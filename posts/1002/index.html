<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【The Cherno-C++】学习笔记二（34-66） | Hmxs's Blog</title><meta name="author" content="徽墨行深,hmxsqaq@gmail.com"><meta name="copyright" content="徽墨行深"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article"><meta property="og:title" content="【The Cherno-C++】学习笔记二（34-66）"><meta property="og:url" content="https://hmxs.games/posts/1002/index.html"><meta property="og:site_name" content="Hmxs&#39;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304182342702.png"><meta property="article:published_time" content="2023-05-31T17:46:00.000Z"><meta property="article:modified_time" content="2024-09-29T19:40:14.427Z"><meta property="article:author" content="徽墨行深"><meta property="article:tag" content="C&#x2F;C++"><meta property="article:tag" content="Note"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304182342702.png"><link rel="shortcut icon" href="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg"><link rel="canonical" href="https://hmxs.games/posts/1002/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【The Cherno-C++】学习笔记二（34-66）",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-09-30 03:40:14"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach(e=>{n.setAttribute(e,t[e])}),document.head.appendChild(n)}),e.getCSS=(e,t=!1)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/hmxs_custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom_loading.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions={restartOnPushState:!1},document.addEventListener("pjax:send",()=>{Pace.restart()})</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304182342702.png)"><nav id="nav"><span id="blog-info"><a href="/" title="Hmxs's Blog"><span class="site-name">Hmxs's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【The Cherno-C++】学习笔记二（34-66）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-31T17:46:00.000Z" title="发表于 2023-06-01 01:46:00">2023-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-29T19:40:14.427Z" title="更新于 2024-09-30 03:40:14">2024-09-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/C-C/">C/C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/C-C/TheCherno/">TheCherno</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="【The Cherno-C++】学习笔记二（34-66）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/1002/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306010145167.jpeg" alt="cherno"></p><blockquote><p><strong>B站up神经元猫翻译版：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uy4y167h2">https://www.bilibili.com/video/BV1uy4y167h2</a></strong></p></blockquote><h2 id="前言">前言</h2><p>C++因为其优异的性能，是游戏开发中最为常用的语言之一，目前的Unity与Unreal两大商用引擎的内核都是采用C++进行编写，作为一个有志于成为游戏开发者的人，这种语言怎么能不学一学呢？</p><p>本文基于油管著名博主，曾任职于EA的The Cherno的C++系列视频，The Cherno作为寒霜引擎的核心开发人员之一，对C++有着非常独到而深刻的理解</p><p>这些笔记记录了我通过The Cherno的系列视频学习C++的一些知识点与理解，希望对你有帮助😉</p><blockquote><p>第一章（1-33）：<a href="https://hmxs.games/posts/1001/">https://hmxs.games/posts/1001/</a></p><p><strong>第二章（34-66）：<a href="https://hmxs.games/posts/1002/">https://hmxs.games/posts/1002/</a></strong></p><p>第三章（67-99）：<a href="https://hmxs.games/posts/1003/">https://hmxs.games/posts/1003/</a></p></blockquote><hr><h2 id="const关键字（34）">const关键字（34）</h2><p><code>const</code>在改变生成的代码方面做不了什么，其有点类似类/结构体中的可见性</p><blockquote><p><strong><code>const</code>是一个可以让我们的代码变得更干净的机制，是对开发人员编写代码的强制特定的规则，被<code>const</code>修饰的东西被承诺不会被改变</strong>（但实际上，这个“承诺”是可以违背的，anyway，it just a promise.🤐）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// 这行代码会报错</span></span><br></pre></td></tr></table></figure><p>如上面的代码所示，被const修饰的变量的值无法被改变，如果我们希望定义一个在程序中永远不变的量，那么<code>const</code>便可以出场了</p><p><code>const</code>是一种声明变量的方式，而我们可以通过强制转换绕过<code>const</code>的限制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE;</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们让指针<code>a</code>指向了<code>const</code>的<code>MAX_AGE</code>,这样便绕过了<code>const</code>，但如果我们尝试通过逆向引用<code>a</code>来写入<code>MAX_AGE</code>便很可能导致程序崩溃，所以最好还是别这么干</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* b = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> c = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><p>上面是三种声明<code>const</code>指针的方式，其中a与b效果完全一样，而c与ab的效果相反</p><p>在a与b中，修改ab本身是被允许的，而修改ab指向的内容是被禁止的，即<code>a = &amp;x</code>可行，而<code>*a = 2</code>不可行；而c的效果则与ab相反</p><p>当然我们也可以通过<code>const int* const a = new int;</code>来让<code>a</code>与``*a`的值都无法改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> mutableX_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutableX_ = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> x_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintX</span><span class="params">(<span class="type">const</span> Entity&amp; entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是<code>const</code>的最后一种用法，在类中修饰方法（只能在类中这样用）</p><p>被<code>const</code>修饰的方法，只能对类中被<code>mutable</code>修饰的字段进行修改，如在上述<code>GetX()</code>方法中，若对<code>X</code>进行修改就会报错</p><p><strong>这种<code>const</code>有什么用呢？</strong></p><p>当我们以<code>const</code>传递类或类的引用时，只有类中的<code>const</code>方法才能被调用，因为<code>const</code>需要保证传入的引用的类无论如何都不会被更改，这种用法常常被用来修饰<code>getter</code>方法</p><p>在上面的代码中，如果<code>GetX()</code>方法没有被<code>const</code>修饰，那么在<code>PrintX()</code>中其便无法被调用</p><hr><h2 id="mutable关键字（35）">mutable关键字（35）</h2><p><code>mutable</code>关键字在C++中有着两种不同的用途</p><p>一是和<code>const</code>一起使用，在上一章的最后有提到，类中被<code>const</code>修饰的方法，只能对类中被<code>mutable</code>修饰的字段进行修改，这种情况往往发生在我们需要调试程序时（这是一种近似于违背承诺的行为，最好还是别大量使用，这会破坏<code>const</code>的意义）</p><p>二是用在<code>lambda</code>表达式中，<code>lambda</code>基本上就像一个一次性小函数，你可以写出来并赋值给一个变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span> </span><br><span class="line">&#123;</span><br><span class="line">    x++;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="comment">// x = 8</span></span><br></pre></td></tr></table></figure><p>在上面的<code>lambda</code>表达式中，如果我们想以值传递的形式传入<code>x</code>，并更改它，那么我们就必须加上<code>mutable</code>关键字</p><p>如果不使用<code>mutable</code>我们便需要创建一个局部变量来对<code>x</code>的值进行一次复制才能实现上面的效果</p><p><em>（当然其实这种用法非常非常少见，The Cherno说他其实完全没见过这么用的🤣）</em></p><hr><h2 id="成员初始化列表（36）">成员初始化列表（36）</h2><blockquote><p><strong>构造函数初始化列表是我们在构造函数中初始化类成员的一种方式</strong></p></blockquote><p>当我们编写类时，通常需要通过构造函数对类的成员进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        name_ = <span class="string">&quot;Default&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    &#123;</span><br><span class="line">        name_ = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们通常会这样来完成字段的初始化，而实际上C++还提供了另外一种语法来实现这件事</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">        : <span class="built_in">name_</span>(<span class="string">&quot;default&quot;</span>), <span class="built_in">age_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上述代码所示，<code>构造函数() : 字段1(初始值1), 字段2(初始值2)</code>通过这样的语法便可实现字段的初始化</p><p><em>需要注意的是，通过这种方法进行初始化时，初始化的顺序是由字段声明的顺序决定的，在上述代码中，即使我们写成<code>: age_(0), name_(&quot;default&quot;)</code>，运行时仍然会按照先<code>name_</code>再<code>age_</code>的顺序初始化，所以在编写初始化代码时，最好直接按照声明的顺序来</em></p><p><strong>为什么我们需要这玩意呢？</strong></p><ul><li>把琐碎繁杂的初始化写在一起，让代码更加整洁易读</li><li>在特定情况下，使用原先的初始化方式会造成性能/内存的浪费，如下面这个例子</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Create Example&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Create Example&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Example e_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        e_ = <span class="built_in">Example</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>Entity</code>类中声明了<code>Example</code>类，并对其进行初始化，如果通过<code>e_ = Example(5)</code>的方式进行，那么<code>Example</code>的两个构造函数都会被运行，即<code>Create Example</code>与<code>Create Example5</code>都会被输出，其原因是在<code>Example e_</code>的创建中默认构造函数会先被调用，而使用初始化列表则不会有这个问题</p><p><strong>综上，我们应该在任何类的成员初始化场景用初始化列表来实现，我们没有理由不使用他们</strong></p><hr><h2 id="三元运算符（37）">三元运算符（37）</h2><blockquote><p><strong>三元运算符是if else语法的语法糖，可以方便地根据特定条件给变量赋值</strong></p><p><strong>语法：<code>变量名 = 条件判断 ? 为真时的值 : 为假时的值</code></strong></p></blockquote><p>三元运算符可以帮助我们清理我们的代码，增加代码的可读性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">y = x &gt; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面的两段代码的意思其实是完全相同的</p><p>同时，如果我们需要赋的值是引用类型，那么三元运算符还能些许加快运算的速度</p><p><strong>需要注意的是，虽然三元运算符可以嵌套，但大量嵌套的三元运算符可读性极差，和其初衷背道而驰，而且会很想让看你代码的人砍死你，所以最好还是别用</strong></p><hr><h2 id="对象的实例化（38）">对象的实例化（38）</h2><p>当我们编写完成了一个类之后，除非其是完全静态的，我们都需要对其进行实例化，而基本上，我们有两个实例化方法的选择：<strong>在栈上创建/在堆上创建</strong>，这两种方法的主要区别在于内存分配的位置</p><p>栈对象，拥有一个自动的生命周期，这由它们被声明的地方作用域决定，只要超出作用域，其内存便会被自动释放</p><p>而堆对象则不同，堆对象的内存需要我们进行手动释放</p><h3 id="栈对象">栈对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entity e;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Entity e = <span class="built_in">Entity</span>();</span><br></pre></td></tr></table></figure><p>这样便可简单实例化一个类对象</p><p><em>与Jave/C#不同的是C++的<code>Entity e</code>并不单指声明，其效果等于<code>Entity e = Entity()</code>，会调用类的默认构造函数</em></p><p><strong>几乎所有时候，只要我们可以这样创建对象，我们都应该这样创建，这是C++中最快也是最易管控的实例化对象的方法</strong></p><h3 id="堆对象">堆对象</h3><p>当我们需要显式控制类的生命周期时 或 我们需要实例化的类很大/很多（栈的内存往往很小）时，我们便需要借助堆来实例化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br></pre></td></tr></table></figure><p>堆对象实例化的关键便是<code>new</code>关键字，当我们调用<code>new Entity</code>时，它在堆上为<code>Entity</code>类分配内存，并返回实例化的类在堆上被分配的内存地址</p><p><em>这与C#/Java中的语法相似，C#中的struct是在栈上的，而所有类都在堆上，而Java全在堆上</em></p><h3 id="尽量使用栈而不是堆">尽量使用栈而不是堆</h3><ul><li><p>性能问题：在堆上分配内存要比栈花费更长的时间</p></li><li><p>操作繁琐：堆需要手动释放内存（<code>delete</code>）</p></li></ul><hr><h2 id="new关键字（39）">new关键字（39）</h2><blockquote><p><strong><code>new</code>是一个操作符，主要作用是在堆上分配内存，其会根据你指定的类型在堆上找到对应大小的内存空间，并返回该空间的地址，对类来说，new还会调用构造函数</strong></p><p><strong>语法：<code>new 类型</code></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">// C++风格</span></span><br><span class="line">Entity* e = (Entity*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Entity)); <span class="comment">// C风格</span></span><br></pre></td></tr></table></figure><p>上述两行代码的唯一区别便是<code>new</code>会调用构造函数，而<code>malloc</code>不会，大部分情况下<code>new</code>会调用<code>malloc</code>进行内存的分配</p><p><code>delete</code>关键字会释放堆中的内存，如果是类，其还会调用析构函数，其也是借用C中的<code>free</code>函数实现的，这点与<code>new</code>类似</p><p><strong><code>new</code>和<code>delete</code>总是应该成对出现，被<code>new</code>分配的内存只有在被<code>delete</code>释放后才能被再次使用</strong></p><hr><h2 id="隐式转换与explicit关键字（40）">隐式转换与explicit关键字（40）</h2><blockquote><p><strong>隐式代表不需要明确地告诉类要做什么，类似于自动，编译器会通过上下文自行推导构造函数</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(<span class="number">-1</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> age)</span><br><span class="line">        : <span class="built_in">name_</span>(<span class="string">&quot;Default&quot;</span>), <span class="built_in">age_</span>(age) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1 = <span class="string">&quot;Hmxs&quot;</span>; <span class="comment">// 隐式转换“Hmxs”-&gt;Entity(&quot;Hmxs&quot;)</span></span><br><span class="line">    Entity e2 = <span class="number">20</span>; <span class="comment">// 隐式转换20-&gt;Entity(20)</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当构造函数限定条件足够多时，如类的构造函数只接受一个字符串为参数，而你又正好让类等于了一个字符串，那么编译器会为你自行推导，生成构造函数</p><p>这很酷，可以简化代码，但清晰的代码才是最好的，还是少用吧</p><blockquote><p><strong><code>explicit</code>关键字则代表禁用该构造函数的隐式转换，如果你需要通过此构造函数进行类的实例化，那么你必须显式调用此构造函数</strong></p></blockquote><p><code>explicit</code>可以确保类型转换的安全，不会发生意外的隐式转换</p><hr><h2 id="运算符及其重载（41）">运算符及其重载（41）</h2><blockquote><p><strong>运算符是一种符号，通常代替一个函数来执行一些事情，如 <code>+ - * / += -&gt; &amp; &lt;&lt; new delete</code> 等</strong></p></blockquote><p>本质上运算符就是不用写函数名的函数，可以帮我们清理代码</p><p>而运算符重载的应用往往非常少，当我们需要运算符重载时，往往是类中一种特殊的类型需要处理或者类本身需要处理</p><p>如下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x + other.x, y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector2 <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x * other.x, y * other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们实现了一个<code>Vector2</code>结构体，并想要实现向量的加法与乘法，于是我们编写了<code>Add</code>与<code>Multipy</code>函数</p><p>但如果这样实现，最后在使用时很可能会变成这样<code>Vector2 result = pos1.Add(pos2.Multiply(pos3));</code>，虽然结果没问题但是可读性很差，使用起来也并不方便</p><p>这时使用运算符重载便可以清理我们的代码，让其变得更加直观</p><p><strong>我们只需更改函数名为<code>operate+/operate*</code>即可重载对应运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Vector2 <span class="keyword">operator</span>+(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x + other.x, y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector2 <span class="keyword">operator</span>*(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x * other.x, y * other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后直接使用运算符即可<code>Vector2 result = pos1 + pos2 * pos3;</code>，代码一下子便清晰了许多</p><p><strong>下面是重载<code>&lt;&lt;</code>达成类输出的的一个例子：</strong></p><p>如果我们想输出一个上面的<code>Vector2</code>变量，直接<code>cout</code>将会报错<code>std::cout &lt;&lt; pos1 &lt;&lt; &quot;\n&quot;;</code>，而我们可以重载<code>&lt;&lt;</code>达成类似C#中<code>ToString()</code>的效果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> Vector2&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>  stream &lt;&lt; other.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; other.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><code>cout</code>是C++中的流式输出方法，其实际是一个类型为<code>ostream</code>的流数据</em></p><p>重载过后便可以正常输出了<code>std::cout &lt;&lt; pos1 &lt;&lt; &quot;\n&quot;;</code></p><hr><h2 id="this关键字（42）">this关键字（42）</h2><blockquote><p><strong><code>this</code>是一个指向当前对象实例的指针，通过this可以访问类中的非静态字段方法</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是一个<code>this</code>应用的例子，当我们传入的参数与类字段名相同时，<code>x = x</code>显然是有问题的,<code>this</code>可以帮助编译器进行区分</p><p>当然，<code>this</code>本身只是一个指针，一个指向当前对象本身的指针，我们可以在类中可以像使用其他指针一样使用它，比如<code>Entity* e = this</code></p><hr><h2 id="对象的生命周期（43）">对象的生命周期（43）</h2><p>作用域通常可以和一对大括号等价，而一旦超出作用域，作用域中的栈对象都会被释放</p><p><strong>下面是一个例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Create Entity&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroy Entity&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面这个简单的<code>Entity</code>类中，当其被创建时会输出&quot;Create Entity&quot;，而被释放时会输出&quot;Destroy Entity&quot;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Entity e;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的main函数中，<code>e</code>在栈中被创建，当运行到第5行时作用域结束，<code>e</code>被释放，&quot;Destroy Entity&quot;被输出</p><p>而如果我们通过堆来创建<code>e</code>时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有&quot;Create Entity&quot;会被输出</p><p><strong>下面是另外一个关于作用域的例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">CreateArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数尝试创建一个数组并返回其指针，但实际上这段代码是完全错误且无效的，<code>int array[50]</code>是以栈的方式创建数组，而在函数结束时，<code>array</code>的作用域便结束了，其内存会被释放</p><p><strong>作用域在限制我们的同时，也为我们提供了一些有用的特性，善用作用域可以帮我们实现很多功能</strong></p><p><strong>以下是一个利用作用域实现堆对象自动销毁的例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* ptr_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* ptr)</span><br><span class="line">        : <span class="built_in">ptr_</span>(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ScopedPtr</code>包裹了一个<code>Entity</code>类的指针，在栈中创建<code>ScopedPtr</code>对象，当其超出作用域被自动销毁时，其会自动调用析构函数，在析构函数中释放包裹着的<code>Entity</code>类，以此便实现了堆<code>Entity</code>对象的自动销毁</p><p>除此之外作用域与生命周期还有很多妙用，如自动计时的Timer类，会在之后进行介绍</p><hr><h2 id="智能指针（44）">智能指针（44）</h2><blockquote><p><strong>智能指针本质上是一个原始指针的包装</strong></p><p><strong>当你使用智能指针时，它会调用new为你分配内存，然后基于你使用的智能指针，这些内存会在某一时刻被自动释放</strong></p></blockquote><h3 id="unique-ptr"><code>unique_ptr</code></h3><p><code>unique_ptr</code>是作用域指针，当超出作用域时，它会被销毁然后调用delete；其不可复制，因为这会导致两个指针指向相同的内存，当其中一个将内存释放后，另一个便会指向已经被释放的内存，这会带来问题</p><p><em>要使用智能指针我们需要引入<code>memory</code>头文件</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity1</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity2 = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();</span><br></pre></td></tr></table></figure><p>以上是两种<code>unique_ptr</code>的使用方式，后者对异常处理更加友好</p><p><em>需要注意的是<code>unique_ptr</code>的构造函数是<code>explicit</code>的，需要显式调用</em></p><p>使用<code>unique_ptr</code>声明的<code>entity1</code>和<code>entity2</code>都会在作用域结束时被销毁</p><p><strong><code>unique_ptr</code>是最简单的智能指针，是有用且低开销的，缺点是其不能复制</strong></p><p><em><code>std::unique_ptr&lt;Entity&gt; entity3 = entity2;</code>&lt;-为了防止我们写出这种代码，尝试去复制<code>unique_ptr</code>，<code>unique_ptr</code>的复制构造函数和<code>=</code>操作符都被删除了，这样的代码会直接报错</em></p><h3 id="shared-ptr"><code>shared_ptr</code></h3><p><code>shared_ptr</code>是共享指针，在大部分编译器中，其通过引用计数实现了智能指针的共享，每当共享指针被复制时，其内部的引用计数便会加一，当共享指针被释放时，引用计数便会减一，当引用数量为0时，共享指针才会真正释放其指向的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Entity&gt; <span class="title">entity1</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">std::shared_ptr&lt;Entity&gt; entity2 = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br></pre></td></tr></table></figure><p>我们仍有两种方式使用<code>shared_ptr</code>，但对于<code>shared_ptr</code>来说，后者明显更好</p><p><em>在<code>unique_ptr</code>中使用<code>make_unique</code>带来的优势仅仅是会抛出异常，但对于<code>shared_ptr</code>来说，因为其需要声明一块专用的控制块内存用于存储应用计数，通过<code>new</code>进行内存分配再传递给<code>shared_ptr</code>会带来两次内存分配，而使用<code>make_shared</code>则可以将两次内存分配组合在一起，获得更好的效率</em></p><h3 id="weak-ptr"><code>weak_ptr</code></h3><p><code>weak_ptr</code>通常和<code>shared_ptr</code>一起使用，<code>weak_ptr</code>可以被复制，但是同时不会增加引用计数，仅仅声明这个指针还活着</p><p>同时<code>weak_ptr</code>可以查询其指向的内存块是否被释放了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;Entity&gt; weak = entity2;</span><br></pre></td></tr></table></figure><h3 id="什么时候应该使用智能指针">什么时候应该使用智能指针</h3><p>根据实际情况而定，当你不需要手动管理内存时，智能指针会非常方便</p><p>在使用智能指针时，<code>unique_ptr</code>应该被优先考虑，因为其几乎没有开销，而当我们需要共享数据而<code>unique_ptr</code>无法实现时，<code>shared_ptr</code>就应该被使用了，即使其会带来一些额外的开销</p><hr><h2 id="复制构造函数（45）">复制构造函数（45）</h2><blockquote><p><strong>拷贝指的是复制数据/内存，让一份数据拥有多个副本</strong></p></blockquote><p>拷贝往往会耗费很多时间，但也会让我们得以实现很多功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = a;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的值拷贝的过程，<code>a</code>和<code>b</code>是两个独立的变量</p><p>而当我们使用<code>new</code>来分配内存时，事情就会有些不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* a = new int(1);</span><br><span class="line">int* b = a;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们同样进行了一次拷贝，但是这次拷贝的是指针，这意味着我们创造了两个保存着相同地址的指针</p><p>但是无论如何，当你使用<code>=</code>，即赋值操作符时，你总是在拷贝值</p><p><em>除引用之外，因为引用仅仅是别名，我们无法重新分配引用，只能改变其指向，并不是拷贝</em></p><p><strong>下面会实现一个原始的字符串类，尝试让其具有可复制性：</strong></p><p><em>这个字符串类将只采用C++的原始特性进行编写，为了让其更有教学意义</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* buffer_;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">    &#123;</span><br><span class="line">        size_ = <span class="built_in">strlen</span>(string);</span><br><span class="line">        buffer_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer_, string, size_);</span><br><span class="line">        buffer_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; string.buffer_;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实现了一个基本的<code>String</code>类，其会自动分配分配/销毁内存，并且重载了<code>&lt;&lt;</code>操作符，让其可以接受流输出</p><p>这看起来很完善，但当我们尝试拷贝一个<code>String</code>类时，如下面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="string">&quot;Hmxs&quot;</span>;</span><br><span class="line">String copy = string;</span><br></pre></td></tr></table></figure><p>但当程序结束时，程序会崩溃，这是因为我们实际上进行的是一次浅拷贝，在<code>copy</code>实际拷贝的是<code>string</code>中的<code>char</code>类型指针，并没有重新进行堆内存的分配，所以当程序结束时，会运行两次<code>delete[] buffer_</code>去释放同一片内存，导致了程序的崩溃</p><p><strong>而如何使复制时进行深拷贝呢？</strong></p><p>我们可以创造一个新函数返回一个字符串，但这不够优雅，我们应该使用的方法是-<strong>拷贝构造函数</strong></p><blockquote><p><strong>拷贝构造函数是一个构造函数，当你在进行拷贝操作，将一个变量的值拷贝给另一个变量，也就是使用<code>=</code>，并且<code>=</code>左右两边变量类型相同时，会调用的构造函数</strong></p></blockquote><p>使用<code>类名(const 类名&amp; 变量名)&#123;&#125;</code>即可构建拷贝构造函数（如果不手动设定，C++会提供默认的拷贝构造函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    : <span class="built_in">size_</span>(other.size_)</span><br><span class="line">&#123;</span><br><span class="line">    buffer_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer_, other.buffer_, size_ + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，程序便不会崩溃了</p><p>但是仍有一点我们需要注意，只要我们对<code>String</code>类型的变量进行值的传递，如传递给一个函数，其就会对自己进行一次深拷贝，这会非常影响效率，而我们可以通过引用的方式进行值的传递，如<code>Print(const String&amp; other)</code>,这样一来传递的便是变量本身，而非其复制了</p><p>在使用引用传值时，<strong>总是、总是、总是使用const引用传递对象</strong>，这会帮我们避免很多问题</p><hr><h2 id="箭头操作符（46）">-&gt;箭头操作符（46）</h2><blockquote><p><strong><code>x</code>是一个指针，拥有一个<code>print</code>方法，则<code>x-&gt;print()</code> = <code>(*x).print()</code></strong></p></blockquote><p>当我们想要通过指针访问类中的字段/方法时，我们往往需要先对指针做逆引用运算后，再使用<code>.</code>运算符访问其中的方法/字段，同时因为运算符优先级的问题，为了达到我们需要效果我们还需要加一个括号，最后的代码便需要写成<code>(*x).</code>，这写起来非常笨重；我们也可以通过在外面包一层引用来解决这个问题，但是这同样需要多写一行；此时箭头操作符便应运而生了，箭头操作符是上述操作的一个快捷方式而已</p><p>以上就是<code>-&gt;</code>箭头操作符的默认用法了，而作为一个操作符，我们同样可以重载它，<strong>以下是一个例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* obj_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* entity)</span><br><span class="line">        : <span class="built_in">obj_</span>(entity) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> obj_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们手动实现了一个Entity的智能指针类，此时我们便可以通过<code>ScopedPtr</code>来声明堆中的<code>Entity</code>类，但此时，通过<code>ScopedPtr</code>声明的类无法通过<code>-&gt;</code>操作符访问其中的方法，因为实际的类是<code>ScopedPtr</code>中的成员变量，此时我们便可以通过重载箭头操作符来达成我们想要的效果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entity* <span class="keyword">operator</span>-&gt; () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> obj_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载箭头操作符使其返回<code>ScopedPtr</code>中的成员变量即可</p><hr><h2 id="动态数组std-vector（47）">动态数组<code>std::vector</code>（47）</h2><blockquote><p><strong>动态数组是指不定长的数组，我们创建它时不需要给定固定的内存空间，其会在运行时进行空间的动态分配</strong></p></blockquote><p>C++STL中的动态数组被称为<code>vector</code>，但它实际上并不是数学意义上的“向量”，也不是C#中的Vector2/Vector3，其实际更像一个<code>ArrayList</code></p><p><em>至于它为什么起了个这么奇怪的名字，听说故事很复杂🤣</em></p><p><strong>下面是C++STL中<code>vector</code>的基本使用方法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> <span class="comment">// 任意数据类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; stream, <span class="type">const</span> Data&amp; data)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; data.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; data.y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; data.z;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// vector的创建</span></span><br><span class="line">    std::vector&lt;Data&gt; vectors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector元素的添加</span></span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素删除</span></span><br><span class="line">    vectors.<span class="built_in">erase</span>(vectors.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历方法一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vectors.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; vectors[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 遍历方法二</span></span><br><span class="line">    <span class="keyword">for</span> (Data&amp; date : vectors)</span><br><span class="line">        std::cout &lt;&lt; date &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>需要注意的是，传递<code>vector</code>时务必使用引用进行传递，防止对整个<code>vector</code>进行复制</strong></p><hr><h2 id="std-vector使用优化（48）"><code>std::vector</code>使用优化（48）</h2><p>虽然C++为我们提供了STL，但是STL中的数据结构在设计过程中，其性能往往不是最优先考虑的要素，而C++的<code>vector</code>在每次需要扩充数组容量时，都会先分配一个新的更大的空间，将原先的数据复制到新空间中，再删除原先的空间，这听上去性能就很差，而如果我们没有正确地使用它，这种分配往往会经常发生。</p><p><strong>下面是一种更好地使用<code>vector</code>类的方式，让<code>vector</code>的效率更高：</strong></p><p>先来看一个反面教材</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> Data&amp; other)</span><br><span class="line">        : <span class="built_in">x</span>(other.x), <span class="built_in">y</span>(other.y), <span class="built_in">z</span>(other.z)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Data&gt; vectors;</span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>Data</code>类是一个普通的数据类，其在每次被复制时都会输出一个“<code>Copy</code>”，我们创建了一个<code>vector</code>变量，并通过<code>push_back</code>方法向其中添加了3个元素，这看起来一点毛病没有，但如果我们运行这段代码，我们会发现有6个<code>Copy</code>被输出了，这意味着在加入元素的过程中，<code>Data</code>被复制了6次，这太糟糕了</p><p>而造成这6次复制的原因有两个：类的实例化 与 <code>vector</code>的扩容</p><ul><li><p>类的实例化：在上述代码中，我们是在栈中实例化类的，而使用<code>push_back</code>方法会先在栈中给类分配内存，再将对象移动到<code>vector</code>变量处，这一过程便会进行一次类的复制；而解决方法也非常简单，<strong>将<code>push_back</code>替换为<code>emplace_back</code>即可</strong>，<code>emplace_back</code>会直接在<code>vector</code>变量的内存处构建类，省去了复制过程</p></li><li><p><code>vector</code>的扩容：C++的<code>vector</code>在每次需要扩充数组容量时，都会先分配一个新的更大的空间，将原先的数据复制到新空间中，再删除原先的空间；而<strong>我们可以通过<code>reserve</code>方法为vector设定初始的容量</strong>，这样在达到容量上限前都不会进行空间的复制</p></li></ul><p>通过上述两个方法优化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Data&gt; vectors;</span><br><span class="line">    vectors.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">    vectors.<span class="built_in">emplace_back</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    vectors.<span class="built_in">emplace_back</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    vectors.<span class="built_in">emplace_back</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，我们可以发现一个<code>Copy</code>都没有输出，说明一次复制行为都没有发生，这大大提高了效率；要知道在原先的代码下，复制次数会随元素添加次数的增加而呈指数级增加，这对性能的损耗将是可怕的</p><hr><h2 id="库的使用（49、50）">库的使用（49、50）</h2><p>在python、C#、Java等语言中，添加库是一项非常简单的任务，但是在C++中，似乎这里成了问题的重灾区，而实际上在C++中添加库并不困难</p><p><strong>以下将通过链接二进制文件的形式在C++中链接GLFW库：</strong></p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260202572.png" alt="image-20230626020227432" style="zoom:67%"><p>下载解压GLFW预编译二进制文件后，我们便可以得到上述文件，它们主要由两部分组成：include文件与lib文件，它们分别对应头文件与具体的函数实现，而对于这两部分我们都需要进行加载</p><p><em>C++存在着两种库：静态库（.lib）与动态库（.dll），它们基本的区别是静态库会被编译进exe文件中，而动态库则是在运行时装载的，之后会有篇章专门介绍他们</em></p><p>下面是两种库引入方式的介绍：</p><h3 id="静态链接">静态链接</h3><p>将include文件夹与对应平台的lib文件夹复制到项目文件夹中，而在lib文件夹中我们可以看到三个文件</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260214664.png" alt="image-20230626021447618"></p><p>其中<code>glfw3.lib</code>为静态库，而<code>glfw3.dll</code>为动态库，<code>glfw3dll.lib</code>为动态库的导入库，其中包含了动态库中所有函数、符号的位置，以便我们进行使用（没有它我们也可以使用动态库，但是我们需要通过函数名来访问它）</p><p>要链接到库，我们首先需要将其头文件包含到项目中，我们可以在<code>属性/C++/常规/附加包含目录</code>将库文件夹包含在项目中，如下图所示</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260227665.png" alt="image-20230626022703597" style="zoom:67%"><p>之后即可在代码中使用<code>#include &quot;GLFW/glfw3.h&quot;</code>引入头文件了，但到这里我们仅仅只是引入了头文件，并没有包含函数的实现，而这一步需要我们在链接器选项中进行操作</p><p>在<code>属性/链接器/常规/附加库目录</code>中添加库文件夹的地址</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260234490.png" alt="image-20230626023444430" style="zoom:67%"><p>在<code>属性/链接器/输入/附加依赖项</code>中添加<code>glfw3.lib</code></p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260235757.png" alt="image-20230626023557693" style="zoom:67%"><p>即可完成库文件的包含，到此我们便可以在程序中调用库函数了</p><h3 id="动态链接">动态链接</h3><p>静态链接发生在编译时，而动态链接发生在运行时</p><p>在静态链接时，编译器和链接器会知道完全的库的代码，所以会允许更多的优化发生</p><p>而动态链接则只有在你运行exe文件时，库才会被加载，其实际上不是可执行文件的一部分</p><p>那么应该如何使用动态链接呢？</p><p>其实只需要<code>属性/链接器/输入/附加依赖项</code>中加入<code>glfw3dll.lib</code>即可</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307180302256.png" alt="image-20230718020213161"></p><p>因为GLFW支持静态链接与动态链接都使用同一个头文件，所以我们的<code>include</code>也不需要更改</p><p>做完这一步之后，我们已经可以编译通过了，但是在运行时仍然会报错，这便是因为到此我们已经向编译器保证了<code>dll</code>库会存在，但实际上在运行时程序还是需要找到对应的<code>dll</code>文件的，而程序会默认在exe文件的根目录中寻找<code>dll</code>文件，所以我们只需将<code>dll</code>文件和<code>exe</code>文件放在一起便大功告成了，而我们同样可以手动指定程序对于<code>dll</code>文件的搜索范围。</p><hr><h2 id="处理多返回值（52）">处理多返回值（52）</h2><p>在C++的默认情况下，是无法返回多个类型的返回值的，但我们可以通过一些手段来实现这一点</p><p>下面是一些方法的总结：</p><ol><li><strong>使用引用/指针传入外部值后，在内部修改</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultipleReturnValue</span><span class="params">(std::string&amp; outValue1, <span class="type">int</span>&amp; outValue2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outValue<span class="number">1.</span><span class="built_in">append</span>(<span class="string">&quot; Hello&quot;</span>);</span><br><span class="line">    outValue2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string value1 = <span class="string">&quot;NiHao&quot;</span>;</span><br><span class="line">    <span class="type">int</span> value2 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">MultipleReturnValue</span>(value1, value2);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value1: &quot;</span> &lt;&lt; value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value2: &quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：效率最高；可以返回任意数量、任意类型的值</p><p><strong>缺点</strong>：看着比较乱，不够直观</p><ol start="2"><li><strong>使用<code>std::array</code>/<code>std::vector</code></strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">MultipleReturnValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::vector&lt;std::string&gt;&#123; <span class="string">&quot;Hello1&quot;</span>,<span class="string">&quot;Hello2&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vector = <span class="built_in">MultipleReturnValue</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value1: &quot;</span> &lt;&lt; vector[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value2: &quot;</span> &lt;&lt; vector[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：好像没什么优点</p><p><strong>缺点</strong>：只能传递一种类型；得到返回值时无法显示变量名</p><ol start="3"><li><strong>使用<code>std::tuple</code>/<code>std::pair</code></strong></li></ol><p><code>tuple</code>和<code>pair</code>都不关心其中的变量类型，其余与<code>array</code>和<code>vector</code>类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">MultipleReturnValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> tuple = <span class="built_in">MultipleReturnValue</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value1: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tuple) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value2: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tuple) &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：与<code>array</code>和<code>vector</code>相比，可以传递多类型了</p><p><strong>缺点</strong>：得到返回值时无法显示变量名，且解包写法十分繁琐</p><ol start="4"><li><strong>使用自建结构体传递返回值</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ReturnValues</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string Value1;</span><br><span class="line">    <span class="type">int</span> Value2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ReturnValues <span class="title">MultipleReturnValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> returns = <span class="built_in">MultipleReturnValue</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value1: &quot;</span> &lt;&lt; returns.Value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value2: &quot;</span> &lt;&lt; returns.Value2 &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：清晰明了，可读性高，写法简单；可传递任意类型、任意数量的变量；解包可以显示变量名</p><p><strong>缺点</strong>：与方法1相比效率稍差</p><blockquote><p><strong>总的来说，法1与法4较为实用</strong></p></blockquote><hr><h2 id="模板template（53）">模板<code>template</code>（53）</h2><p>C++的<code>template</code>有点类似其他语言中的泛型<code>Generic</code>，但实际上<code>template</code>比泛型要强大地多</p><p>模板有点像宏，它实际上可以帮你完成非常多的事情，而泛型往往受限与类型系统以及其他很多因素</p><blockquote><p><strong><code>template</code>允许你定义一个可以根据你想要的用途进行编译的模板，你可以编写一套规则，来让编译器帮你写代码</strong></p><p><strong>这有点像一种蓝图，你只需要制定规则，而实际的生产由编译器进行</strong></p></blockquote><p>当我们想要编写一系列函数，其大部分内容都相同，只是接受的参数不同时，我们便可以使用<code>template</code>，下面是一个例子：</p><p>我们想要编写一个<code>Print</code>函数，让其可以分别输出整数、浮点数、字符串，我们通常需要创建多个函数重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">float</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(std::string value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1.1f</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要增加更多类型我们就需要更加跟多重载，这可行，但是非常麻烦，而使用<code>template</code>可以大幅简化代码，就像下面这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1.1f</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><code>T</code>可以自定义，如<code>typename Hmxs</code>同样可以</em></p><blockquote><p><code>template</code>函数实际上并不真实存在，实际的函数会在被调用时被自动创建</p></blockquote><p>而在上面的代码中，在我们调用<code>Print</code>函数时，实际包含了一层隐式的类型推导，如在<code>Print(1)</code>中，编译器知道<code>1</code>是一个整数，所以其创建了一个<code>T</code>为<code>int</code>的<code>Print</code>函数</p><p>而实际上我们同样可以在调用模板函数时显式地指定类型，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Print</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上面是一种<code>template</code>在函数中的简单应用，而<code>template</code>实际完全不局限与函数中</p><p>如我们想创建一个自定义的在栈中生成的<code>Array</code>类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T array_[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; m_array&#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; m_array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>如此强大！</code></strong></p><p>而这其实也只是<code>template</code>应用的冰山一角，大量使用<code>template</code>的编码方式被称为meta programming元编程</p><p>但实际上，任何事情都有两面性，<code>template</code>十分强大，但过分使用它会让你的代码的可读性降低，以至于你不得不为理解<code>template</code>而花费更多地时间</p><p>当一个基于<code>template</code>的系统变得过于深入与庞大时，将是非常疯狂的，没人会知道这玩意是怎么运行的</p><p>So, we should balance them well.</p><hr><h2 id="堆与栈内存的比较（54）">堆与栈内存的比较（54）</h2><p>栈（<code>stack</code>）内存和堆（<code>heap</code>）内存是ram中实际存在的两个区域</p><p>栈通常是一个预定义大小的内存区域，通常约为2兆字节左右；堆也是一个预定了默认值的区域，但堆内存可以生长，并随着应用程序的进行而改变</p><p>而最重要的是，这两个内存区域的实际位置（物理上），在我们的ram中是完全一致的</p><p><strong>为什么栈会比堆快？</strong></p><p>在栈上分配内存，其实只是一行cpu指令：将栈头指针移动一定的字节</p><p>而在堆上进行内存分配则复杂地多，cpu需要记录许多信息</p><hr><h2 id="宏Macro（55）">宏<code>Macro</code>（55）</h2><blockquote><p><strong>宏主要在预处理阶段发挥作用，我们可以通过宏将代码中的文本替换为其他东西，这基本上就像遍历我们的代码然后进行查找和替换，但实际上并没有那么简单粗暴</strong></p></blockquote><p>这听起来有点像之前说到的模板<code>template</code>，但宏发生作用的时间会比模板更早</p><p>下面是一个宏的使用例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT std::cin.get()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用<code>WAIT</code>替代了<code>std::cin.get()</code></p><p>这看上去更简洁了，<strong>但实际上这是非常错误的用法</strong>，用宏去替换原来理所应当的代码，只会让看代码的人觉得疑惑</p><p>而下面这种宏函数的用法则是合理的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(message) std::cout &lt;&lt; message &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>宏函数的优点</strong>：没有普通函数保存寄存器、参数传递和返回值传递的开销，展开后代码效率会更高</p><p>同时我们可以使用宏定义来区分<code>Debug</code>模式与<code>Release</code>模式的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG(message) std::cout &lt;&lt; message &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG(message)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="auto关键字（56）"><code>auto</code>关键字（56）</h2><blockquote><p><strong><code>auto</code>的作用非常简单，它可以为我们自动推导变量的类型，它在某些时候十分有效，但我们不应该滥用它</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">GetHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> hello = <span class="built_in">GetHello</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个<code>auto</code>的使用例，我们用其来接收函数的返回值</p><p>其一个好处便是，如果我们的函数返回值类型发生了变化，如果我们使用了auto，那么我们便不需要再改动接收处的变量类型了</p><p>但这也是一把双刃剑，这也意味着，如果我们接下来的代码中有用到原来的类型特性，那么便会带来更大的问题，这降低了可读性</p><p>这种用法见仁见智</p><p><code>auto</code>还有一种用法便是简化类型，当我们面对一个极其长的类型名时，我们便可以使用<code>auto</code>，这样反而会增加可读性，如下面这个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; name_vector;</span><br><span class="line">    name_vector.<span class="built_in">emplace_back</span>(<span class="string">&quot;Hmxs&quot;</span>);</span><br><span class="line">    name_vector.<span class="built_in">emplace_back</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;std::string&gt;::iterator iterator = name_vector.<span class="built_in">begin</span>(); iterator != name_vector.<span class="built_in">end</span>(); iterator++)</span><br><span class="line">        std::cout &lt;&lt; *iterator &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iterator = name_vector.<span class="built_in">begin</span>(); iterator != name_vector.<span class="built_in">end</span>(); iterator++)</span><br><span class="line">        std::cout &lt;&lt; *iterator &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="静态数组std-array（57）">静态数组<code>std::array</code>（57）</h2><blockquote><p><strong><code>std::array</code>是C++STL的一部分，其是专门用来处理静态数组的；所谓静态数组，便是定长数组，在你完全初始化array的初始化之后，其长度便无法改变了</strong></p></blockquote><p>在使用上，<code>array</code>几乎和C语言风格的数组别无二致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 10&gt; array;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这看上去理所当然，那么问题便出现了，我们应该使用它还是C语言的原生数组呢？</strong></p><blockquote><p><strong>结论是：我们应该尽量使用<code>std::array</code></strong></p></blockquote><p>首先，<code>std::array</code>是非常快的，其是储存在栈上的，几乎没有性能损耗</p><p>其次，因为<code>array</code>属于STL，其包含了许多内置函数，可以简化我们的代码，如用于排序的<code>sort</code></p><p>最后，使用<code>array</code>我们便不需要自己维护数组的大小了，<code>array.size()</code>函数可以返回数组大小，并且这个<code>size</code>属于模板，并不占用额外的内存</p><hr><h2 id="函数指针（58）">函数指针（58）</h2><blockquote><p><strong>函数指针，是将一个函数赋值给一个变量的方法；当我们直接传递函数名而不带括号时，我们便传递了一个函数指针</strong></p></blockquote><p>在一些情况下，函数指针的使用可以大幅简化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span>(*function)() = Print;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们可以使用<code>返回值 (*变量名)()</code>创建一个函数指针，并通过函数指针调用函数</p><p>而这么写往往比较奇怪，所以我们一般会使用<code>auto</code>/<code>typedef</code>/<code>using</code>完成函数指针的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PrintFunc)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">PrintFunc func1 = Print;</span><br><span class="line"><span class="keyword">auto</span> func2 = Print;</span><br></pre></td></tr></table></figure><p>下面是关于函数指针的一个实际用例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vector, <span class="type">void</span>(*func)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : vector)</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vector = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(vector, Print);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过函数指针将函数像变量一样在函数中传递，达成“回调”的效果</p><p>此外，<code>lambda</code>表达式也可以应用在函数指针中，<code>lambda</code>表达式将在下一章被详细介绍</p><hr><h2 id="lambda表达式（59）"><code>lambda</code>表达式（59）</h2><blockquote><p><strong><code>lambda</code>本质是我们定义的一种被称为匿名函数的方法</strong></p><p><strong>我们可以通过这种方法在不实际创建函数的情况下创建函数，就像一个快速的一次性函数</strong></p></blockquote><p><strong>我们什么时候可以使用<code>lambda</code>？</strong></p><p>只要你有一个函数指针，你便可以在C++中使用<code>lambda</code></p><p>当我们需要一个回调函数时，<em>即，我们想要指定一段代码，在未来的某一时刻被调用，但我们无法得知这一确切的时间时</em>，<code>lambda</code>是一个很好的方法用于编写回调函数</p><p>语法：<code>[捕获](参数) &#123;函数体&#125;</code></p><p>C++中的<code>lambda</code>表达式由三部分组成：</p><ul><li>捕获为<code>lambda</code>对于外部变量的态度，<code>[=]</code>为以值捕获所有外部变量，<code>[&amp;]</code>为以引用捕获所有外部变量，或者也可以直接传入需要捕获的变量</li><li>参数与正常函数的参数列表类似，如<code>(int value)</code></li><li>函数体也与正常函数类似，是函数的主体代码</li></ul><hr><h2 id="为什么不应该使用using-namespace-std（60）">为什么不应该使用<code>using namespace std</code>（60）</h2><p>当我们需要调用C++标准库中的内容时，我们总是需要加上前缀<code>std::</code>，很多人会觉得这很麻烦</p><p>而在某一作用域或全局加上<code>using namespace std</code>，我们便可以直接调用标准库的内容</p><p>这在一定程度上让代码变得简洁，但实际上，这并不是什么好习惯，以下是不使用<code>using namespace std</code>的几个原因</p><ul><li>让代码变得更易混淆，当我们不使用<code>using namespace std</code>时，我们可以通过函数前的<code>std::</code>清晰地看出这个函数是标准库中的，而使用<code>using namespace std</code>，会让代码的可读性降低，变得更易混淆</li><li>当遇到不用命名空间中的同名函数时，<code>using namespace</code>可能会导致歧义甚至编译错误</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> orange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string temp = str;</span><br><span class="line">        std::<span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        std::cout &lt;&lt; temp &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> orange;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，命名空间<code>apple</code>与<code>orange</code>中存在同名函数<code>print</code>，而此时因为隐式转换优先级的问题，我们实际调用的<code>print</code>将是<code>orange</code>中的，这种问题在实际遇到时很难发现，甚至不会有报错，但你会得到错误的结果，而不使用<code>using namespace</code>便可以很大程度上解决该问题</p><blockquote><p>并且，需要强调的是：<strong>永远不要在头文件中使用<code>using namespace</code>，天知道什么会被包含进来</strong></p></blockquote><p>在作用域很小时，或包含自己的库时，<code>using namespace</code>是可接受的，但是对于<code>std</code>这类库，最好永远避免使用<code>using namespace</code></p><hr><h2 id="命名空间（61）">命名空间（61）</h2><blockquote><p><strong>命名空间存在的主要原因，是为了避免命名冲突</strong></p></blockquote><p>C与C++语言中，名字完全相同的两个符号是不允许同时存在的，如我们无法拥有两个类型都为<code>int</code>，名字都为<code>a</code>的变量</p><p>在C语言中，我们通常通过在名字前增加前缀来防止命名冲突，如对于<code>print</code>函数而言，便可以写为<code>apple_print</code>与<code>orange_print</code>来区分不同的变量</p><p>而在C++中，我们便可以更加便捷地通过命名空间来实现这一点，就像下面这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> orange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们可以使用<code>::</code>来访问某一命名空间，如<code>apple::print()</code></p><p><em>类、结构体、枚举等本身也是一种命名空间，所以同理，我们也可以使用<code>::</code>来访问其中的字段与函数</em></p><p>而<code>using namespace</code>便是在某一作用域内引入某一命名空间的全部内容</p><p>同时<code>using</code>也有其他灵活的用法，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> a = apple;</span><br><span class="line"><span class="keyword">using</span> apple::print;</span><br></pre></td></tr></table></figure><blockquote><p><strong>需要强调的是，引用命名空间时，应该将其限定在尽量小的作用域内</strong></p><p><strong>命名空间的作用是避免命名冲突，而如果我们总是在顶层文件引入命名空间，那我们为什么还需要命名空间呢？</strong></p></blockquote><hr><h2 id="多线程（62）">多线程（62）</h2><blockquote><p><strong>在之前的学习过程中，我们的所有代码都是单线程的，即计算机实际上只顺序运行了一段命令</strong></p><p><strong>而线程系统可以让我们同时运行某几段代码，这往往在性能优化或一些其他方面非常有用</strong></p></blockquote><p>在C++11的STL中，存在<code>thread</code>库，使用该库我们便可以便捷地开启线程</p><ul><li>线程开启：创建<code>std::thread</code>类型的变量即为开启一个线程，其构造函数接受一个函数指针作为参数，传入的函数会在另外一个线程中被执行</li><li>线程关闭：使用<code>join()</code>函数可以让主线程的等待该子线程完成，然后主线程再继续执行。这样，子线程便可以安全的访问主线程中的资源，子线程结束后由主线程负责回收子线程资源</li></ul><p><strong>应用实例：</strong></p><p>一个程序的输入检测系统可以采用多线程的方式来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> is_finish = <span class="literal">false</span>; <span class="comment">// 使用静态全局变量传递状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每隔一秒输出一个“Working”</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working......&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(DoWork)</span></span>;<span class="comment">// 创建并开启线程，此时DoWork开始运行</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();<span class="comment">// 主线程阻塞，与此同时DoWork函数会在另一个线程被不断运行</span></span><br><span class="line">    is_finish = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>();<span class="comment">// 等待子线程完全结束后再继续进行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finish!&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>线程的概念非常简单，但是其应用缺极其复杂</strong></p></blockquote><hr><h2 id="计时（63）">计时（63）</h2><p><strong>我们应该如何在C++中计算完成某个操作或执行某个代码所需要的时间呢？</strong></p><p>这是个非常广泛的问题，计时的应用往往无处不在，不论是需要在特定时间运行的代码，还是进行性能测试时</p><p>我们实际上有着多种方法计算程序运行的实际时间，如操作底层系统库；而在C++中，官方的<code>chrono</code>库可以为我们这点</p><blockquote><p><code>chrono</code>库API参考：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/chrono">https://en.cppreference.com/w/cpp/chrono</a></p></blockquote><p><strong>以下是使用<code>chrono</code>进行高精度计时的一个范例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="type">float</span>&gt; duration = end_time - start_time;</span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>std::chrono::high_resolution_clock::now()</code>可以获得当前的精确时间，使两个时间相减即可得到时间间隔</p><p>但这看起来挺复制的，而如果我们想要为很多个函数计时，不停地复制这些代码会变得非常麻烦，下面是一种更加聪明的计时方法-<strong>利用C++对象的生存周期自动计时</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;</span><br><span class="line">    std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        duration = end - start;</span><br><span class="line">        <span class="keyword">auto</span> ms = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration);</span><br><span class="line">        std::cout &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Timer timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过创建<code>Timer</code>结构体，我们可以利用构造与析构函数将计时过程自动化，如果我们需要计时，我们便只需要在某一函数的开始创建一个<code>Timer</code>变量即可</p><hr><h2 id="多维数组（64）">多维数组（64）</h2><blockquote><p><strong>多维数组实际上代表着数组的嵌套</strong></p><p><strong>二维数组就是数组的数组，而三维数组就是数组的数组的数组</strong></p></blockquote><p><strong>多维数组的创建</strong></p><p>在我们创建多维数组时，我们可以将其看做是数组的嵌套</p><p>上层数组每个元素都代表着一个指向一个下层数组的指针，就像下面这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultidimensionalArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>** array2d = <span class="keyword">new</span> <span class="type">int</span>* [<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        array2d[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>*** array3d = <span class="keyword">new</span> <span class="type">int</span>** [<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        array3d[i] = <span class="keyword">new</span> <span class="type">int</span>* [<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array3d[i][j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们仅仅像<code>int** array2d = new int* [50];</code>这样完成声明后，我们的工作还远没有结束，到此我们只是为50个指针分配了内存空间，而并没有为这50个指针指向的50数组分配内存，所以我们还需要遍历地进行内存分配</p><p>而同理，在删除时，我们也需要遍历地进行删除</p><blockquote><p><strong>需要注意的是，多维数组中多层嵌套寻址的设计对内存并不友好，因为其储存的不连续性，这会带来更多的cache miss，实际应用上会比单纯地一维数组慢很多</strong></p><p><strong>而实际上，一维数组其实可以在很多时候替代多维数组的作用，通过<code>[x+y*i]</code>的方式</strong></p></blockquote><hr><h2 id="排序（65）">排序（65）</h2><blockquote><p><strong>对于如何处理数据的排序问题，我们可以通过多种方法来实现，包括自己实现冒泡、选择排序等算法</strong></p><p><strong>而当我们面对使用了C++STL，如<code>std::vector</code>，进行组织的数据时，我们实际上没必要自己写一个算法，我们可以使用C++库来帮我们排序</strong></p></blockquote><p>C++提供的排序函数为<code>std::sort</code>，它可以为任何类型的迭代器进行排序</p><p>我们需要为其提供一个迭代器的开始与结束，并选择性地提供比较函数，如果不提供，其将自动尝试根据类型排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这样<code>values</code>便会降序排序</p><p>而不仅如此，我们可以通过函数的使用大幅定制化我们的排序算法</p><hr><h2 id="类型双关（66）">类型双关（66）</h2><blockquote><p><strong>类型双关被用来在C++中绕过类型系统的检测</strong></p></blockquote><p>C++虽然是一门强类型语言，但因为其可以直接访问内存，其类型系统便显得不那么具有强制性，如在Java或C#中想要绕过类型系统便较为麻烦</p><p>这是一种原始的、底层的访问，对于这种操作的允许也是让C++拥有如此优秀的性能的原因</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">double</span> b = a;</span><br></pre></td></tr></table></figure><p>显然的，我们可以在C++中进行上述代码的使用，但是这并不意味着类型双关，这其中其实蕴含了一次隐式的类型转换</p><p>如果我们去查看<code>a</code>与<code>b</code>在内存中的表现形式，会发现其实二者是截然不同的</p><p>而类型双关则可以让我们在保持内存不变的情况下转换类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">double</span> b = *(<span class="type">double</span>*)&amp;a;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们先取了<code>a</code>的地址即<code>&amp;a</code>，而后将<code>a</code>的<code>int</code>类型地址强制转换为了<code>double</code>类型的地址，再将其解引用，就得到了<code>b</code>，此时<code>a</code>与<code>b</code>在内存中的表现完全一直，且类型不同</p><p>但，这实际上是很糟糕的用法，<code>int</code>类型与<code>double</code>类型的内存大小不一样，这十分不安全，在一些情况下甚至可能引发崩溃</p><p>下面是一个更加实际的应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e = &#123; <span class="number">5</span>,<span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* position = (<span class="type">int</span>*)&amp;e;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; position[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; position[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类型双关处理<code>Entity</code>，我们便可以不通过<code>e</code>，直接以类似数组的形式访问其中的数据</p><blockquote><p><strong>总而言之，类型双关允许我们以不同的形式解释同一块内存，正确地使用它可以帮助代码提高效率</strong></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hmxs.games">徽墨行深</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hmxs.games/posts/1002/">https://hmxs.games/posts/1002/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hmxs.games" target="_blank">Hmxs's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Note/">Note</a></div><div class="post_share"><div class="social-share" data-image="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304182342702.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/6/" title="《辟邪傩狮》-游戏创作1结课"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307161452197.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《辟邪傩狮》-游戏创作1结课</div></div></a></div><div class="next-post pull-right"><a href="/posts/2000/" title="【游戏编程模式】读书笔记零：目录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303301905867.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【游戏编程模式】读书笔记零：目录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/102/" title="【LeetCode】算法练习记录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309090059804.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-09</div><div class="title">【LeetCode】算法练习记录</div></div></a></div><div><a href="/posts/1001/" title="【The Cherno-C++】学习笔记一（1-33）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304182342702.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">【The Cherno-C++】学习笔记一（1-33）</div></div></a></div><div><a href="/posts/1003/" title="【The Cherno-C++】学习笔记三（67-90）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304182342702.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">【The Cherno-C++】学习笔记三（67-90）</div></div></a></div><div><a href="/posts/4/" title="《联机象棋》-游戏编程实训"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307161608249.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-16</div><div class="title">《联机象棋》-游戏编程实训</div></div></a></div><div><a href="/posts/12/" title="从零开始的C++软光栅渲染器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202406202341390.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="title">从零开始的C++软光栅渲染器</div></div></a></div><div><a href="/posts/101/" title="【GAMES101】学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403130823578.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-13</div><div class="title">【GAMES101】学习笔记</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">徽墨行深</div><div class="author-info__description">ゲームをしましょう！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hmxsqaq"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hmxsqaq" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hmxsqaq@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/11752174" target="_blank" title="BiliBili"><i class="fab fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到徽墨的博客！<br>目前中传游戏系在读<br>想要成为一名游戏开发者<br>随缘更新，请多指教！😆</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8834%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">const关键字（34）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutable%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8835%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">mutable关键字（35）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%EF%BC%8836%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">成员初始化列表（36）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8837%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">三元运算符（37）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8838%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">对象的实例化（38）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">栈对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.</span> <span class="toc-text">堆对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E6%A0%88%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A0%86"><span class="toc-number">6.3.</span> <span class="toc-text">尽量使用栈而不是堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8839%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">new关键字（39）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8Eexplicit%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8840%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">隐式转换与explicit关键字（40）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E9%87%8D%E8%BD%BD%EF%BC%8841%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">运算符及其重载（41）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8842%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">this关键字（42）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8843%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">对象的生命周期（43）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%8844%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">智能指针（44）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">12.1.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">12.2.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">12.3.</span> <span class="toc-text">weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">12.4.</span> <span class="toc-text">什么时候应该使用智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8845%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">复制构造函数（45）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%8846%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">-&gt;箭头操作符（46）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84std-vector%EF%BC%8847%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">动态数组std::vector（47）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-vector%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96%EF%BC%8848%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">std::vector使用优化（48）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8849%E3%80%8150%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">库的使用（49、50）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">17.1.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">17.2.</span> <span class="toc-text">动态链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8852%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">处理多返回值（52）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BFtemplate%EF%BC%8853%EF%BC%89"><span class="toc-number">19.</span> <span class="toc-text">模板template（53）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%8854%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">堆与栈内存的比较（54）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8FMacro%EF%BC%8855%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">宏Macro（55）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8856%EF%BC%89"><span class="toc-number">22.</span> <span class="toc-text">auto关键字（56）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84std-array%EF%BC%8857%EF%BC%89"><span class="toc-number">23.</span> <span class="toc-text">静态数组std::array（57）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%8858%EF%BC%89"><span class="toc-number">24.</span> <span class="toc-text">函数指针（58）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8859%EF%BC%89"><span class="toc-number">25.</span> <span class="toc-text">lambda表达式（59）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8using-namespace-std%EF%BC%8860%EF%BC%89"><span class="toc-number">26.</span> <span class="toc-text">为什么不应该使用using namespace std（60）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%8861%EF%BC%89"><span class="toc-number">27.</span> <span class="toc-text">命名空间（61）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8862%EF%BC%89"><span class="toc-number">28.</span> <span class="toc-text">多线程（62）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%EF%BC%8863%EF%BC%89"><span class="toc-number">29.</span> <span class="toc-text">计时（63）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8864%EF%BC%89"><span class="toc-number">30.</span> <span class="toc-text">多维数组（64）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%EF%BC%8865%EF%BC%89"><span class="toc-number">31.</span> <span class="toc-text">排序（65）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3%EF%BC%8866%EF%BC%89"><span class="toc-number">32.</span> <span class="toc-text">类型双关（66）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4003/" title="【Algorithm4】读书笔记三：查找"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Algorithm4】读书笔记三：查找"></a><div class="content"><a class="title" href="/posts/4003/" title="【Algorithm4】读书笔记三：查找">【Algorithm4】读书笔记三：查找</a><time datetime="2024-10-21T15:49:59.676Z" title="更新于 2024-10-21 23:49:59">2024-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4002/" title="【Algorithm4】读书笔记二：排序"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Algorithm4】读书笔记二：排序"></a><div class="content"><a class="title" href="/posts/4002/" title="【Algorithm4】读书笔记二：排序">【Algorithm4】读书笔记二：排序</a><time datetime="2024-10-04T19:44:57.378Z" title="更新于 2024-10-05 03:44:57">2024-10-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/10000/" title="针对《异度神剑2》的批判看法与改造意见"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281809194.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="针对《异度神剑2》的批判看法与改造意见"></a><div class="content"><a class="title" href="/posts/10000/" title="针对《异度神剑2》的批判看法与改造意见">针对《异度神剑2》的批判看法与改造意见</a><time datetime="2024-09-29T19:50:50.161Z" title="更新于 2024-09-30 03:50:50">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/106/" title="【Unity-Timeline】学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202312182321194.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Unity-Timeline】学习笔记"></a><div class="content"><a class="title" href="/posts/106/" title="【Unity-Timeline】学习笔记">【Unity-Timeline】学习笔记</a><time datetime="2024-09-29T19:50:05.303Z" title="更新于 2024-09-30 03:50:05">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/105/" title="【Unity-Input System】学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303300143145.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Unity-Input System】学习笔记"></a><div class="content"><a class="title" href="/posts/105/" title="【Unity-Input System】学习笔记">【Unity-Input System】学习笔记</a><time datetime="2024-09-29T19:50:02.020Z" title="更新于 2024-09-30 03:50:02">2024-09-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 徽墨行深</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hmxs.games/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://hmxs-twikoo.netlify.app/.netlify/functions/twikoo",region:"",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://hmxs-twikoo.netlify.app/.netlify/functions/twikoo",region:"",urls:[window.location.pathname],includeReply:!1}).then(o=>{t.textContent=o[0].count}).catch(t=>{console.error(t)})})()},o=()=>{"object"==typeof twikoo?setTimeout(t,0):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(t)};o()})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>