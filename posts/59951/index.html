<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Algorithm4】读书笔记二：排序 | 👾Hmxs's Blog👾</title><meta name="author" content="徽墨行深,18321938171@163.com"><meta name="copyright" content="徽墨行深"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article"><meta property="og:title" content="【Algorithm4】读书笔记二：排序"><meta property="og:url" content="https://hmxs.games/posts/59951/index.html"><meta property="og:site_name" content="👾Hmxs&#39;s Blog👾"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png"><meta property="article:published_time" content="2023-10-08T09:13:50.000Z"><meta property="article:modified_time" content="2024-05-22T03:05:59.724Z"><meta property="article:author" content="徽墨行深"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Note"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png"><link rel="shortcut icon" href="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg"><link rel="canonical" href="https://hmxs.games/posts/59951/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Algorithm4】读书笔记二：排序",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-05-22 11:05:59"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.getCSS=(e,t=!1)=>new Promise((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom_loading.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()})</script><script>window.paceOptions={restartOnPushState:!1},document.addEventListener("pjax:send",()=>{Pace.restart()})</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png)"><nav id="nav"><span id="blog-info"><a href="/" title="👾Hmxs's Blog👾"><span class="site-name">👾Hmxs's Blog👾</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Algorithm4】读书笔记二：排序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-08T09:13:50.000Z" title="发表于 2023-10-08 17:13:50">2023-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-22T03:05:59.724Z" title="更新于 2024-05-22 11:05:59">2024-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/Algorithm/">Algorithm</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/Algorithm/%E3%80%8AAlgorithms-4th-Edition%E3%80%8B/">《Algorithms, 4th Edition》</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="【Algorithm4】读书笔记二：排序"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/59951/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202310081712174.png" alt="algorithm4" style="zoom:50%"><blockquote><p><strong>官网：<a target="_blank" rel="noopener" href="https://algs4.cs.princeton.edu/home/">https://algs4.cs.princeton.edu/home/</a></strong></p><p><strong>笔记目录：<a href="https://hmxs.games/posts/25550/">https://hmxs.games/posts/25550/</a></strong></p></blockquote><hr><h1>排序</h1><p>排序就是将一组对象按照某种逻辑顺序重新排列的过程，其在商业数据处理和现代科学计算方面都有着重要的地位，本章将聚焦于排序算法，介绍、研究并实现几种经典的排序算法。</p><h2 id="前言">前言</h2><h3 id="排序算法模板">排序算法模板</h3><p>在实现排序算法时，我们将会遵照一定的“游戏规则”，以下<code>SortExample</code>展示了我们对于排序算法的约定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable v, Comparable w)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123; <span class="type">Comparable</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; a[i] = a[j]; a[j] = t; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Comparable[] a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSorted</span><span class="params">(Comparable[] a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        String[] a = In.readStrings();</span><br><span class="line"></span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">assert</span> <span class="title function_">isSorted</span><span class="params">(a)</span>;</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sort：排序的具体实现</li><li>less：比较两个数据的大小</li><li>exchange：交换两个数据</li><li>show：打印数组</li><li>isSorted：检查是否成功排序</li></ul><h3 id="性能评估">性能评估</h3><blockquote><p><strong>排序成本模型：在研究排序算法时，我们需要计算比较和交换的数量。对于不交换元素的算法，我们会计算访问数组的次数</strong></p></blockquote><h3 id="算法比较">算法比较</h3><p>当我们实现了好几种排序算法后，我们自然想知道他们哪个更快，而以下的<code>SortCompare</code>类便可以帮助我们实现这点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortCompare</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">time</span><span class="params">(String alg, Double[] a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stopwatch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">&quot;Insertion&quot;</span>)) InsertionSort.sort(a);</span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">&quot;Selection&quot;</span>)) SelectionSort.sort(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> timer.elapsedTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">timeRandomInput</span><span class="params">(String alg, <span class="type">int</span> N, <span class="type">int</span> T)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        Double[] a = <span class="keyword">new</span> <span class="title class_">Double</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt; T; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">                a[i] = Math.random();</span><br><span class="line">            total += time(alg, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">alg1</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">alg2</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">2</span>]); <span class="comment">// array size</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">3</span>]); <span class="comment">// number of trials</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">t1</span> <span class="operator">=</span> timeRandomInput(alg1, N, T); <span class="comment">// total for alg1</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">t2</span> <span class="operator">=</span> timeRandomInput(alg2, N, T); <span class="comment">// total for alg2</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;For %d random Doubles\n    %s is&quot;</span>, N, alg1);</span><br><span class="line">        System.out.printf(<span class="string">&quot; %.1f times faster than %s\n&quot;</span>, t2/t1, alg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里以马上要实现的选择排序与插入排序的比较为例，实现了跟多排序算法后，在<code>time()</code>中添加即可</p><p>上面的排序算法以完全随机生成的数组作为排序算法的输入，通过多次实验保证实验结果的有效性，并且我们通过改变输入改变输入的规模以进行更精确的测试</p><hr><h2 id="选择排序">选择排序</h2><blockquote><p><strong>这是最简单的排序算法之一，其核心思想是：不断选择最小/大的元素</strong></p></blockquote><p>我们会先找到数组中最小/大的元素，将其与数组的第一个元素交换位置；之后，在剩下的元素中找到最小/大的元素，将其与第二个元素交换位置；之后不断重复这一过程，直至最后一个元素</p><h3 id="实现">实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min]))</span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">if</span> (min != i)</span><br><span class="line">            exchange(a, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析">分析</h3><blockquote><p><strong>对于长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>的数组，选择排序需要大约<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span></span></span></span>此比较与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>次比较，其时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>级别</strong></p></blockquote><p>其有两个鲜明的特点：</p><ul><li><strong>运行时间与输入无关</strong>：无论输入数组排序状态如何，是有序还是无序，对选择排序的运行效率都没有影响</li><li><strong>数据移动时最少的</strong>：选择排序的交换次数与数组大小是线性关系，其余任何算法都不具备这个特性（大部分都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">Nlg N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>级别）</li></ul><hr><h2 id="插入排序">插入排序</h2><blockquote><p><strong>插入排序的核心思想就如同在斗地主时整理手牌：将每张牌插入到已有的有序牌中的适当位置</strong></p></blockquote><p>在算法的实现中，由于要给元素腾出位置，我们需要将其余元素向右移动一位；与选择排序相同，索引左边的元素都是有序的，而当索引到达数组右端时，排序便完成了</p><h3 id="实现-2">实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">            exchange(a, j, j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-2">分析</h3><blockquote><p><strong>对于长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>的数组选择排序，其时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>级别</strong></p></blockquote><p>插入排序在部分情况下非常有效，其实际效率很大程度上取决于其需要进行插入的次数</p><p>如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。 下面是几种典型的部分有序的数组：</p><ul><li>数组中每个元素距离它的最终位置都不远</li><li>一个有序的大数组接一个小数组</li><li>数组中只有几个元素的位置不正确</li></ul><p>插入排序对这样的数组很有效，而选择排序则不然；事实上，当倒置数量很少时，插入排序很可能比其他任何算法都快</p><hr><h2 id="希尔排序">希尔排序</h2><blockquote><p><strong>希尔排序是一种基于插入排序的排序算法，其核心思想是：交换不相邻的元素以对数组的局部 进行排序，并最终用插入排序将局部有序的数组排序</strong></p></blockquote><p>在上面对于插入排序的分析中，我们了解到：当数组是部分有序的时，插入排序非常快；而希尔排序正是利用了这点，先使数组变得部分有序，再进行进一步的排序，以加快插入排序的速度</p><p>如下图所示，希尔排序会以h为步长将数组进行分割，假设数组为<code>[5, 7, 1, 4, 6, 9]</code>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">h=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">3</span></span></span></span>，则数组会被分割为<code>[5, 4]</code>、<code>[7, 6]</code>、<code>[1, 9]</code>三组；首先对组内进行插入排序（一个更简单的方法是在子数组中将每个元素交换到比它大的元素之前去即可），便可以得到<code>[4, 5]</code>、<code>[6, 7]</code>、<code>[1, 9]</code>，这被称为<code>h有序数组</code>；之后我们便可以进一步缩小h，以得到更大的h有序数组，最后实现数组的排序</p><p>我们也可以从这一角度去思考：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">h</span></span></span></span>较大，在进行组内排序时便可以将元素移动到很远的地方，而插入排序只能一个个的进行元素移动，从而提高效率</p><p>在我们下面的实现中，使用了序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mtext>（</mtext><mn>3</mn><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1/2（3k-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1/2</span><span class="mord cjk_fallback">（</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，即从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">N/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mord">/3</span></span></span></span>开始递减至 1。我们把这个序列称为递增序列；下面的实现中实时计算了其递增序列，另一种方式是将递增序列存储在一个数组中</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401112336523.png" alt="image-20240111233622452"></p><h3 id="实现-3">实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>)</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j-=h)</span><br><span class="line">                exchange(a, j, j-h);</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-3">分析</h3><p>通过<code>SortCompare</code>进行比较我们可以发现，希尔排序比插入排序快了非常多</p><blockquote><p><strong>希尔排序更高效的原因是它权衡了子数组的规模和有序性</strong></p></blockquote><p>希尔排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序</p><p>而子数组部分有序的程度取决于递增序列的选择，但对于递增序列的选择是个复杂的问题：算法的性能不仅取决于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">h</span></span></span></span>，还取决于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">h</span></span></span></span>之间的数学性质，比如它们的公因子等；有很多论文研究了各种不同的递增序列，但都无法证明某个序 列是“最好的”；在我们的实现中，使用了非常简单易于计算的底层序列，但一些复杂的序列可以被证明其性能好于我们使用的序列，更加优秀的递增序列有待我 们去发现</p><p>透彻理解希尔排序的性能至今仍然是一项挑战；实际上，希尔排序是我们唯一无法准确描述其对于乱序的数组的性能特征的排序方法</p><hr><h2 id="归并排序">归并排序</h2><blockquote><p><strong>归并，即将两个有序数组合并成一个更大的有序数组；归并排序便是基于这一简单操作进行的</strong></p></blockquote><p>归并排序是一种基于分治思想的递归排序算法，要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来</p><p>归并排序的优点在于其能够保证，排序将任意长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>的数组所需的时间与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>成正比；同时，其也存在所需的额外空间与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>成正比的缺点</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401122003737.png" alt="image-20240112200331668"></p><h3 id="归并的抽象实现">归并的抽象实现</h3><p>实现归并的一种直截了当的办法是将两个不同的有序数组归并到第三个数组中，创建一个适当大小的数组然后将两个输 入数组中的元素一个个从小到大放入这个数组中即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> low; k &lt;= high; k++)</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> low; k &lt;= high; k++)</span><br><span class="line">        <span class="keyword">if</span>         (i &gt; mid)				a[k] = aux[j++]; <span class="comment">// 数组左半边已用尽</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high)                a[k] = aux[i++]; <span class="comment">// 数组右半边已用尽</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))    a[k] = aux[j++]; <span class="comment">// 右边的元素小</span></span><br><span class="line">        <span class="keyword">else</span>                            a[k] = aux[i++]; <span class="comment">// 左边的元素小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码演示了进行一次归并时进行的操作，<code>a</code>是我们需要进行归并的数组，我们会先将<code>a</code>复制到<code>aux</code>辅助数组中，对左右两边的数组进行一一比较后，一个个放回<code>a</code>数组中完成排序</p><p>上述代码可以完成一次归并，但是当我们想要用归并将一个大数组排序时，我们便需要进行多次归并，上述的方法会在每进行一次归并时都对原数组进行一次完整的复制，这会带来大量的内存消耗</p><p>与此相比，我们更需要一种“原地归并”的方法，使得我们不需要用一个额外的数组来存储数据，但实际上这是较为困难且复杂的；不管怎么说，上述方法仍然是有意义的，其帮助我们对归并操作进行了抽象化，我们可以在此基础上继续探索</p><h3 id="自顶向下的归并排序">自顶向下的归并排序</h3><p>基于归并的抽象实现，我们可以实现一种自顶向下的递归归并算法</p><p>这也是应用高效算法设计中分治思想的 最典型的一个例子</p><h4 id="实现-4">实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    sort(a, low, mid);        <span class="comment">// 对左半数组进行排序</span></span><br><span class="line">    sort(a, mid+<span class="number">1</span>, high);    <span class="comment">// 对右半数组进行排序</span></span><br><span class="line">    merge(a, low, mid, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将a[low..high]复制到aux[low..high]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> low; k &lt;= high; k++)</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> low; k &lt;= high; k++)</span><br><span class="line">        <span class="keyword">if</span>         (i &gt; mid)               a[k] = aux[j++]; <span class="comment">// 数组左半边已用尽</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high)              a[k] = aux[i++]; <span class="comment">// 数组右半边已用尽</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))  a[k] = aux[j++]; <span class="comment">// 右边的元素小</span></span><br><span class="line">        <span class="keyword">else</span>                            	a[k] = aux[i++]; <span class="comment">// 左边的元素小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-4">分析</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401122052338.png" alt="image-20240112205259265"></p><p>上图展示了自顶向下的归并排序算法的递归树</p><blockquote><p><strong>对于长度为 N 的任意数组，自顶向下的归并排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2}NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8451em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>次比较；最多需要访问数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">6NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>次</strong></p></blockquote><p>归并排序和之前的初级排序方法不可同日而语，它表明我们只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序；可以用归并排序处理数百万甚至更大规模的数组，这是插入排序或者选择排序做不到的</p><h3 id="改进-a-id-anchor-merge-insertion-a">改进<a id="anchor-merge_insertion"></a></h3><p>通过一些细致的思考我们还能够大幅度缩短归并排序的运行时间：</p><ul><li>对小规模子数组使用插入排序</li></ul><p>递归会使小规模问题中方法的调用过于频繁，而在前面对于插入排序的研究中，我们可以发现插入排序对于小数组可能比归并排序更快；在分割数组到足够小后，我们便可以采用插入排序，之后再进行归并，这可以提高算法的效率</p><ul><li>测试数组是否已经有序</li></ul><p>我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，我们就认为数组已经是有序 的并跳过 merge() 方法。这个改动不影响排序的递归调用，但是任意有序的子数组算法的运行时间 就变为线性的了</p><ul><li>不将元素复制到辅助数组</li></ul><p>我们可以节省将数组元素复制到用于归并的辅助数组所用的时间；这种方法需要一些技巧，我们要在递归调用的每个层次交换输入数组和辅助数组的角色；<code>merge</code>的过程类似对着一个源文本进行重新抄录，而此方法便是让两个数组轮流作为源文本</p><p><strong>以下代码对上述三个优化进行了实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CUTOFF</span> <span class="operator">=</span> <span class="number">7</span>; <span class="comment">// 小数组的阈值，小数组应用插入排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    Comparable[] aux = a.clone();</span><br><span class="line">    sort(aux, a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] source, Comparable[] destination, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low + CUTOFF) <span class="comment">// 优化：小数组应用插入排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        insertionSort(destination, low, high);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    sort(destination, source, low, mid); <span class="comment">// 优化：交换source和destination的位置</span></span><br><span class="line">    sort(destination, source, mid+<span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">if</span> (!less(source[mid+<span class="number">1</span>], source[mid])) <span class="comment">// 优化：如果数组已经有序，就不需要归并了</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.arraycopy(source, low, destination, low, high - low + <span class="number">1</span>); <span class="comment">// 复制数组</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    merge(source, destination, low, mid, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// source: 用于比较的数组，destination用于归并的目的地</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] source, Comparable[] destination, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> low; k &lt;= high; k++)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid)         destination[k] = source[j++]; <span class="comment">// 数组左半边已用尽</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high)     destination[k] = source[i++]; <span class="comment">// 数组右半边已用尽</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(source[j], source[i])) destination[k] = source[j++]; <span class="comment">// 右边的元素小</span></span><br><span class="line">        <span class="keyword">else</span>                                 destination[k] = source[i++]; <span class="comment">// 左边的元素小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(Comparable[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt;= high; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; low &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">            exchange(a, j, j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自底向上的归并排序">自底向上的归并排序</h3><p>递归实现的归并排序是算法设计中分治思想的典型应用：我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题；尽管我们考虑的问题是归并两个大数组， 实际上我们归并的数组大多数都非常小</p><p>在自顶向下的归并排序中，我们会先从大数组入手，一步步将大数组分割为小数组；而我们实际上还可以直接从小数组入手，即把每个元素想象成一个大小为1的数组，然后两两归并、四四归并、八八归并…直到归并完成；这种归并排序的实现方法被称为自底向上的归并排序</p><h4 id="实现-5">实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">    aux = <span class="keyword">new</span> <span class="title class_">Comparable</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> <span class="number">1</span>; sz &lt; N; sz *= <span class="number">2</span>) <span class="comment">// sz子数组大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>; low &lt; N - sz; low += <span class="number">2</span> * sz) <span class="comment">// low: 子数组索引</span></span><br><span class="line">            merge(a, low, low + sz - <span class="number">1</span>, Math.min(low + <span class="number">2</span> * sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将a[low..high]复制到aux[low..high]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> low; k &lt;= high; k++)</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> low; k &lt;= high; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>      (i &gt; mid)               a[k] = aux[j++]; <span class="comment">// 数组左半边已用尽</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high)              a[k] = aux[i++]; <span class="comment">// 数组右半边已用尽</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))  a[k] = aux[j++]; <span class="comment">// 右边的元素小</span></span><br><span class="line">        <span class="keyword">else</span>                            a[k] = aux[i++]; <span class="comment">// 左边的元素小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-5">分析</h4><blockquote><p><strong>对于长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>的任意数组，自底向上的归并排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2}NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8451em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>次比较，最多访问数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">6NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>次</strong></p></blockquote><p>这种实现方法的一个优势在于其比标准递归方法所需要的代码量要少很多</p><p>**当数组长度为2的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同；**其他时候，两种方法的比较和数组访问的次序会有所不同</p><p>自底向上的归并排序比较适合用链表组织的数据，其只需要重新组织链表链接就能将链表原地排序，而不需要创建任何新的链表结点</p><blockquote><p><strong>用自顶向下或是自底向上的方式实现任何分治类的算法都很自然</strong></p></blockquote><h3 id="排序算法的复杂度">排序算法的复杂度</h3><p>学习归并排序的一个重要原因是它是证明计算复杂性领域的一个重要结论的基础</p><p>对于基于比较（<code>Comparable</code>）的排序算法来说，其具有以下性质（<strong>此处，我们忽略了访问数组的开销</strong>）</p><blockquote><p><strong>没有任何基于比较的算法能够保证使用少于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mtext>～</mtext><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">lg(N!)～NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">!)</span><span class="mord cjk_fallback">～</span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>次比较将长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>的数组排序</strong></p></blockquote><p><em>书中对于这一结论通过一个基于二叉树的数学模型给出了精彩的证明，这里不再赘述</em></p><p>这一性质告诉了我们在设计排序算法时能达到的上限与目标，如果没有这一结论，我们便可能会去尝试设计一个个在最坏情况下比较次数只有归并排序的一半的基于比较的算法；通过这一结论，我们便可以明确知道，这样的算法不存在</p><p>在上面对于归并排序的分析中，我们得到了归并排序在最坏情况下的比较次数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>这一结论，而在上面我们同样知道了没有任何排序算法能够用少于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mtext>～</mtext><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">lg(N!)～NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">!)</span><span class="mord cjk_fallback">～</span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>次比较将数组排序，这也就意味着：</p><blockquote><p><strong>归并排序是一种渐进最优的基于比较排序的算法</strong></p></blockquote><p><em>从严谨的角度来说，我们认为仅仅只需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>g</mi><mi>N</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">lgN!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">!</span></span></span></span>次比较的算法才是最优的排序算法，但在实际应用中，即使对于很大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>，这种算法与归并排序之间的差异也并不明显</em></p><p>虽说我们已经盖棺定论地说归并排序已经是渐进最优了，但其仍然是有很多局限性的：</p><ul><li>归并排序的空间复杂度不是最优的</li><li>在实践中不一定会遇到最坏情况</li><li>除了比较，算法的其他操作（例如访问数组）也可能很重要</li><li>不进行比较也能将某些数据排序</li></ul><hr><h2 id="快速排序">快速排序</h2><p>终于来到大名鼎鼎的快速排序了，其可能是应用最为广泛的排序算法；快速排序实现简单、对输入的抵赖低同时在一般应用中比其他排序算法都要快得多，其在内存与效率上都非常优秀</p><ul><li>内存上，快速排序是原地排序，其只需要一个很小的辅助栈</li><li>效率上，快速排序将长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>的数组排序所需的时间和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>成正比。</li></ul><h3 id="基本实现">基本实现</h3><p>快速排序同归并排序一样，也是一种基于分治思想的递归排序算法，它们都会将数组进行分割，并分别排序，不同的是它们在实现思路上是相反的，或者说互补的：</p><ul><li>归并排序会先对数组进行分割，然后将分割完成的数组分别排序，最后将已经有序的子数组进行归并从而实现对整个数组的排序；总的来说，归并排序是<strong>先递归再处理数组</strong></li><li>快速排序的思想则是其会依据数组元素的大小对数组进行分割，即“是当两个子数组都有序时整个数组也就自然有序了”；其是<strong>先处理数组再进行递归</strong>的</li></ul><p>形象的说，归并是在递归到底层之后向上返回的过程中完成对数组的排序；而快排则是当递归到底层后，排序就已经完成了</p><p>相对应的，归并排序中会通过递归调用<code>“归并（merge）”</code>来排序数组，而快速排序则是通过<code>“切分（partition）”</code></p><p>当我们对一个数组进行切分时，我们会从其中选定一个“切分元素”，之后通过元素交换实现：<strong>切分元素左边的元素都小于它，而其右边的元素都大于它</strong></p><p>通过递归地对数组进行切分，我们便可以完成对数组的排序，这便是快速排序的基本原理，下面便可以开始实现了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401142321251.png" alt="image-20240114232150071"></p><p>如上图所示，要实现快速排序的切分，一般的策略是先随意取一个元素作为切分元素，这里先取<code>a[lo]</code>，即最左边的元素；然后我们从数组的左端开始使用指针<code>i</code>向右扫描直到找到一个大于等于它的元素，再从数组的右端开始使用指针<code>j</code>向左扫描直到找到一个小于等于它的元素；这两个元素显然是没有排定的，因此我们交换它们的位置；如此继续，直到<code>i</code>与<code>j</code>相遇，再将切分元素交换到中间，我们就可以实现切分效果了</p><p>以下快速排序的基本实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    StdRandom.shuffle(a);</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(a, low, high);</span><br><span class="line">    sort(a, low, j-<span class="number">1</span>); <span class="comment">// 将左半部分a[low..j-1]排序</span></span><br><span class="line">    sort(a, j+<span class="number">1</span>, high); <span class="comment">// 将右半部分a[j+1..high]排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = high + <span class="number">1</span>; <span class="comment">// 左右扫描指针</span></span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">v</span> <span class="operator">=</span> a[low]; <span class="comment">// 切分元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 扫描左右，检查扫描是否结束并交换元素</span></span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v)) <span class="keyword">if</span> (i == high) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (less(v, a[--j])) <span class="keyword">if</span> (low == j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exchange(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exchange(a, j, low); <span class="comment">// 将v = a[j]放入正确的位置</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免糟糕的实现">避免糟糕的实现</h3><p>快速排序有着无数优点，但其非常“脆弱”，一些糟糕的实现会很容易导致糟糕的性能，让快速排序变成超慢排序🤣</p><p>以下是一些要点：</p><ul><li>原地切分</li></ul><p>我们可以轻易地像实现归并排序那样用一个辅助数组来实现切分，但其中因为开辟数组与数组复制所带来的的内存与效率损失会让我得不偿失</p><ul><li>数组越界问题</li></ul><p>在切分的内循环中，我们会依据切分元素扫描数组，而当切分元素是最小或最大的元素时，数组越界的问题便可能发生，在我们上面的实现中，我们通过<code>if (i == high) break</code>与<code>if (low == j) break</code>预防了这个问题</p><p>但实际上，上面实现中的<code>if (low == j) break</code>存在冗余，因为我们选择的切分元素是数组最左边的元素，而实际上<code>a[j]</code>无论如何也不会小于<code>a[low]</code>，所以这条语句实际上是可以删去的，在这一情况下，切分元素本身被作为了“哨兵”，防止了数组越界的产生</p><p>而实际上，我们也可以手动在数组最右端制造一个“哨兵”，如此一来<code>if (i == high) break</code>便也可以省去了；我们可以在开始排序前，将最大的元素放置在数组最右边，同时在递归左半部分的数组时，将上一轮的切分元素包含，即由<code>sort(a, low, j-1)</code>变为<code>sort(a, low, j)</code>，因为上一轮的切分元素一定大于其左边的所有元素；这样在所有切分中，最右端的元素都是最大的，可以起到“哨兵”的作用了</p><ul><li>打乱数组，保持随机</li></ul><p>我们可以注意到，在排序开始前，我们使用<code>StdRandom.shuffle(a)</code>对数组进行了打乱，这一来是对算法效率测试的保证；二来，快速排序在面对一些特殊输入时会有极差的性能，如我们每次选取的切分元素都是最大/最小的元素，效率会来到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>级别，打乱数组可以避免这一点</p><ul><li>循环终止条件</li></ul><p>正确地检测指针是否越界需要一点技巧，并不像看上去那么容易；一个最常见的错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素</p><ul><li>处理切分元素值有重复的情况</li></ul><p>左侧扫描最好是在遇到大于等于切分元素值的元素时停下，右侧扫描则是遇到小于等于切分元素值的元素时停下；尽管这样可能会不必要地将一些等值的元素交换，但在某些典型应用中，它能够避免算法的运行时间变为平方级别；稍后我们会讨论另一种可以更好地处理含有大量重复值的数组的方法</p><ul><li>递归终止条件</li></ul><p>实现快速排序时一个常见的错误就是不能保证将切分元素放入正确的位置，从而导致程序在切分元素正好是子数组的最大或是最小元素时陷入了无限的递归循环之中</p><h3 id="分析-6">分析</h3><p>快速排序的效率如此之高的一个很重要的原因得益于其简洁高效的切分内循环，在快速排序的切分方法中环会用一个递增的索引将数组元素和一个定值比较，而希尔排序与归并排序则还需要在内循环中进行数据的移动</p><p>快速排序另一个速度优势在于它的比较次数很少</p><blockquote><p><strong>将长度为 N 的无重复数组排序，快速排序平均需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mn>2</mn><mi>N</mi><mi>l</mi><mi>n</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">~2NlnN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mspace nobreak"> </span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>次比较（以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8451em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的交换）</strong></p></blockquote><p>总的来说，可以肯定的是对于大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>的数组，快速排序的运行时间在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.39</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1.39NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord">1.39</span><span class="mord mathnormal" style="margin-right:.01968em">Nl</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>的某个常数因子的范围之内；归并排序也能做到这一点，但是快速排序一般会更快（尽管它的比较次数多<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>39</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">39\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8056em;vertical-align:-.0556em"></span><span class="mord">39%</span></span></span></span>），因为它移动数据的次数更少；这些保证都来自于数学概率</p><h3 id="改进">改进</h3><p>快速排序是由 C.A.R Hoare 在 1960 年发明的，几乎从 Hoare 第一次发表这个算法开始，人们就不断地提出各种改进方法；并不是所有的想法都可行，因为快速排序的平衡性已经非常好，改进所带来的提高可能会被意外的副作用所抵消；但其中一些，也是我们现在要介绍的，非常有效</p><h4 id="对小规模子数组使用插入排序">对小规模子数组使用插入排序</h4><p>同样的方法我们在之前介绍<a href="#anchor-merge_insertion">归并排序的改进方法</a>时已经用过，此处的思路也差不多</p><ul><li>对于小数组，快速排序比插入排序慢</li><li>因为递归，快速排序的<code>sort()</code>方法在小数组中也会调用自己</li></ul><p>我们只需要将<code>if (high &lt;= low) return;</code>替换为<code>if (high &lt;= low + M) &#123; Insertion.sort(a, lo, hi); return; &#125;</code>即可</p><p>切换阈值<code>M</code>的最佳值是和系统相关的，但是5～15之间的任意值在大多数情况下都能令人满意</p><h4 id="三取样切分">三取样切分</h4><p>快速排序的效率很大程度上取决于切分元素的选择，其最优情况便是切分元素正好等于数组元素的中位数，但要计算出这一数值便意味着我们需要在每次切分时都进行一次遍历，这是得不偿失的</p><p>在我们目前的实现中，我们通过打乱数组完全消除了输入的影响，使得切分元素的选取完全随机，这样可以在完全不计算中位数的情况下达到平均的效率</p><p>而取样切分则使用子数组的一小部分元素的中位数来切分数组，这可以让切分更优秀，虽然同样会付出计算中位数的代价，但这明显比遍历好多了，这种代价是可以接受的；人们发现将取样大小设为3并用大小居中的元素切分的效果最好</p><p>同时，取样切分可以带来的额外好处是，我们不需要进行特别的处理便可以将取样元素所谓哨兵使用，这样可以去除切分算法中的边界检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 三取样切分</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (less(a[mid], a[low])) exchange(a, low, mid);</span><br><span class="line">    <span class="keyword">if</span> (less(a[high], a[low])) exchange(a, low, high);</span><br><span class="line">    <span class="keyword">if</span> (less(a[high], a[mid])) exchange(a, mid, high);</span><br><span class="line"></span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">v</span> <span class="operator">=</span> a[mid]; <span class="comment">// 切分元素: a[low] &lt;= a[mid] &lt;= a[high]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = high + <span class="number">1</span>; <span class="comment">// 左右扫描指针</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 扫描左右，检查扫描是否结束并交换元素</span></span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v));</span><br><span class="line">        <span class="keyword">while</span> (less(v, a[--j]));</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exchange(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exchange(a, j, low); <span class="comment">// 将v = a[j]放入正确的位置</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hmxs.games">徽墨行深</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hmxs.games/posts/59951/">https://hmxs.games/posts/59951/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hmxs.games" target="_blank">👾Hmxs's Blog👾</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a><a class="post-meta__tags" href="/tags/Note/">Note</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/52301/" title="《Just Suck.》-吉比特GameJam2023"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202311010242672.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Just Suck.》-吉比特GameJam2023</div></div></a></div><div class="next-post pull-right"><a href="/posts/27521/" title="【Algorithm4】读书笔记一：基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Algorithm4】读书笔记一：基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/25550/" title="【Algorithm4】读书笔记零：目录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-13</div><div class="title">【Algorithm4】读书笔记零：目录</div></div></a></div><div><a href="/posts/27521/" title="【Algorithm4】读书笔记一：基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-13</div><div class="title">【Algorithm4】读书笔记一：基础</div></div></a></div><div><a href="/posts/18628/" title="【LeetCode】算法练习记录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309090059804.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-09</div><div class="title">【LeetCode】算法练习记录</div></div></a></div><div><a href="/posts/10824/" title="【C#-反射】学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281818840.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-22</div><div class="title">【C#-反射】学习笔记</div></div></a></div><div><a href="/posts/17194/" title="【C#-泛型约束】学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281818840.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-28</div><div class="title">【C#-泛型约束】学习笔记</div></div></a></div><div><a href="/posts/17021/" title="【3B1B-线性代数的本质】学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100312370.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">【3B1B-线性代数的本质】学习笔记</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">徽墨行深</div><div class="author-info__description">一个来自中传游戏系的大二学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hmxsqaq"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hmxsqaq" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:18321938171@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/11752174" target="_blank" title="BiliBili"><i class="fab fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到徽墨的博客！<br>目前中传游戏系大二在读<br>想要成为一名游戏程序<br>随缘更新一些自己的游戏作品/学习笔记/游戏评论<br>希望对你有帮助！😆</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.1.1.</span> <span class="toc-text">排序算法模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">性能评估</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.3.</span> <span class="toc-text">算法比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-3"><span class="toc-number">1.4.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">归并的抽象实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">自顶向下的归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-4"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B-a-id-anchor-merge-insertion-a"><span class="toc-number">1.5.3.</span> <span class="toc-text">改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">自底向上的归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90-5"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.5.5.</span> <span class="toc-text">排序算法的复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">基本实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%B3%9F%E7%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">避免糟糕的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-6"><span class="toc-number">1.6.3.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B"><span class="toc-number">1.6.4.</span> <span class="toc-text">改进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%B0%8F%E8%A7%84%E6%A8%A1%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">对小规模子数组使用插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8F%96%E6%A0%B7%E5%88%87%E5%88%86"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">三取样切分</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/30933/" title="《辟邪傩狮》-游戏创作1结课"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307161452197.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="《辟邪傩狮》-游戏创作1结课"></a><div class="content"><a class="title" href="/posts/30933/" title="《辟邪傩狮》-游戏创作1结课">《辟邪傩狮》-游戏创作1结课</a><time datetime="2024-05-22T03:10:00.236Z" title="更新于 2024-05-22 11:10:00">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8233/" title="《联机象棋》-游戏编程实训"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307161608249.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="《联机象棋》-游戏编程实训"></a><div class="content"><a class="title" href="/posts/8233/" title="《联机象棋》-游戏编程实训">《联机象棋》-游戏编程实训</a><time datetime="2024-05-22T03:09:57.417Z" title="更新于 2024-05-22 11:09:57">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5719/" title="《电击小子》-CiGA GameJam 2023"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307161555859.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="《电击小子》-CiGA GameJam 2023"></a><div class="content"><a class="title" href="/posts/5719/" title="《电击小子》-CiGA GameJam 2023">《电击小子》-CiGA GameJam 2023</a><time datetime="2024-05-22T03:09:54.495Z" title="更新于 2024-05-22 11:09:54">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/41772/" title="《Revive》-UE GameJam 2022"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261616663.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="《Revive》-UE GameJam 2022"></a><div class="content"><a class="title" href="/posts/41772/" title="《Revive》-UE GameJam 2022">《Revive》-UE GameJam 2022</a><time datetime="2024-05-22T03:09:51.049Z" title="更新于 2024-05-22 11:09:51">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/57480/" title="《SCP》-游戏创作1 week3"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305221534305.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="《SCP》-游戏创作1 week3"></a><div class="content"><a class="title" href="/posts/57480/" title="《SCP》-游戏创作1 week3">《SCP》-游戏创作1 week3</a><time datetime="2024-05-22T03:09:48.669Z" title="更新于 2024-05-22 11:09:48">2024-05-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 徽墨行深</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hmxs.games/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div",{class:"katex-wrap"})})</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://hmxs-twikoo.netlify.app/.netlify/functions/twikoo",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://hmxs-twikoo.netlify.app/.netlify/functions/twikoo",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.textContent=o[0].count})).catch((function(t){console.error(t)}))})()},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};o()})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>