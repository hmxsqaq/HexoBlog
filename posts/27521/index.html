<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Algorithm4】读书笔记一：基础 | 👾Hmxs's Blog👾</title><meta name="author" content="徽墨行深,18321938171@163.com"><meta name="copyright" content="徽墨行深"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article"><meta property="og:title" content="【Algorithm4】读书笔记一：基础"><meta property="og:url" content="https://hmxs.games/posts/27521/index.html"><meta property="og:site_name" content="👾Hmxs&#39;s Blog👾"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png"><meta property="article:published_time" content="2023-09-13T15:03:11.000Z"><meta property="article:modified_time" content="2024-05-22T03:06:05.606Z"><meta property="article:author" content="徽墨行深"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Note"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png"><link rel="shortcut icon" href="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg"><link rel="canonical" href="https://hmxs.games/posts/27521/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Algorithm4】读书笔记一：基础",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-05-22 11:06:05"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.getCSS=(e,t=!1)=>new Promise((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom_loading.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()})</script><script>window.paceOptions={restartOnPushState:!1},document.addEventListener("pjax:send",()=>{Pace.restart()})</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png)"><nav id="nav"><span id="blog-info"><a href="/" title="👾Hmxs's Blog👾"><span class="site-name">👾Hmxs's Blog👾</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Algorithm4】读书笔记一：基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-13T15:03:11.000Z" title="发表于 2023-09-13 23:03:11">2023-09-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-22T03:06:05.606Z" title="更新于 2024-05-22 11:06:05">2024-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/Algorithm/">Algorithm</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/Algorithm/%E3%80%8AAlgorithms-4th-Edition%E3%80%8B/">《Algorithms, 4th Edition》</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="【Algorithm4】读书笔记一：基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/27521/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="algorithm4" style="zoom:50%"><blockquote><p><strong>官网：<a target="_blank" rel="noopener" href="https://algs4.cs.princeton.edu/home/">https://algs4.cs.princeton.edu/home/</a></strong></p><p><strong>笔记目录：<a href="https://hmxs.games/posts/25550/">https://hmxs.games/posts/25550/</a></strong></p></blockquote><hr><h1>基础</h1><h2 id="基础编程模型">基础编程模型</h2><blockquote><p><strong>《算法4》中主要采用了Java作为编程语言，而这章主要介绍了Java的语言基础</strong></p></blockquote><h3 id="Java基础">Java基础</h3><h4 id="编译流程">编译流程</h4><p>Java是一个完全遵循面向对象编程思想（<code>OOP</code>）进行设计的语言，其中通过<code>class</code>来组织所有的代码</p><p>在Java中，我们编写的是后缀名为<code>.java</code>的源代码文件，每个<code>.java</code>文件中都包含着一个同名类，每个类中都可以包含一个<code>main</code>入口函数</p><p>在命令行中使用<code>javac</code>命令可以对<code>.java</code>文件进行编译，编译通过后会生成后缀为<code>.class</code>的Java字节码文件，通过<code>java</code>命令即可运行<code>.class</code>文件中的<code>main</code>函数</p><h4 id="Java原理">Java原理</h4><p>Java是一门半解释半编译的语言，其会将源文件的高级语言先编译为Java字节码后运行在Java虚拟机（JVM）上</p><p>Java因此得以拥有了良好地跨平台性，Java字节码是不分平台的，只要对应平台实现了Java虚拟机，Java字节码即可运行在该平台上</p><p>同时Java虚拟机会在运行时对代码进行优化处理，使得Java同时拥有了比纯解释型语言更快的速度，在这一过程中还可以使得语言获得一定的运行时特性</p><hr><h3 id="重定向、管道与输入-输出">重定向、管道与输入/输出</h3><h4 id="标准输入">标准输入</h4><p>在Java中，<code>main</code>函数会接受一个<code>String[] args</code>类型的参数作为<code>main</code>函数的输入</p><p>而当我们使用<code>java</code>命令运行<code>.class</code>文件时（进行这一步时<code>.class</code>文件不需要输入后缀名），我们可以直接在后面追加参数作为<code>args</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java test abc 123 qwe</span><br></pre></td></tr></table></figure><p>如在上面这行命令中，我们通过<code>java</code>命令运行了<code>test.class</code>文件，而后续的<code>abc</code>、<code>123</code>、<code>qwe</code>则为输入，即<code>String[] args = &#123;&quot;abc&quot;, &quot;123&quot;, &quot;qwe&quot;&#125;;</code></p><h4 id="标准输出">标准输出</h4><p>在一般情况下，我们可以调用<code>System.out</code>库或本书作者提供的<code>Stdout</code>库将我们想要的内容输出到控制台上</p><p>同时<code>Stdout</code>也支持格式化输出，即类似<code>C/C++</code>中的<code>printf()</code></p><p>使用并无特殊之处，故不再详细赘述</p><h4 id="重定向">重定向</h4><p>在上面的标准输入/输出中我们都是在和控制台进行交互，这在进行一些大量数据的输入/输出时并不方便</p><p>而重定向允许我们直接从文本文件中读取输入，或直接将内容输出至文件中</p><p>重定向输入操作符为<code>&lt;</code>，输出则为<code>&gt;</code>，在其后面追加需要读取/输出到的文件路径即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java test &lt; data.txt &gt; output.txt</span><br></pre></td></tr></table></figure><p>上述意思为从<code>data.txt</code>文件中读取输入，并将输出内容输出至<code>output.txt</code></p><p>同时，重定向输入是可以和上述的标准输入混用的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java test data1.txt &lt; data2.txt</span><br></pre></td></tr></table></figure><p>如上面这段语句代表着<code>String[] args = &#123;&quot; data.txt&quot;, ...&#125;</code>，<code>...</code>为从<code>data2.txt</code>中读取到的内容</p><h4 id="管道">管道</h4><p>管道是进一步的重定向，其可以将上一个<code>.class</code>文件的输出作为下一个文件的输入，操作符为<code>|</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java test1 100 200 | java test2</span><br></pre></td></tr></table></figure><p>如上面这段语句代表将<code>args = [100, 200]</code>作为参数输入<code>test1.class</code>，后将<code>test1.class</code>的输出输入<code>test2.class</code></p><hr><h2 id="数据抽象">数据抽象</h2><blockquote><p><strong>数据类型指的是一组值和一组对这些值的操作的集合；本章主要介绍了数据类型的定义与使用，这个过程也被称为<code>数据抽象</code></strong></p></blockquote><h3 id="抽象数据类型的使用">抽象数据类型的使用</h3><h4 id="API与继承">API与继承</h4><p>我们使用API来对抽象数据类型中的函数与方法进行描述，这近似于静态方法库</p><p>同时我们可以通过继承类，覆写父类中的方法来实现API的灵活改变</p><h4 id="对象">对象</h4><p>而与静态方法库不同的是，数据类型往往需要依托于对象存在</p><blockquote><p><strong>对象是能够承载数据类型的值的实体</strong></p></blockquote><p>所有对象都具有三大重要特性：</p><ul><li>状态：即数据类型中的值</li><li>标识：即对象在内存中地址的引用</li><li>行为：即可对数据类型进行的操作</li></ul><p>数据类型的实现的唯一职责就是维护一个对象的身份，这样用例代码在使用数据类型时便只需要遵守描述对象行为的API即可，无需关心对象状态的表示方法</p><h4 id="对象的创建">对象的创建</h4><p>每种数据类型中的值都存储于一个对象中，使用<code>new</code>关键字即可实例化对象，即对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Counter</span> <span class="variable">heads</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="string">&quot;Header&quot;</span>)</span><br></pre></td></tr></table></figure><p>当我们使用<code>new</code>进行实例化时，系统会：</p><ul><li>为对象分配内存空间</li><li>调用构造函数</li><li>返回对象的引用</li></ul><p>我们可以用同一个类创建无数个对象</p><h4 id="对象赋值">对象赋值</h4><p>当我们对引用类型的变量进行赋值操作时，我们实际是创建了一个别名，复制了一遍内存地址</p><p>这只是一种浅拷贝，在使用时我们应注意这点</p><h4 id="对象总结">对象总结</h4><p>运用数据抽象的思想编写代码的方式被称为<code>面向对象编程</code>，这是一种极其重要的编程思想</p><p>一个数据类型的实现所支持的操作有：</p><ul><li>创建对象：使用<code>new</code>触发构造函数并创建对象，初始化对象中的值并返回对其的引用</li><li>操作对象中的值：使用和对象关联的变量调用实例方法来对对象中的值进行操作</li><li>操作多个对象：创建对象的数组，像原始数据类型的值一样将他们传递给方法或是从方法中返回，只是变量关联的是对象的引用而非对象本身</li></ul><hr><h3 id="抽象数据类型的实现">抽象数据类型的实现</h3><h4 id="Counter类"><code>Counter</code>类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">// final 类似C#中的const</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">(String id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Increment</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Tally</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> count + <span class="string">&quot; &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试用例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">heads</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="string">&quot;Heads&quot;</span>);</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">tails</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="string">&quot;Tails&quot;</span>);</span><br><span class="line"></span><br><span class="line">        heads.Increment();</span><br><span class="line">        heads.Increment();</span><br><span class="line">        tails.Increment();</span><br><span class="line"></span><br><span class="line">        StdOut.println(heads + <span class="string">&quot; &quot;</span> + tails);</span><br><span class="line">        StdOut.println(heads.Tally() + tails.Tally());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="VisualAccumulator类"><code>VisualAccumulator</code>类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisualAccumulator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> total;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VisualAccumulator</span><span class="params">(<span class="type">int</span> trials, <span class="type">double</span> max)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StdDraw.setXscale(<span class="number">0</span>, trials);</span><br><span class="line">        StdDraw.setYscale(<span class="number">0</span>, max);</span><br><span class="line">        StdDraw.setPenRadius(<span class="number">.005</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AddDataValue</span><span class="params">(<span class="type">double</span> value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        total += value;</span><br><span class="line">        StdDraw.setPenColor(StdDraw.DARK_GRAY);</span><br><span class="line">        StdDraw.point(n, value);</span><br><span class="line">        StdDraw.setPenColor(StdDraw.RED);</span><br><span class="line">        StdDraw.point(n, total / n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Mean</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> total / n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mean (&quot;</span> + n + <span class="string">&quot; values): &quot;</span> + String.format(<span class="string">&quot;%7.5f&quot;</span>, Mean());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">VisualAccumulator</span> <span class="variable">visualAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VisualAccumulator</span>(T, <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; T; i++)</span><br><span class="line">            visualAccumulator.AddDataValue(StdRandom.uniformDouble());</span><br><span class="line">        StdOut.println(visualAccumulator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数据类型的设计">数据类型的设计</h3><blockquote><p><strong>抽象数据类型是一种向用例隐藏内部表示的数据类型</strong></p></blockquote><h4 id="封装">封装</h4><p>面向对象编程的特征之一就是使用数据类型的实现封装数据，以简化实现和隔离用例开发</p><p>封装实现了模块化编程，它允许我们：</p><ul><li>独立开发用例和实现的代码</li><li>切换至改进的实现而不会影响用例的代码</li><li>支持尚未编写的程序</li></ul><p>封装同时也隔离了数据类型的操作，这使得我们可以：</p><ul><li>限制潜在的错误</li><li>在实现中添加一致性检查等调试工具</li><li>确保用例代码更明晰</li></ul><p>封装是实现高拓展性的关键，模块化编程成功的关键在于保持模块之间的独立性</p><h4 id="设计API">设计API</h4><p>设计API是构建现代软件最重要也是最有挑战的一项任务</p><p>它没有标准答案，需要经验、思考和反复的修改</p><blockquote><p><strong>这句格言或许有帮助：只为用例提供它们所需要的，仅此而已</strong></p></blockquote><h4 id="算法与抽象数据类型">算法与抽象数据类型</h4><p>数据抽象天生适合算法研究，其可以让我们：</p><ul><li>准确定义算法能为用例提供什么</li><li>隔离算法的实现和用例的代码</li><li>实现多层抽象，用已知算法实现其他算法</li></ul><h4 id="等价性">等价性</h4><p>当我们进行引用类型的等价性测试时，如<code>a == b</code>，我们比较的是其的引用，即比较是标识</p><p>而如果我们想进行状态的比较，可以实现<code>Object</code>类中的<code>equals</code>方法</p><p>Java约定<code>equals()</code>必须是一种等价性关系，它必须具有：</p><ul><li>自反性：<code>x.equals(x)</code>为<code>true</code></li><li>对称性：当<code>x.equals(y)</code>为<code>true</code>时，<code>y.equals(x)</code>也应为<code>true</code></li><li>传递性：当<code>x.equals(y)</code>，<code>y.equals(z)</code>都为<code>true</code>时，<code>x.equals(z)</code>为<code>true</code></li><li>一致性：当对象不变时，反复调用<code>x.equals(y)</code>的结果应相同</li><li>非空性：<code>x.equals(null)</code>应始终为<code>false</code></li></ul><h4 id="不可变性">不可变性</h4><p>我们可以通过<code>final</code>将某一变量标记为不可变，这意味着其在第一次赋值之后，值便无法改变了</p><p>但需要注意的是，对于引用类型，<code>final</code>只能保证引用的不变，即变量永远指向初始指定的内存，但无法保证内存中的内容不变</p><h4 id="异常与断言">异常与断言</h4><ul><li>异常：一般用于处理不受我们控制的不可预见的错误</li><li>断言：验证我们在代码中的一些假设</li></ul><p>断言是一个布尔表达式，当我们运行到断言处时，如果表达式为<code>false</code>，程序会直接抛出异常</p><p>我们可以在测试中使用断言来验证我们的想法，并且帮助我们更好地debug，保证代码永远不会被系统错误终止或进入死循环；但我们不应该在实际程序中使用他们，其在实际运行中可能会被禁用</p><blockquote><p><strong>契约式设计：数据类型的设计者需要说明前提条件（用例在调用某个方法前必须满足的条件）、后置条件（实现在方法返回时必须达到的要求）和副作用（方法可能对对象状态产生的任何其他变更）</strong></p></blockquote><hr><h2 id="背包、队列和栈">背包、队列和栈</h2><p>在本章中，会讲述背包（Bag）、队列（Queue）和栈（Stack）三种数据类型</p><h3 id="API">API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bag</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Bag();                <span class="comment">// 创建空背包</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T item)</span>;    <span class="comment">// 添加一个元素 </span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;    <span class="comment">// 背包是否为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;            <span class="comment">// 背包的元素数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Queue();                <span class="comment">// 创建空队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(T item)</span>;    <span class="comment">// 添加一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dequeue</span><span class="params">(T item)</span>;    <span class="comment">// 删除最早添加的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;        <span class="comment">// 队列是否为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;                <span class="comment">// 队列的元素数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Stack();            <span class="comment">// 创建空栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span>;    <span class="comment">// 添加一个元素</span></span><br><span class="line">    </span><br><span class="line">    T <span class="title function_">pop</span><span class="params">()</span>;            <span class="comment">// 删除最晚添加的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;    <span class="comment">// 栈是否为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;            <span class="comment">// 栈的元素数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型">泛型</h4><blockquote><p><strong>泛型，也叫做参数化类型，其可以被用来储存任意类型的数据</strong></p></blockquote><p>我们可以用任意数据类型来替换泛型中的<code>&lt;T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><h4 id="自动装箱">自动装箱</h4><p>类型参数必须被实例化为引用类型，因此Java有一种特殊机制来使泛型代码能够处理原始数据类型</p><p>Java中的中的原始数据类型都有着对应的引用类型，如<code>Boolean</code>、<code>Byte</code>、<code>Integer</code>分别对应<code>boolean</code>、<code>byte</code>、<code>int</code>，Java会自动对其进行类型转换</p><blockquote><p><strong>自动将一个原始数据类型转换为一个封装类型被称为自动装箱，反之则为自动拆箱</strong></p></blockquote><h4 id="背包">背包</h4><blockquote><p><strong>背包是一种不支持从中删除指定元素的集合数据类型，它的目的就是帮助用例收集元素，并迭代遍历所有收集到的元素</strong></p></blockquote><p>在背包中，迭代的顺序是不确定的；我们当然可以使用栈或队列或其他数据结构来完成这一项工作，但使用背包可以说明元素的处理顺序并不重要</p><p>下面是一个基于背包的计算标准差与平均值的程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bag&lt;Double&gt; numbers = <span class="keyword">new</span> <span class="title class_">Bag</span>&lt;Double&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (! StdIn.isEmpty())</span><br><span class="line">            numbers.add(StdIn.readDouble());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> numbers.size();</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> x : numbers)</span><br><span class="line">            sum += x;</span><br><span class="line">        <span class="type">double</span> <span class="variable">mean</span> <span class="operator">=</span> sum / N;</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> x : numbers)</span><br><span class="line">            sum += (x - mean) * (x - mean);</span><br><span class="line">        <span class="type">double</span> <span class="variable">std</span> <span class="operator">=</span> Math.sqrt(sum / (N - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        StdOut.printf(<span class="string">&quot;Mean: %.2f\n&quot;</span>, mean);</span><br><span class="line">        StdOut.printf(<span class="string">&quot;Std dev: %.2f\n&quot;</span>, std);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"><span class="comment">// 101</span></span><br><span class="line"><span class="comment">// 98</span></span><br><span class="line"><span class="comment">// 65</span></span><br><span class="line"><span class="comment">// ^D</span></span><br><span class="line"><span class="comment">// Mean: 91.00</span></span><br><span class="line"><span class="comment">// Std dev: 17.38</span></span><br></pre></td></tr></table></figure><h4 id="先进先出队列">先进先出队列</h4><blockquote><p><strong>队列是一种基于先进先出（FIFO）策略的集合类型</strong></p></blockquote><p><em>这在C++/C#或一些其他语言中都非常常见，不再赘述</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>在使用<code>foreach</code>进行遍历时，元素会以加入顺序被处理</p><h4 id="下压栈">下压栈</h4><blockquote><p><strong>栈是一种基于后进先出（LIFO）策略的集合类型</strong></p></blockquote><p><em>这在C++/C#或一些其他语言中都非常常见，不再赘述</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;;</span><br></pre></td></tr></table></figure><p>在使用<code>foreach</code>进行遍历时，元素被处理的顺序与加入顺序相反</p><h4 id="算术表达式求值">算术表达式求值</h4><p>对于字符串形式的算术表达式的求值，我们可以通过<code>E.W.Dijkstra</code>发明的双栈运算算法进行</p><p>表达式由括号、运算符和操作数组成，我们根据以下四种情况从左到右逐个将这些实体入栈处理：</p><ul><li>将操作数压入操作数栈</li><li>将运算符压入运算符栈</li><li>忽略左括号</li><li>在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符与操作数的运算结果压入操作数栈</li></ul><p>操作数栈上最后剩下的值即为表达式的值，下面是Java中的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evaluate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Dijkstra双栈算术表达式求值算法</span></span><br><span class="line">        Stack&lt;String&gt; operators = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Double&gt; values = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (! StdIn.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取字符</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> StdIn.readString();</span><br><span class="line">            <span class="comment">// 左括号则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;(&quot;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 是运算符则压入操作符栈</span></span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;+&quot;</span>) || s.equals(<span class="string">&quot;-&quot;</span>) || s.equals(<span class="string">&quot;*&quot;</span>) || s.equals(<span class="string">&quot;/&quot;</span>) || s.equals(<span class="string">&quot;sqrt&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                operators.push(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是右括号则出栈</span></span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;)&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">operator</span> <span class="operator">=</span> operators.pop();</span><br><span class="line">                <span class="type">Double</span> <span class="variable">value</span> <span class="operator">=</span> values.pop();</span><br><span class="line">                <span class="keyword">if</span> (operator.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                    values.push(values.pop() + value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                    values.push(values.pop() - value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;*&quot;</span>))</span><br><span class="line">                    values.push(values.pop() * value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">                    values.push(values.pop() / value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;sqrt&quot;</span>))</span><br><span class="line">                    values.push(Math.sqrt(value));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上述都不是则压入数值栈</span></span><br><span class="line">            values.push(Double.parseDouble(s));</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(values.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">//( ( 1 + sqrt ( 5.0 ) ) / 2.0 )</span></span><br><span class="line"><span class="comment">//^D</span></span><br><span class="line"><span class="comment">//1.618033988749895</span></span><br></pre></td></tr></table></figure><p>这段代码实际上是一个极其简单的“解释器”</p><hr><h3 id="集合类数据类型的实现">集合类数据类型的实现</h3><p>接下来就该来自己实现数据结构了！</p><h4 id="定容栈">定容栈</h4><p>我们将会从最简单的固定容量的字符串栈的实现开始，它要求用例指定一个容量且不支持迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedCapacityStackOfStrings</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FixedCapacityStackOfStrings</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123; s = <span class="keyword">new</span> <span class="title class_">String</span>[capacity]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(String item)</span></span><br><span class="line">    &#123; s[N++] = item; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> s[--N]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最简单的数据结构，但也是一切的基础</p><h4 id="泛型-2">泛型</h4><p>定容栈的第一个缺点是其只能处理<code>String</code>一种类型的数据，而泛型可以解决这一问题</p><p>需要注意的是，因为一些历史遗留问题，Java不能直接创建泛型数组，但我们可以通过类型转换来实现<code>T[] s = (T[]) new Object[capacity];</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedCapacityStack</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FixedCapacityStack</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123; s = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span></span><br><span class="line">    &#123; s[N++] = item; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> s[--N]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有<code>Sting</code>改为<code>T</code>即可</p><h4 id="动态调整数组的大小">动态调整数组的大小</h4><p>在Java中，数组一旦创建，其大小便无法改变了；但我们可以通过动态创建更大的数组并将原来的数组复制过来来实现数组大小的动态变化</p><p>通过以下函数便可以实现动态调整数组的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> new_capacity)</span></span><br><span class="line">&#123;</span><br><span class="line">    T[] temp = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[new_capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        temp[i] = array[i];</span><br><span class="line">    array = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后更改<code>push()</code>与<code>pop()</code>，在要溢出时扩容，利用率太低时减容，即可实现内存大小的动态调整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResizingArrayStack</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResizingArrayStack</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123; array = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= array.length)</span><br><span class="line">            resize(<span class="number">2</span> * N);</span><br><span class="line">        array[N++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> array[--N];</span><br><span class="line">        array[N] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N &lt;= array.length / <span class="number">4</span>)</span><br><span class="line">            resize(N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> new_capacity)</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[] temp = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[new_capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            temp[i] = array[i];</span><br><span class="line">        array = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代">迭代</h4><p>在Java中，实现迭代只需要让对应类继承<code>Iterable&lt;T&gt;</code>接口，并实现对应方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; </span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口中，可以看到我们需要实现一个返回值为<code>Iterator&lt;T&gt;</code>的<code>iterator()</code>方法即可</p><p>而<code>Iterator&lt;T&gt;</code>即为迭代器，迭代器中需要实现的方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们声明一个内部类继承<code>Iterator&lt;T&gt;</code>，并实现其中的方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ReverseArrayIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> i &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">return</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>迭代器的实现对于数据类型的封装是十分重要的，其可以让外部完全不关系内部实现，使用迭代器即可完成对内部元素的遍历</strong></p></blockquote><h4 id="最终实现">最终实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResizingArrayStack</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResizingArrayStack</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123; array = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= array.length)</span><br><span class="line">            resize(<span class="number">2</span> * N);</span><br><span class="line">        array[N++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> array[--N];</span><br><span class="line">        array[N] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N &lt;= array.length / <span class="number">4</span>)</span><br><span class="line">            resize(N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> new_capacity)</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[] temp = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[new_capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            temp[i] = array[i];</span><br><span class="line">        array = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReverseArrayIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ReverseArrayIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">        &#123; <span class="keyword">return</span> i &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ResizingArrayStack&lt;T&gt;</code>已经是一个颇具雏形的数据类型了，但在具体实现上，其还有着一定的问题</p><p>在进行<code>push()</code>与<code>pop()</code>操作时，数组的大小会被调整，这种调整的规模是呈指数上升的，这对内存与性能都并不友好，而使用链表可以解决这一缺陷，并以一种完全不同的方式组织数据</p><hr><h3 id="链表">链表</h3><blockquote><p><strong>链表是一种递归数据结构，它或为空，或为含有泛型元素的结点和指向另一个结点的引用</strong></p></blockquote><p><em>链表的基础概念较为简单，且笔者之前已经学过很多遍，此处不再赘述</em></p><ul><li>链表可以处理任意数据类型的数据</li><li>链表所需的空间总是和集合的大小成正比</li><li>链表操作所需时间总是和集合大小无关</li></ul><p>在上一章我们通过数组实现了可动态调整大小可迭代的下压数组</p><p>而使用链表来实现它们一样可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinklistStack</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        T value;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> head == <span class="literal">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        newNode.value = value;</span><br><span class="line">        newNode.next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> head.value;</span><br><span class="line">        head = head.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinklistIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LinklistIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">        &#123; <span class="keyword">return</span> current.next != <span class="literal">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> current.value;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>在结构化存储数据集时，链表是数组的一种重要的替代方法</strong></p></blockquote><hr><h3 id="总结">总结</h3><p>在研究一个新的应用领域时，我们应按照以下步骤识别目标并使用数据抽象解决问题：</p><ul><li>定义API</li><li>根据特定的应用场景开发用例代码</li><li>描述一种数据结构（一组值的表示），并在API所对应的抽象数据类型的实现中根据它定义类的实例变量</li><li>描述算法（实现一组操作的方法），并根据它实现类中的实例方法</li><li>分析算法的性能特点</li></ul><hr><h2 id="算法分析">算法分析</h2><blockquote><ul><li><strong>我的程序会运行多长时间</strong></li><li><strong>我的程序会耗费多少内存</strong></li></ul><p><strong>这是我们在编写代码时会不可避免地遇到的两大问题，而为这些基础问题给出答案实际上并不困难</strong></p></blockquote><h3 id="数学模型">数学模型</h3><p>根据Knuth的理论，尽管有着许多复杂因素影响着程序的效率，但原则上我们总可以构建出一个数学模型来描述任意程序的运行时间</p><p>一个程序的运行时间主要和两点有关：</p><ul><li>执行每条语句的耗时</li><li>执行每条语句的频率</li></ul><p>前者取决于计算机硬件和操作系统，后者取决于程序本身和输入，而我们最需要关注的便是后者</p><h4 id="近似">近似</h4><p>对于语句频率的分析往往会使我们得到一个复杂冗长的表达式，如对于下面这段程序而言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; N; k++)</span><br><span class="line">            sum++;</span><br></pre></td></tr></table></figure><p>得到的语句频率表达式为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>6</mn><mo>=</mo><msup><mi>N</mi><mn>3</mn></msup><mi mathvariant="normal">/</mi><mn>6</mn><mo>−</mo><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">N(N-1)(N-2)/6=N^3/6-N^2/2+N/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/6</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">/6</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mord">/3</span></span></span></span></p><p>这并不直观，但我们可以发现，当N比较大时，首项之后的其他项都相对较小</p><p>如对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">N=1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1000</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo>≈</mo><mn>499667</mn></mrow><annotation encoding="application/x-tex">-N^2/2+N/3\approx499667</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-.25em"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mord">/3</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">499667</span></span></span></span>，这相对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup><mi mathvariant="normal">/</mi><mn>6</mn><mo>≈</mo><mn>166666667</mn></mrow><annotation encoding="application/x-tex">N^3/6\approx166666667</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">/6</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">166666667</span></span></span></span>来说小了非常多，以至于可以省略</p><p>所以我们可以舍去除首项外的其他项来大大简化我们的表达式，从而得到一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">N^3/6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">/6</span></span></span></span></p><p>而实际上我们还可以进一步的简化，在首项的基础上舍去常数量，我们即可得到算法的<code>增长数量级</code>，如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">N^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p><strong>增长数量级（大O表示法）是一个非常重要的概念，其可以非常简单直观地表示一个算法的抽象效率，且与算法的具体实现无关</strong></p></blockquote><h4 id="成本模型">成本模型</h4><p>上述的增长数量级非常简单直观，但如果我们想要一种更加系统性且可以量化的方法来对算法的性能进行精确的比较或预测，我们便可以使用成本模型</p><blockquote><p><strong>成本模型是一个用于评估算法性能的概念框架，其定义了哪些操作或资源应该被计算，以及是如何进行计算的</strong></p></blockquote><p>在算法分析中，成本模型用于：</p><ol><li><strong>确定算法效率</strong>：通过计算算法执行中某些操作的数量，可以评估算法的运行时间。例如，在排序算法中，可能会计算比较和交换的次数</li><li><strong>比较算法</strong>：成本模型允许我们在同一基础上比较不同算法的性能。通过分析不同算法在相同成本模型下的行为，我们可以确定哪种算法更有效</li><li><strong>预测性能</strong>：通过对算法在不同输入大小下的成本进行数学建模，我们可以预测算法在更大输入上的行为</li></ol><p>在选择成本模型时，通常会选择对于特定算法和问题域来说最具代表性和影响力的操作。例如，在分析快速排序算法时，比较和交换可能是成本模型中最重要的操作，而在分析图算法时，可能会更关注边和顶点的遍历次数</p><h4 id="总结-2">总结</h4><p>对于大多数程序，得到其运行时间的数学模型所需步骤如下：</p><ul><li>确定输入模型，定义问题的规模</li><li>识别内循环</li><li>根据内循环中的操作确定成本模型</li><li>对于给定输入，判断这些操作的执行频率</li></ul><hr><h3 id="倍率实验">倍率实验</h3><p>倍率实验是一种估计运行时间的增长数量级的简单方法，我们通过倍率实验可以越过程序本身直接测试并预测出算法的运行效率</p><p>通过下面的方法我们便可以对一段程序进行倍率实验：</p><ul><li>使用一个输入生成器生成各规模的输入</li><li>不断提高输入规模并重新运行程序</li><li>直到运行时间与上一次的运行时间比值趋近于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8491em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8491em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span></li></ul><p>由此便可以得到倍率实验的结果，而被测程序的增长数量级便近似为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">N^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8491em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8491em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span></p><p>而，之所以运行时间的比值会趋近于一个常数是因为<code>倍率定理</code></p><blockquote><p><strong>倍率定理：</strong></p><p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>∽</mo><mi>a</mi><msup><mi>N</mi><mi>b</mi></msup><mi>lg</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">T(N) \backsim aN^b \lg N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel amsrm">∽</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-.1944em"></span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8491em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mop">l<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mn>2</mn><mi>N</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>∽</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">T(2N)/T(N) \backsim 2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel amsrm">∽</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8491em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8491em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span></p></blockquote><hr><h3 id="处理对于输入的依赖">处理对于输入的依赖</h3><p>我们通常采用大O表示法，即增长数量级来描述算法的效率，但需要注意的是，随着输入内容及规模的改变，算法的效率很可能会发生非常大的变化，这时我们便需要进行更为细致的分析</p><h4 id="输入模型">输入模型</h4><p>一种方法是更加小心细致地选择输入模型，如让输入模型足够适应现实情况</p><p>这种方法往往会面临以下两个缺点：</p><ol><li>输入模型可能是不切实际的</li><li>对输入的分析可能极端困难，所需的数学技巧远非一般的学生或程序员可以掌握</li></ol><h4 id="对最坏情况下的性能保证">对最坏情况下的性能保证</h4><p>我们需要从极度悲观的视角下来估算算法的信念</p><p>虽然我们是程序的设计者，但程序的输入确是来自于各个不同的用户（其中或许包含着恶意），我们需要确保即使程序接收到了异常规模的数据也不会直接崩溃，这是为性能做的最后一层保险</p><h4 id="随机化算法">随机化算法</h4><p>为性能提供保证的一种重要方法是引入随机性</p><p>如，大名鼎鼎的快速排序算法在最坏最坏的情况下性能会达到平方级别，但在输入完全随机的情况下，其在概率下的性能可以达到线性对数，要让其达到平方级的概率微乎其微</p><p>虽然概率不为0，但快速排序达到平方级的概率可能比电脑出问题的概率还低</p><p>因此，随机情况下的概率保证，在实际情况中也可以作为最坏情况下的性能保证</p><h4 id="操作序列">操作序列</h4><p>有些情况下，更改一次计时中某些操作的顺序也会改变程序的效率</p><p>如对于一个下压栈来说，一次性压入N个对象再将它们全部弹出所需的时间，和将这些操作混合进行所需的时间可能完全不同</p><p>我们需要将这些情况也考虑进去</p><h4 id="均摊分析">均摊分析</h4><p>提供性能保证的另一种方法是通过记录所有操作的总成本并除以操作总数来将成本均摊掉</p><p>这种方法可以用于分析一些每次调用的成本可能不同的方法，如之前实现的可动态调整大小的栈</p><hr><h3 id="内存">内存</h3><p>Java是基于JVM运行的，得益于此，其拥有自动内存管理的能力，但也正因此，其过高的内存占用常常被诟病，而JVM对于内存管理的实现也是高度依赖于硬件的，不同的操作系统与硬件会带来截然不同的内存分配策略与大小</p><p>但幸运的是，我们只是一个程序编写者<s>臭写代码的</s>，我们不必关心不同系统的JVM对于内存的具体实现，基本上只需要专注于基础数据类型与对象即可</p><p>每个基础数据类型就像内存世界中的原子，一切对象都基于他们而展开，而他们所占用的内存空间往往是固定的</p><h4 id="对象-2">对象</h4><p>而对于一个对象而言，我们只需要将所有实例变量所用的内存与对象本身的开销（一般为16字节）相加即可</p><p>如，一个<code>Integer</code>对象会使用24字节，其中包含16字节的对象开销，4字节<code>int</code>值以及4个填充字节</p><h4 id="链表-2">链表</h4><p>链表属于嵌套的非静态类，其中需要额外8个字节用于指向外部类的引用</p><p>对于下面的<code>Node</code>类而言，一共需要40字节的开销，其中包含16字节的对象开销，指向<code>Item</code>和<code>Node</code>的引用各8字节，另外加上8字节的额外开销</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组">数组</h4><p>Java中数组被实现为对象，它们一般都会因为记录长度而需要额外的内存</p><p>一个原始数据类型的数组一般需要24字节的头信息，其中包含16字节的对象开销，4字节用于保存长度以及4个填充字节</p><p>头信息再加上保存值所需的内存即为总内存开销</p><p>总的来说，与对象的计算方法类似</p><h4 id="字符串对象">字符串对象</h4><p>String的标准实现中含有4个实例变量：</p><ul><li>一个指向字符数组的引用：8字节</li><li>一个描述字符数组偏移量的int值：4字节</li><li>一个计数器int值：4字节</li><li>一个散列int值：4字节</li></ul><p>故String对象将会额外使用40字节：16字节对象开销、3个int变量各4字节、数组引用的8字节、4个填充字节</p><h4 id="字符串的值和子字符串">字符串的值和子字符串</h4><p>一个长度为N的String对象一般需要使用40字节加上（24+2N）字节</p><p>但考虑到字符串经常会和子字符串打交道，但字符串值的复制会产生很大的开销，所以Java会希望尽量避免在创建字符串时进行字符串的复制</p><p>所以当我们调用<code>substring()</code>时，我们虽然仍然会创建一个新对象，但其中数组引用可以指向旧数组，只需改变偏移量与长度即可</p><p>因此，一个子字符串所需的额外内存是一个常数，构建一个子字符串所需的时间也是常数</p><hr><h3 id="展望">展望</h3><p>良好的性能是非常重要的，效率极低的程序几乎和不正确的程序一样无用，因此关注程序的运行开销是重要的</p><p>但在编程领域中，有两个常见错误时常发生</p><ul><li>其一是过于关注的程序的性能</li></ul><p>我们应先明白，我们的首要任务是写出清晰而明确的代码，而非花费大量时间却只让程序快了0.1秒</p><p>特别是在计算机硬件如此发达的今天，对于一个运行只需要一瞬的程序而言，即使你让他快了10倍也是无关紧要的</p><p>而快速排序的发明者Hoare也曾说过：”<strong>不成熟的优化是所有罪恶之源。</strong>“</p><ul><li>其二是完全忽略了程序的性能</li></ul><p>较快的算法往往比暴力求解复杂许多，这也导致了一部分人不愿意应付它们，但实际上，有时候几行代码的优化便可以带来成倍的性能提升</p><p>同时，当我们面临大规模问题时，寻找更好的算法是我们的唯一解</p><hr><h2 id="案例研究：union-find算法">案例研究：union-find算法</h2><p>下面让我们从一个实际案例入手，开始我们真正意义上的算法学习吧！</p><h3 id="问题描述：动态连通性的判定">问题描述：动态连通性的判定</h3><p>如下图所示</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202310071311415.png" alt="img"></p><p>假设我们输入了一组整数对，即上图中的<code>(4, 3) (3, 8)</code>等等，每对整数代表这两个points/sites是连通的。那么随着数据的不断输入，整个图的连通性也会发生变化，从上图中可以很清晰的发现这一点。同时，对于已经处于连通状态的points/sites，直接忽略，比如上图中的<code>(8, 9)</code></p><hr><h3 id="动态连通性的应用">动态连通性的应用</h3><ul><li>网络连接判断</li></ul><p>如果每个pair中的两个整数分别代表一个网络节点，那么该pair就是用来表示这两个节点是需要连通的。那么为所有的pairs建立了动态连通图后，就能够尽可能少的减少布线的需要，因为已经连通的两个节点会被直接忽略掉</p><ul><li>变量名等价性</li></ul><p>某些编程环境允许声明两个等价的变量名（指向同一个对象的多个引用），在一系列别名被声明后，系统需要能够判别两个给定的变量名是否等价</p><ul><li>数学集合</li></ul><p>在更高的抽象层次上，可以将输入的所有整数看做属于不同的数学集合，在处理一个整数对pq时，我们是在判断它们是否属于相同的集合，如果不是，我们会将p所属的集合和q所属的集合归并到一个集合中</p><hr><h3 id="实现">实现</h3><h4 id="API与框架">API与框架</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123; <span class="keyword">return</span> find(p) == find(q); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">// todo</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> <span class="comment">// todo</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(N);</span><br><span class="line">        <span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(p, q))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">            StdOut.println(p + <span class="string">&quot; &quot;</span> + q);</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(uf.getCount() + <span class="string">&quot;components&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>int id[]</code>：标识符数组，索引为触点值</p></li><li><p><code>void union(int p, int q)</code>：如果两个触点在不同分量中，<code>union()</code>会将两个分量归并</p></li><li><p><code>int find(int k)</code>：返回给定触点所在分量的标识符</p></li><li><p><code>boolean connected(int p, int q)</code>：判断两个触点是否处于同一个分量中</p></li><li><p><code>int getCount()</code>：返回所有连通分量的数量</p></li></ul><h4 id="quick-find算法"><code>quick-find</code>算法</h4><p>我们可以引入“标识值”概念来表示某一分量，即同一分量的标示值都相同</p><p>直接将<code>id[p]</code>作为<code>p</code>触点的标识值，那么若<code>id[p]==id[q]</code>，则p和q是连通的</p><p>如此一来我们只需要保证将同一分量的触点的标识符都统一即可</p><ul><li><code>int find(int k)</code>：返回<code>id[k]</code>的值即可</li><li><code>void union(int p, int q)</code>：先判断q、p是否连通，如果是则直接返回，如果不是那么遍历<code>id</code>，将<code>id</code>中所有标识值等于<code>id[p]</code>的改为<code>id[q]</code>即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span> &#123; <span class="keyword">return</span> id[k]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pID</span> <span class="operator">=</span> id[p];</span><br><span class="line">    <span class="type">int</span> <span class="variable">qID</span> <span class="operator">=</span> id[q];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pID == qID)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (id[i] == pID) id[i] = qID;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>分析：在<code>quick-find</code>中，<code>find()</code>操作非常快，但是<code>union()</code>每次都需要遍历整个数组，当问题规模较大时效率较低，其时间复杂度约为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></strong></p></blockquote><h4 id="quick-union算法"><code>quick-union</code>算法</h4><p>在<code>quick-find</code>中，同一分量中所有元素都拥有同一标识值</p><p>而实际上我们并不需要使得分量中的标识值都相同，也能表示一个分量</p><p>我们可以使用“单向链接”，即指向的方式来连通两个触点，一个触点的标识值为另一个与之连通的触点，若p与q是连通的，那么<code>id[p] = q</code>，即<code>p</code>指向<code>q</code></p><p>因为分量是由单向链接的一个个触点构成，所以总会存在一个<code>k = id[k]</code>的根触点，其类似链表的头，而我们进行链接时也是对根触点进行操作</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202310071807652.png" alt="img"></p><ul><li><code>int find(int k)</code>：找到并返回根触点</li><li><code>void union(int p, int q)</code>：找到需要归并的两个分量的根触点，将其中的一个指向至另一个即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (k != id[k])</span><br><span class="line">        k = id[k];</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    id[pRoot] = qRoot;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>分析：对于<code>quick-union</code>算法的成本分析较为困难，其效率会随着输入的改变发生很大的变化，在最好的情况下其时间复杂度可以达到线性级别，而最坏情况下其也会到达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的复杂度，但总的来说，<code>quick-union</code>虽然不能保证其在每种情况下都比<code>quick-find</code>要快，但其仍然是对<code>quick-find</code>算法的改良</strong></p></blockquote><h4 id="加权quick-union算法">加权<code>quick-union</code>算法</h4><p><code>quick-union</code>中基于“单向链接”的触点关系的组织方式是类似数据结构中的“树”的方式，而影响<code>quick-union</code>效率的一个很重要的因素便是树的深度过深，导致使用<code>find()</code>寻找根节点时，需要经历很长遍历；这一情况的产生很大程度上是由于在链接两颗树时顺序的随意，导致较深的树被链接到了较浅的树的根节点上，使得树变得越来越深，而我们若能记录每棵树的深度，并以此有顺序地进行分量的链接，<code>quick-union</code>算法的效率便可以得到大幅提升，这便是加权<code>quick-union</code>算法</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202310072332226.png" alt="img"></p><p>加权<code>quick-union</code>算法需要一个额外的数组来记录各个分量的深度，下面是加权<code>quick-union</code>算法的基本实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeightedQuickUnionFind</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightedQuickUnionFind</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">            size[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123; <span class="keyword">return</span> find(p) == find(q); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k != id[k])</span><br><span class="line">            k = id[k];</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size[pRoot] &gt; size[qRoot])</span><br><span class="line">        &#123; </span><br><span class="line">            id[qRoot] = pRoot; </span><br><span class="line">            size[pRoot] += size[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; </span><br><span class="line">            id[pRoot] = qRoot; </span><br><span class="line">            size[qRoot] += size[pRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">        <span class="type">WeightedQuickUnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeightedQuickUnionFind</span>(N);</span><br><span class="line">        <span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(p, q))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">            StdOut.println(p + <span class="string">&quot; &quot;</span> + q);</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(uf.getCount() + <span class="string">&quot;components&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>分析：加权<code>quick-union</code>算法的时间复杂度可以达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lg</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\lg N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mop">l<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>，其是三种算法中唯一可以解决大规模实际问题的算法</strong></p></blockquote><p><strong>为什么使用分量的大小而非高度作为比较值？</strong></p><ul><li>因为union-find中树的构成方式，其形成的数的高度永远不会大于大小的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9386em;vertical-align:-.2441em"></span><span class="mop"><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.207em"><span style="top:-2.4559em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2441em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>，所以并不会造成问题，其带来的性能变化微乎其微</li><li>union-find中树的大小更好追踪，特别是使用了路径压缩方法后，树的根节点与高度会发生变化，高度很难准确追踪</li></ul><h4 id="最优算法：路径压缩优化">最优算法：路径压缩优化</h4><p>最好的算法总是大家所趋之若鹜的，而加权<code>quick-union</code>算法虽已经很优秀，但仍然还有优化空间</p><p>路径压缩方法便是很容易实现的高效优化思路，其优化思路非常简单，既然我们希望树的深度尽量小，那么让元素尽量链接在根节点上就行了，只需要为<code>find()</code>添加一个循环，将在路径上遇到的所有节点都直接链接到根节点，那么我们就能得到一个近乎完全扁平的树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> k;</span><br><span class="line">    <span class="comment">// 找到根节点</span></span><br><span class="line">    <span class="keyword">while</span> (root != id[root])</span><br><span class="line">        root = id[root];</span><br><span class="line">    <span class="comment">// 将中间所有的节点链接至根节点</span></span><br><span class="line">    <span class="keyword">while</span> (k != root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> id[k];</span><br><span class="line">        id[k] = root;</span><br><span class="line">        k = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法简单有效，其可以产生近乎于理想情况下的树</p><p>而加上路径压缩方法后，实际情况下已经很难再对加权<code>quick-union</code>算法进行改进了</p><blockquote><p><strong>路径压缩的quick-union算法是解决动态连通性问题的最佳算法，其均摊效率可以接近与常数级</strong></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hmxs.games">徽墨行深</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hmxs.games/posts/27521/">https://hmxs.games/posts/27521/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hmxs.games" target="_blank">👾Hmxs's Blog👾</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a><a class="post-meta__tags" href="/tags/Note/">Note</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/59951/" title="【Algorithm4】读书笔记二：排序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Algorithm4】读书笔记二：排序</div></div></a></div><div class="next-post pull-right"><a href="/posts/25550/" title="【Algorithm4】读书笔记零：目录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Algorithm4】读书笔记零：目录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/59951/" title="【Algorithm4】读书笔记二：排序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-08</div><div class="title">【Algorithm4】读书笔记二：排序</div></div></a></div><div><a href="/posts/25550/" title="【Algorithm4】读书笔记零：目录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-13</div><div class="title">【Algorithm4】读书笔记零：目录</div></div></a></div><div><a href="/posts/18628/" title="【LeetCode】算法练习记录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309090059804.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-09</div><div class="title">【LeetCode】算法练习记录</div></div></a></div><div><a href="/posts/17194/" title="【C#-泛型约束】学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281818840.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-28</div><div class="title">【C#-泛型约束】学习笔记</div></div></a></div><div><a href="/posts/10824/" title="【C#-反射】学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281818840.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-22</div><div class="title">【C#-反射】学习笔记</div></div></a></div><div><a href="/posts/17021/" title="【3B1B-线性代数的本质】学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100312370.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">【3B1B-线性代数的本质】学习笔记</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">徽墨行深</div><div class="author-info__description">一个来自中传游戏系的大二学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hmxsqaq"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hmxsqaq" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:18321938171@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/11752174" target="_blank" title="BiliBili"><i class="fab fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到徽墨的博客！<br>目前中传游戏系大二在读<br>想要成为一名游戏开发者<br>随缘更新，请多指教！😆</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基础编程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">编译流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Java原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-number">1.1.2.</span> <span class="toc-text">重定向、管道与输入&#x2F;输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">标准输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">标准输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">管道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">数据抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">抽象数据类型的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">API与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">对象赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">对象总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">抽象数据类型的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Counter%E7%B1%BB"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Counter类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VisualAccumulator%E7%B1%BB"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">VisualAccumulator类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.3.</span> <span class="toc-text">数据类型的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1API"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">设计API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">算法与抽象数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">等价性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">不可变性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%96%AD%E8%A8%80"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">异常与断言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">背包、队列和栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.3.1.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">自动装箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">背包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">先进先出队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E5%8E%8B%E6%A0%88"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">下压栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">算术表达式求值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">集合类数据类型的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%AE%B9%E6%A0%88"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">定容栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-2"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">动态调整数组的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">最终实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">数学模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%91%E4%BC%BC"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">近似</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">成本模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%8D%E7%8E%87%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.4.2.</span> <span class="toc-text">倍率实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%B9%E4%BA%8E%E8%BE%93%E5%85%A5%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-number">1.4.3.</span> <span class="toc-text">处理对于输入的依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">输入模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BF%9D%E8%AF%81"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">对最坏情况下的性能保证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">随机化算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">操作序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%87%E6%91%8A%E5%88%86%E6%9E%90"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">均摊分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.4.4.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-2"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8-2"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">字符串对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%80%BC%E5%92%8C%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">字符串的值和子字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%95%E6%9C%9B"><span class="toc-number">1.4.5.</span> <span class="toc-text">展望</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9Aunion-find%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">案例研究：union-find算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">1.5.1.</span> <span class="toc-text">问题描述：动态连通性的判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">动态连通性的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E4%B8%8E%E6%A1%86%E6%9E%B6"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">API与框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quick-find%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">quick-find算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quick-union%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">quick-union算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83quick-union%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">加权quick-union算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">最优算法：路径压缩优化</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/59951/" title="【Algorithm4】读书笔记二：排序"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Algorithm4】读书笔记二：排序"></a><div class="content"><a class="title" href="/posts/59951/" title="【Algorithm4】读书笔记二：排序">【Algorithm4】读书笔记二：排序</a><time datetime="2024-09-29T19:17:21.937Z" title="更新于 2024-09-30 03:17:21">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24391/" title="《吹气球》-游戏创作2 week1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211553628.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="《吹气球》-游戏创作2 week1"></a><div class="content"><a class="title" href="/posts/24391/" title="《吹气球》-游戏创作2 week1">《吹气球》-游戏创作2 week1</a><time datetime="2024-07-21T08:57:52.846Z" title="更新于 2024-07-21 16:57:52">2024-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/12662/" title="从零开始的C++软光栅渲染器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202406202341390.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="从零开始的C++软光栅渲染器"></a><div class="content"><a class="title" href="/posts/12662/" title="从零开始的C++软光栅渲染器">从零开始的C++软光栅渲染器</a><time datetime="2024-07-21T08:57:52.845Z" title="更新于 2024-07-21 16:57:52">2024-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/61857/" title="《BlindTrust》-游戏创作2 week3"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211628143.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="《BlindTrust》-游戏创作2 week3"></a><div class="content"><a class="title" href="/posts/61857/" title="《BlindTrust》-游戏创作2 week3">《BlindTrust》-游戏创作2 week3</a><time datetime="2024-07-21T08:57:52.842Z" title="更新于 2024-07-21 16:57:52">2024-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/10127/" title="《AssAssIn》-游戏创作2结课"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211639045.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="《AssAssIn》-游戏创作2结课"></a><div class="content"><a class="title" href="/posts/10127/" title="《AssAssIn》-游戏创作2结课">《AssAssIn》-游戏创作2结课</a><time datetime="2024-07-21T08:57:52.837Z" title="更新于 2024-07-21 16:57:52">2024-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 徽墨行深</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hmxs.games/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div",{class:"katex-wrap"})})</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://hmxs-twikoo.netlify.app/.netlify/functions/twikoo",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://hmxs-twikoo.netlify.app/.netlify/functions/twikoo",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.textContent=o[0].count})).catch((function(t){console.error(t)}))})()},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};o()})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>