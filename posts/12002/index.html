<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>「Unity」基于柏林噪声的程序化地形生成 | Hmxs's Blog</title><meta name="author" content="徽墨行深,hmxsqaq@gmail.com"><meta name="copyright" content="徽墨行深"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article"><meta property="og:title" content="「Unity」基于柏林噪声的程序化地形生成"><meta property="og:url" content="https://hmxs.games/posts/12002/index.html"><meta property="og:site_name" content="Hmxs&#39;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281303069.jpg"><meta property="article:published_time" content="2024-07-15T05:00:58.000Z"><meta property="article:modified_time" content="2025-05-24T08:38:09.021Z"><meta property="article:author" content="徽墨行深"><meta property="article:tag" content="Unity"><meta property="article:tag" content="Note"><meta property="article:tag" content="Algorithm"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281303069.jpg"><link rel="shortcut icon" href="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg"><link rel="canonical" href="https://hmxs.games/posts/12002/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"「Unity」基于柏林噪声的程序化地形生成",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-05-24 16:38:09"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach(e=>{n.setAttribute(e,t[e])}),document.head.appendChild(n)}),e.getCSS=(e,t=!1)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/hmxs_custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom_loading.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions={restartOnPushState:!1},document.addEventListener("pjax:send",()=>{Pace.restart()})</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281303069.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="Hmxs's Blog"><span class="site-name">Hmxs's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「Unity」基于柏林噪声的程序化地形生成</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-15T05:00:58.000Z" title="发表于 2024-07-15 13:00:58">2024-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-24T08:38:09.021Z" title="更新于 2025-05-24 16:38:09">2025-05-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="「Unity」基于柏林噪声的程序化地形生成"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/12002/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281303069.jpg" alt=""></p><h1>基于柏林噪声的程序化地形生成</h1><h2 id="前言">前言</h2><p>随着图形学技术的高速发展，程序化生成技术（Procedural Generation）在游戏开发中的应用正在变得越来越广泛，从《我的世界》（Minecraft）、《文明》系列（Civilization）到各类类 Rogue 游戏，程序化生成技术展示了其巨大的潜力与无限的可能性，其很大程度上解放了生产力，让艺术家无需为庞杂繁琐的场景编辑而烦恼，也为游戏提供了无与伦比的重玩价值，让每一次“新游戏”都充满了惊喜。</p><p>在众多的程序化生成技术中，由 Ken Perlin 于 1983 年提出的柏林噪声算法（Perlin Noise）因其可以生成平滑、自然的噪声图像而备受青睐；其独特的平滑过渡的特性，使其在模拟自然现象、生成地形和纹理方面表现地尤为出色；在经久不衰的沙盒游戏《我的世界》的地图生成算法中就大量运用到了柏林噪声。</p><p>本文旨在以一个初学者的视角探索柏林噪声算法的原理、实现与其在程序化生成中的实际应用；笔者将使用 Unity 游戏引擎与 C# 语言实际实现具体的算法并将算法应用在实际的程序化生成中，如 2D Tilemap 的地图生成、 3D 类山地地形生成等；此外，为进一步提升程序化生成的效果，本文还将继续探讨一些柏林噪声的进阶应用与效果优化，如分形柏林噪声、渐进梯度算法、侵蚀算法等。同时，为了更加全面地了解程序化生成技术，本文还将简要介绍其它几种常见的算法，如 Simplex 噪声算法与 DLA 算法。</p><p>通过本文的探索，笔者旨在对程序化生成技术形成一个整体的认识，并了解其中的一些技术与算法的实现。</p><h2 id="什么是柏林噪声">什么是柏林噪声</h2><h3 id="概述">概述</h3><p>在程序功能的实现中，我们常常会使用 rand() 函数来生成随机值来实现一些功能，但在这种简单的随机下，每次生成的值都有些太过“随机”了，其得到的结果往往参差不齐，而我们的世界并不是这样，山川河流都有其走势流向，当我们需要生成随机的地形或实现其他类似功能时，简单的随机往往不能满足我们的要求。而在计算机图形学中，噪声可以被描述为一种随机的信号；使用一些特定的噪声算法，我们便可以得到随机但过渡平缓的信号。</p><p>而柏林噪声（Perlin Noise）顾名思义也是噪声的一种，其特点在于其是一种可以产生连续平滑的可哈希的随机值的噪声生成算法，避免了传统噪声函数中常见的尖锐边界和不自然的过渡。其最早由 Ken Perlin 于 1983 年发明，最初被用于电影《电子世界争霸战》中的特效制作，并在 1985 年获得了奥斯卡科学技术奖。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281315736.png" alt="image3" style="zoom:25%"><p>柏林噪声的有着两点极其重要的特性：</p><ul><li>梯度性：当其入参连续时，其返回的随机噪声值也连续</li><li>可哈希性：当入参相同时，返回值也相同</li></ul><p>这两点给予了柏林噪声无与伦比的灵活性与泛用性。</p><h3 id="原理">原理</h3><p>实现柏林噪声的核心思想实际并不复杂：通过插值实现平滑过渡的梯度；以下是具体的实现原理：</p><ol><li>定义晶格并分配梯度</li></ol><p>在某一维度的空间中，以一定固定间隔定义一个晶格，通过一定规则为每个晶格点分配一个随机梯度向量</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281319049.png" alt="image4" style="zoom:33%"><ol start="2"><li>计算给定坐标点所处晶格</li></ol><p>根据给定点可以得到其所处的晶格，在二维空间中即为4个相邻晶格点，可以得到晶格点到给定坐标点的向量</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281320386.png" alt="image5" style="zoom:33%"><ol start="3"><li>计算梯度值</li></ol><p>对于每个晶格点，计算其梯度向量与步骤2得到向量的点积，这些点积值表示该点在每个晶格点方上的“影响”，此处称为“梯度值”</p><ol start="4"><li>插值得到噪声值</li></ol><p>使用插值函数，如二维平面中的双线性插值，对得到的梯度值进行插值，便可得到最终的噪声值</p><h3 id="柏林噪声的算法实现">柏林噪声的算法实现</h3><p>在上一章中，笔者简单介绍了柏林噪声的原理，这看上去并不难，但是在其实现上仍然有许多值得注意的点，笔者依据 Ken Perlin 在 SIGGRAPH 2002 上发表的论文《Improving Noise》在 Unity 中实现了柏林噪声算法的 C# 版本：</p><p><a target="_blank" rel="noopener" href="https://github.com/hmxsqaq/Unity-ProceduralMapGenerationPerlinNoise/blob/master/Assets/Scripts/PerlinNoise.cs">https://github.com/hmxsqaq/Unity-ProceduralMapGenerationPerlinNoise/blob/master/Assets/Scripts/PerlinNoise.cs</a></p><p><em>实际上 Unity 的 Mathf 库中提供了直接获取柏林噪声的方法，这里的实现是为了更好地理解算法，如果只是出于应用目的，直接使用库函数即可。</em></p><p>在笔者的版本中，笔者分别实现了二维空间与三维空间中的柏林噪声，二者的基本思路相似，以下将介绍 2D 柏林噪声算法的具体实现方式：</p><ul><li>哈希序列</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> List&lt;<span class="built_in">int</span>&gt; Permutation256 = <span class="keyword">new</span>(<span class="number">256</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">151</span>, <span class="number">160</span>, <span class="number">137</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="number">15</span>, <span class="number">131</span>, <span class="number">13</span>, <span class="number">201</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">53</span>, <span class="number">194</span>, <span class="number">233</span>, <span class="number">7</span>, <span class="number">225</span>, <span class="number">140</span>, <span class="number">36</span>, <span class="number">103</span>, <span class="number">30</span>, <span class="number">69</span>, <span class="number">142</span>, <span class="number">8</span>, <span class="number">99</span>, <span class="number">37</span>,</span><br><span class="line">    <span class="number">240</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">190</span>, <span class="number">6</span>, <span class="number">148</span>, <span class="number">247</span>, <span class="number">120</span>, <span class="number">234</span>, <span class="number">75</span>, <span class="number">0</span>, <span class="number">26</span>, <span class="number">197</span>, <span class="number">62</span>, <span class="number">94</span>, <span class="number">252</span>, <span class="number">219</span>, <span class="number">203</span>, <span class="number">117</span>, <span class="number">35</span>, <span class="number">11</span>, <span class="number">32</span>, <span class="number">57</span>, <span class="number">177</span>,</span><br><span class="line">    <span class="number">33</span>, <span class="number">88</span>, <span class="number">237</span>, <span class="number">149</span>, <span class="number">56</span>, <span class="number">87</span>, <span class="number">174</span>, <span class="number">20</span>, <span class="number">125</span>, <span class="number">136</span>, <span class="number">171</span>, <span class="number">168</span>, <span class="number">68</span>, <span class="number">175</span>, <span class="number">74</span>, <span class="number">165</span>, <span class="number">71</span>, <span class="number">134</span>, <span class="number">139</span>, <span class="number">48</span>, <span class="number">27</span>, <span class="number">166</span>, <span class="number">77</span>, <span class="number">146</span>,</span><br><span class="line">    <span class="number">158</span>, <span class="number">231</span>, <span class="number">83</span>, <span class="number">111</span>, <span class="number">229</span>, <span class="number">122</span>, <span class="number">60</span>, <span class="number">211</span>, <span class="number">133</span>, <span class="number">230</span>, <span class="number">220</span>, <span class="number">105</span>, <span class="number">92</span>, <span class="number">41</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">245</span>, <span class="number">40</span>, <span class="number">244</span>, <span class="number">102</span>, <span class="number">143</span>, <span class="number">54</span>, <span class="number">65</span>, <span class="number">25</span>,</span><br><span class="line">    <span class="number">63</span>, <span class="number">161</span>, <span class="number">1</span>, <span class="number">216</span>, <span class="number">80</span>, <span class="number">73</span>, <span class="number">209</span>, <span class="number">76</span>, <span class="number">132</span>, <span class="number">187</span>, <span class="number">208</span>, <span class="number">89</span>, <span class="number">18</span>, <span class="number">169</span>, <span class="number">200</span>, <span class="number">196</span>, <span class="number">135</span>, <span class="number">130</span>, <span class="number">116</span>, <span class="number">188</span>, <span class="number">159</span>, <span class="number">86</span>, <span class="number">164</span>, <span class="number">100</span>,</span><br><span class="line">    <span class="number">109</span>, <span class="number">198</span>, <span class="number">173</span>, <span class="number">186</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">52</span>, <span class="number">217</span>, <span class="number">226</span>, <span class="number">250</span>, <span class="number">124</span>, <span class="number">123</span>, <span class="number">5</span>, <span class="number">202</span>, <span class="number">38</span>, <span class="number">147</span>, <span class="number">118</span>, <span class="number">126</span>, <span class="number">255</span>, <span class="number">82</span>, <span class="number">85</span>, <span class="number">212</span>, <span class="number">207</span>, <span class="number">206</span>,</span><br><span class="line">    <span class="number">59</span>, <span class="number">227</span>, <span class="number">47</span>, <span class="number">16</span>, <span class="number">58</span>, <span class="number">17</span>, <span class="number">182</span>, <span class="number">189</span>, <span class="number">28</span>, <span class="number">42</span>, <span class="number">223</span>, <span class="number">183</span>, <span class="number">170</span>, <span class="number">213</span>, <span class="number">119</span>, <span class="number">248</span>, <span class="number">152</span>, <span class="number">2</span>, <span class="number">44</span>, <span class="number">154</span>, <span class="number">163</span>, <span class="number">70</span>, <span class="number">221</span>, <span class="number">153</span>,</span><br><span class="line">    <span class="number">101</span>, <span class="number">155</span>, <span class="number">167</span>, <span class="number">43</span>, <span class="number">172</span>, <span class="number">9</span>, <span class="number">129</span>, <span class="number">22</span>, <span class="number">39</span>, <span class="number">253</span>, <span class="number">19</span>, <span class="number">98</span>, <span class="number">108</span>, <span class="number">110</span>, <span class="number">79</span>, <span class="number">113</span>, <span class="number">224</span>, <span class="number">232</span>, <span class="number">178</span>, <span class="number">185</span>, <span class="number">112</span>, <span class="number">104</span>, <span class="number">218</span>,</span><br><span class="line">    <span class="number">246</span>, <span class="number">97</span>, <span class="number">228</span>, <span class="number">251</span>, <span class="number">34</span>, <span class="number">242</span>, <span class="number">193</span>, <span class="number">238</span>, <span class="number">210</span>, <span class="number">144</span>, <span class="number">12</span>, <span class="number">191</span>, <span class="number">179</span>, <span class="number">162</span>, <span class="number">241</span>, <span class="number">81</span>, <span class="number">51</span>, <span class="number">145</span>, <span class="number">235</span>, <span class="number">249</span>, <span class="number">14</span>, <span class="number">239</span>, <span class="number">107</span>,</span><br><span class="line">    <span class="number">49</span>, <span class="number">192</span>, <span class="number">214</span>, <span class="number">31</span>, <span class="number">181</span>, <span class="number">199</span>, <span class="number">106</span>, <span class="number">157</span>, <span class="number">184</span>, <span class="number">84</span>, <span class="number">204</span>, <span class="number">176</span>, <span class="number">115</span>, <span class="number">121</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">127</span>, <span class="number">4</span>, <span class="number">150</span>, <span class="number">254</span>, <span class="number">138</span>, <span class="number">236</span>, <span class="number">205</span>,</span><br><span class="line">    <span class="number">93</span>, <span class="number">222</span>, <span class="number">114</span>, <span class="number">67</span>, <span class="number">29</span>, <span class="number">24</span>, <span class="number">72</span>, <span class="number">243</span>, <span class="number">141</span>, <span class="number">128</span>, <span class="number">195</span>, <span class="number">78</span>, <span class="number">66</span>, <span class="number">215</span>, <span class="number">61</span>, <span class="number">156</span>, <span class="number">180</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> List&lt;<span class="built_in">int</span>&gt; Permutation512 = <span class="keyword">new</span>(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">PerlinNoise</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Permutation512.AddRange(Permutation256);</span><br><span class="line">    Permutation512.AddRange(Permutation256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述所示数组 <code>Permutation256</code> 与 <code>Permutation512</code> 为随机哈希序列，其中 <code>Permutation256</code> 中存储了随机顺序的 0 ~ 255，而 <code>Permutation512</code> 则为 256 数组的复制填充，目的是为了方便后续访问。</p><p>随机哈希数列提供了赋予晶格点随机梯度向量的能力，其决定了梯度向量的分配情况，理论上说这一哈希数列的元素顺序是可以随机分配的，而上述代码中手动定义的是 Ken Perlin 教授论文中定义的经典初始值。</p><p>需要注意的是上面说的“可以随机分配”是指可以每次初始化时重新随机，但是在同一轮柏林噪声的计算中，其不应该被改变，改变改数组会引起梯度向量的变化，这和柏林噪声希望的“伪随机”，即输入值相同、返回的随机值也应相同的理念背道而驰。</p><ul><li><code>Lerp</code> 与 <code>Floor</code> 函数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Floor</span>(<span class="params"><span class="built_in">float</span> x</span>)</span> =&gt; x &gt; <span class="number">0</span> ? (<span class="built_in">int</span>)x : (<span class="built_in">int</span>)x - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Lerp</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b, <span class="built_in">float</span> t</span>)</span> =&gt; a + (b - a) * t;</span><br></pre></td></tr></table></figure><p><code>Lerp</code> 函数实现了线性插值，而 <code>Floor</code> 函数实现了向下取整，两个函数都为简单功能函数，它们也都在 Mathf 库中有对应实现，这里为了减少库依赖使用了自己实现的版本。</p><ul><li><code>Fade</code> 函数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Fade</span>(<span class="params"><span class="built_in">float</span> x</span>)</span> =&gt; x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><code>Fade</code> 函数的实现也十分简单，但其起到的作用却非常重要。</p><p>在我们计算得到各个晶格点与给定点的梯度值后，我们需要根据给定点的相对位置将梯度值进行插值得到最后的噪声值，而如果我们仅仅使用最简单的线性插值，得到的结果并不会很平滑，特别是在晶格的交界处；而 <code>Fade</code> 函数实际起到了函数映射的功能，其表示的函数为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn><msup><mi>x</mi><mn>5</mn></msup><mo>−</mo><mn>15</mn><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><mn>10</mn><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">f(x)=6x^5-15x^4+10x^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8974em;vertical-align:-.0833em"></span><span class="mord">6</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8974em;vertical-align:-.0833em"></span><span class="mord">15</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">10</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，其图像如下所示：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281326466.png" alt="image9" style="zoom:33%"><p>这一函数的最大特点在于其在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span>处二阶导都为0，这给予了其平滑边界过渡的功能。</p><p>这一 <code>Fade</code> 函数不仅仅可以被用于柏林噪声的实现，在其他例如值噪声、单形噪声的实现中，其也发挥着重要的作用。</p><ul><li><code>Grad</code>函数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Grad</span>(<span class="params"><span class="built_in">int</span> hash, <span class="built_in">float</span> x, <span class="built_in">float</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> h = hash &amp; <span class="number">7</span>; <span class="comment">// convert the hash to 0-7</span></span><br><span class="line">    <span class="built_in">float</span> u = h &lt; <span class="number">4</span> ? x : y;</span><br><span class="line">    <span class="built_in">float</span> v = h &lt; <span class="number">4</span> ? y : x;</span><br><span class="line">    <span class="keyword">return</span> (h &amp; <span class="number">1</span>) == <span class="number">0</span> ? u : -u + (h &amp; <span class="number">2</span>) == <span class="number">0</span> ? v : -v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Grad</code>函数实现了计算给定点的梯度值的功能；其第一眼看上去可能会令人有些困惑，在前面的原理叙述中，笔者描述的计算梯度值的方式是先给晶格点指定随机梯度向量，再使用点乘计算对应梯度值，但在这个函数中似乎既没有向量也没有点乘；实际上，这个函数确实实现了计算梯度值的功能，但在具体路径上进行了一些简化与优化。</p><p>如果我们对返回值情况进行枚举，这个函数的话其实可以将其转化为下面的这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Grad</span>(<span class="params"><span class="built_in">int</span> hash, <span class="built_in">float</span> x, <span class="built_in">float</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> h = hash &amp; <span class="number">7</span>; <span class="comment">// convert the hash to 0-7</span></span><br><span class="line">    <span class="keyword">switch</span> (h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> y - x;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> x - y;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> - x - y;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> y - x;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">return</span> x - y;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">return</span> - x - y;</span><br><span class="line">        <span class="literal">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Grad</code>函数中，<code>hash</code>即为给定的晶格点，而我们可以进行预设，使得梯度向量的两个分量的绝对值都为1，即梯度向量只能为<code>(1, 1)</code>、<code>(1, -1)</code>、<code>(-1, 1)</code>、<code>(-1, -1)</code>之一，这样便可以将向量之间的点乘转化为加减法运算，可以显著提升性能表现并简化代码。而输入的<code>x</code>、<code>y</code>则为给定点到晶格点的距离向量，如此一来，最后的梯度值便可以简化为<code>x + y</code>、<code>x - y</code>、<code>y - x</code>、<code>- x - y</code></p><ul><li><code>Noise</code>函数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetNoise</span>(<span class="params"><span class="built_in">float</span> x, <span class="built_in">float</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// the grid cell coordinates</span></span><br><span class="line">    <span class="built_in">int</span> gridX = Floor(x) &amp; <span class="number">255</span>;</span><br><span class="line">    <span class="built_in">int</span> gridY = Floor(y) &amp; <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// the relative coordinates of the point in the cell</span></span><br><span class="line">    <span class="built_in">float</span> dx = x - Floor(x);</span><br><span class="line">    <span class="built_in">float</span> dy = y - Floor(y);</span><br><span class="line">    <span class="comment">// fade the relative coordinates</span></span><br><span class="line">    <span class="built_in">float</span> u = Fade(dx);</span><br><span class="line">    <span class="built_in">float</span> v = Fade(dy);</span><br><span class="line">    <span class="comment">// hash coordinates of the 4 corners</span></span><br><span class="line">    <span class="built_in">int</span> hashA = Permutation512[gridX] + gridY;</span><br><span class="line">    <span class="built_in">int</span> hashB = Permutation512[gridX + <span class="number">1</span>] + gridY;</span><br><span class="line">    <span class="comment">// bilinear interpolation</span></span><br><span class="line">    <span class="built_in">float</span> y0 = Lerp(Grad(Permutation512[hashA], dx, dy), Grad(Permutation512[hashB], dx - <span class="number">1</span>, dy), u);</span><br><span class="line">    <span class="built_in">float</span> y1 = Lerp(Grad(Permutation512[hashA + <span class="number">1</span>], dx, dy - <span class="number">1</span>), Grad(Permutation512[hashB + <span class="number">1</span>], dx - <span class="number">1</span>, dy - <span class="number">1</span>), u);</span><br><span class="line">    <span class="keyword">return</span> Lerp(y0, y1, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于到了<code>Noise</code>函数了，这是算法的核心部分，从中可以一窥柏林算法的运算方式。</p><p>其中我们先通过<code>Floor</code>函数获取了给定坐标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mclose">)</span></span></span></span>所处晶格的哈希索引，即<code>gridX</code>与<code>gridY</code>，通过它们我们便可以确定晶格中四个点的哈希值，即<code>hashA</code>、<code>hashB</code>、<code>hashA+1</code>与<code>hashB+1</code>，进而得到其对应梯度向量。</p><p>而之后，我们获得了<code>dx</code>与<code>dy</code>，它们是<code>x</code>与<code>y</code>在晶格中的相对位置，取值范围为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，而之后的由<code>Fade</code>函数计算得到的<code>u</code>、<code>v</code>便是<code>dx</code>、<code>dy</code>的映射值。</p><p>最后便是通过<code>Grad</code>计算梯度值并使用双线性插值得到最后的噪声值。</p><p>下图可以清晰表示出这些变量的关系以及梯度值的计算方法：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281337769.png" alt="image13" style="zoom:50%"><p>以上便是关于柏林噪声具体实现的论述，接下来笔者将尝试将柏林函数应用到实际的程序化生成中。</p><h2 id="2D-Tilemap生成">2D Tilemap生成</h2><p>在理解了柏林噪声的原理，并实现了获取相应柏林噪声的算法之后；接下来，让我们将其应用到实际场景中试试吧！</p><p>笔者在Unity中实现了几个使用柏林噪声进行程序化地图生成的例子，其中包括2D Tilemap生成、3D地形生成等，以下项目与代码都可以在这个Github仓库中找到：</p><p><a target="_blank" rel="noopener" href="https://github.com/hmxsqaq/Unity-ProceduralMapGenerationPerlinNoise">https://github.com/hmxsqaq/Unity-ProceduralMapGenerationPerlinNoise</a></p><h3 id="获取噪声图">获取噪声图</h3><p>对于2D Tilemap的生成而言，柏林算法的应用非常直观，其噪声图本身便可以被描述为一张二维图像，如下所示</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281338114.png" alt="image14" style="zoom:50%"><p>我们只需要将这张二维图像转化为数据，再将数据映射到Tilemap上即可。</p><p>首先我们需要获取到所需的噪声的数据，下图所示代码实现了这一功能：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span>[,] GetNoiseMap(<span class="built_in">int</span> seed, <span class="built_in">int</span> width, <span class="built_in">int</span> height, <span class="built_in">float</span> scale)</span><br><span class="line">&#123;</span><br><span class="line">    Random.InitState(seed);</span><br><span class="line">    <span class="comment">// init map</span></span><br><span class="line">    <span class="built_in">float</span>[,] noiseMap = <span class="keyword">new</span> <span class="built_in">float</span>[width, height];</span><br><span class="line">    <span class="comment">// avoid scale = 0;</span></span><br><span class="line">    scale = scale &lt;= <span class="number">0</span> ? <span class="number">0.0001f</span> : scale;</span><br><span class="line">    <span class="comment">// get offset point</span></span><br><span class="line">    Vector2 offset = <span class="keyword">new</span> Vector2(Random.Range(<span class="number">-9999f</span>, <span class="number">9999f</span>), Random.Range(<span class="number">-9999f</span>, <span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> sampleX = x / scale + offset.x;</span><br><span class="line">            <span class="built_in">float</span> sampleY = y / scale + offset.y;</span><br><span class="line">            noiseMap[x, y] = PerlinNoise.GetNoise(sampleX, sampleY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> noiseMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们先指定了<code>seed</code>，确定了使用的随机序列；使用<code>offset</code>作为偏移量、<code>scale</code>作为缩放来获取噪声，并将获取到的噪声值写入了二维数组<code>noiseMap</code>中；下图直观展示了<code>offset</code>与<code>scale</code>的定义：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281344950.png" alt="image16" style="zoom:50%"><p>在获取噪声图的过程中，我们可以将柏林噪声函数理解为一张无限大的噪声图，而我们需要做的就是从这个坐标系中截取一个矩形（采样），而<code>offset</code>决定了我们截取（采样）的初始点，其由随机数进行指定；<code>scale</code>则决定了我们会截取原噪声图上多大的面积（实际上这并不准确，面积还由需要生成的噪声图的大小决定，<code>scale</code>最准确的描述应是“采样频率”），即我们会看到原噪声图的细致程度，<code>scale</code>越小，得到的噪声图越细致。</p><p>下面的gif图很好地呈现了<code>scale</code>对于噪声图的影响：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281345680.gif" alt="image17" style="zoom:50%"><h3 id="生成Tilemap">生成Tilemap</h3><p>在获取了噪声图之后，我们要干的事情实际上就很简单了，根据将噪声图的数据映射到Tilemap上即可。我分别使用灰度图和<a target="_blank" rel="noopener" href="https://beast-pixels.itch.io/overworld-tileset-grass-biome">网络中的素材</a>实现了这一功能（上面的gif便是由灰度图的实现，这里不再重复展示）。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281345858.png" alt="image18" style="zoom:50%"><p>可以使用<code>scale</code>与<code>waterProbability</code>两个参数修改随机出的效果。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281346036.gif" alt="image19" style="zoom:50%"><p>需要注意的是，我是用了Unity中的<code>Rule Tile</code>功能实现了瓦片的自适应。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281346726.png" alt="image20" style="zoom:50%"><h3 id="生成效果优化">生成效果优化</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281346071.png" alt="image21" style="zoom:50%"><p>如果我们仔细观察我们现在生成的地形，可以发现一些因为不太和谐的地方：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281346646.png" alt="image22"><p>如上图全出的这些地方，它们的规则瓦片并没有被正常匹配，这是因为素材并没有提供对应的瓦片，但是我们可以对噪声图进行处理来剔除掉这些无法匹配的区块。</p><p>这些区块一个很重要的特点便是延伸过长，我们只需遍历每个点，检查其四周的区块分布情况即可，代码如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EliminateSingleWater</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> hasSingleWater = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> w = <span class="number">0</span>; w &lt; width; w++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> h = <span class="number">0</span>; h &lt; height; h++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(NoiseMap[w, h] &lt; waterProbability) || !CheckAroundHavePairLand(w, h)) <span class="keyword">continue</span>;</span><br><span class="line">                NoiseMap[w, h] = <span class="number">1</span>;</span><br><span class="line">                hasSingleWater = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasSingleWater) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">CheckAroundHavePairLand</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> left = <span class="literal">false</span>, right = <span class="literal">false</span>, up = <span class="literal">false</span>, down = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) left = NoiseMap[x - <span class="number">1</span>, y] &gt; waterProbability;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; width - <span class="number">1</span>) right = NoiseMap[x + <span class="number">1</span>, y] &gt; waterProbability;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span>) up = NoiseMap[x, y - <span class="number">1</span>] &gt; waterProbability;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; height - <span class="number">1</span>) down = NoiseMap[x, y + <span class="number">1</span>] &gt; waterProbability;</span><br><span class="line">    <span class="keyword">return</span> (left &amp;&amp; right) || (up &amp;&amp; down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了循环进行一层一层的剔除，其会带来一些额外的性能开销，但是确实可以提升生成的准确性。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281348309.png" alt="image24" style="zoom:67%"><h3 id="总结">总结</h3><p>在这里的实践中，我使用了一张噪声图与Tilemap中的Rule Tile实现了生成随机2D Tilemap地图的效果，并剔除了Rule Tile无法支持的瓦片，使得最后的地图效果更好。</p><h2 id="3D类山地地形生成">3D类山地地形生成</h2><p>以上是对于柏林噪声的非常基础的应用，其虽然简单，但是可以作为一个很好的开始；而在《Minecraft》这些游戏中，对与噪声的应用往往更加复杂更加综合，它们往往会用到多种噪声算法并生成多张噪声图以应对多种不同的需要，如《Minecraft》中就使用多张分形柏林噪声生成了湿度图、温度图、群系图等多种用处不一的噪声图。</p><p>接下来，笔者将更加深入地探索柏林噪声的应用，从Texture出发，实现更加符合现实的3D山地地形的程序化生成。</p><p>下面所用到的所有代码也都可以在这个Github仓库中找到：</p><p><a target="_blank" rel="noopener" href="https://github.com/hmxsqaq/Unity-ProceduralMapGenerationPerlinNoise">https://github.com/hmxsqaq/Unity-ProceduralMapGenerationPerlinNoise</a></p><h3 id="高度图Texture与着色Texture">高度图Texture与着色Texture</h3><p>在应对3D山地地形生成时，因为由原先的2D变为了3D，着色层面上，我们需要先依据噪声图获取到对应Texture来实现对山体的着色。</p><p>我们使用的逻辑和上面的2D Tilemap生成非常相似，只是将Tilemap替换为了Texture，得到的效果如下所示。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281349669.png" alt="image25" style="zoom:33%"><p>通过更细致地配置颜色梯度，我们便可以得到更加好的地形图效果。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281350900.png" alt="image26" style="zoom:50%"><h3 id="分形柏林噪声">分形柏林噪声</h3><p>我们使用多层的颜色地图与柏林噪声尝试创造了地形图，其呈现了一定的随机梯度，但是其实际效果并不逼真，其显得有些太过于“平滑”了，缺少了许多的细节，而我们的自然界实际上并不那么平滑。分形柏林噪声可以一定程度上解决这一问题。</p><p>分形是指具有自相似性的复杂结构，即在不同尺度上看起来相似的图案。在自然界中，许多现象（如山脉、海岸线、云层等）都具有分形特征。分形柏林噪声结合了柏林噪声和分形的概念。具体来说，它通过多次叠加不同频率和振幅的柏林噪声来生成更加复杂和自然的噪声模式。这种叠加通常称为“Octaves”（倍频）。每个倍频层次的柏林噪声具有不同的频率和振幅，频率通常是前一个层次的两倍，振幅则是前一个层次的一半。通过叠加多个倍频层次，分形柏林噪声能够生成具有多尺度细节的复杂图案。</p><p>我们将在噪声图生成算法中引入一些额外参数来实现分形柏林噪声：</p><ul><li>octaves：倍频程数，决定噪声的细节层次</li><li>persistence：每个倍频程的振幅缩减因子</li><li>lacunarity：每个倍频程的频率增加因子</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281350601.png" alt="image27" style="zoom:50%"><p>我的实现如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span>[,] GetNoiseMap(<span class="built_in">int</span> seed, <span class="built_in">int</span> width, <span class="built_in">int</span> height, <span class="built_in">float</span> scale, Vector2 offset,</span><br><span class="line">                                   <span class="built_in">int</span> octaves = <span class="number">1</span>, <span class="built_in">float</span> persistance = <span class="number">1</span>, <span class="built_in">float</span> lacunarity = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Random.InitState(seed);</span><br><span class="line">    <span class="comment">// init map</span></span><br><span class="line">    <span class="built_in">float</span>[,] noiseMap = <span class="keyword">new</span> <span class="built_in">float</span>[width, height];</span><br><span class="line">    <span class="comment">// avoid scale &lt;= 0</span></span><br><span class="line">    scale = scale &lt;= <span class="number">0</span> ? <span class="number">0.0001f</span> : scale;</span><br><span class="line">    <span class="comment">// get offset point</span></span><br><span class="line">    Vector2[] octavesOffsets = <span class="keyword">new</span> Vector2[octaves];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; octaves; i++)</span><br><span class="line">        octavesOffsets[i] = <span class="keyword">new</span> Vector2(Random.Range(<span class="number">-9999f</span>, <span class="number">9999f</span>), Random.Range(<span class="number">-9999f</span>, <span class="number">9999</span>)) + offset;</span><br><span class="line">    <span class="comment">// store min and max value for normalization</span></span><br><span class="line">    <span class="built_in">float</span> minNoise = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">    <span class="built_in">float</span> maxNoise = <span class="built_in">float</span>.MinValue;</span><br><span class="line">    <span class="comment">// store half width and height for centering the noise map</span></span><br><span class="line">    <span class="built_in">float</span> halfWidth = width / <span class="number">2f</span>;</span><br><span class="line">    <span class="built_in">float</span> halfHeight = height / <span class="number">2f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> amplitude = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">float</span> frequency = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">float</span> noise = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; octaves; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">float</span> sampleX = (x - halfWidth) / scale * frequency + octavesOffsets[i].x;</span><br><span class="line">                <span class="built_in">float</span> sampleY = (y - halfHeight) / scale * frequency + octavesOffsets[i].y;</span><br><span class="line">                <span class="built_in">float</span> perlinNoise = PerlinNoise.GetNoise(sampleX, sampleY) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">                noise += perlinNoise * amplitude;</span><br><span class="line"></span><br><span class="line">                amplitude *= persistance;</span><br><span class="line">                frequency *= lacunarity;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// get min and max noise value to lerp</span></span><br><span class="line">            <span class="keyword">if</span> (noise &lt; minNoise) minNoise = noise;</span><br><span class="line">            <span class="keyword">if</span> (noise &gt; maxNoise) maxNoise = noise;</span><br><span class="line">            noiseMap[x, y] = noise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normalize the noise map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">            noiseMap[x, y] = Mathf.InverseLerp(minNoise, maxNoise, noiseMap[x, y]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> noiseMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其使用了累乘的方式对噪声图进行迭代，提供了多个可对噪声图进行调整的参数，如<code>octaves</code>、<code>persistence</code>、<code>lacunarity</code>、<code>offset</code>等；通过调整参数，可以生成各种不同特性的噪声纹理。</p><p>下面的gif展示了其效果：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281352301.gif" alt="image29" style="zoom:50%"><p>现在，在分形柏林算法加入后，地形图的生成效果有了很大的提升，其细节更加丰富，层次也更加多样：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281352481.png" alt="image30" style="zoom:50%"><p>同时，我们可以通过对参数的调整得到多种地形风格：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281353760.gif" alt="image31" style="zoom:50%"><h3 id="为地形赋予高度">为地形赋予高度</h3><p>在之前的实践中，笔者通过为plane设置Texture实现了基于噪声图的着色，而接下来，让我们为其赋予高度，使其成为真正的山地。</p><p>如下图所示，要实现这点的思路非常简单，我们之前已经得到了高度图，依据高度图设置plane的mesh即可实现地形的高度差。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281353915.png" alt="image32" style="zoom:50%"><p>如下面的代码所示，笔者依据噪声图进行了<code>mesh</code>数据的获取：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Mesh <span class="title">GenerateTerrainMesh</span>(<span class="params"><span class="built_in">float</span>[,] noiseMap, <span class="built_in">float</span> heightMultiplier, AnimationCurve heightCurve</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> width = noiseMap.GetLength(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">int</span> height = noiseMap.GetLength(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// get offset to center the mesh</span></span><br><span class="line">    <span class="built_in">float</span> topLeftX = (width - <span class="number">1</span>) / <span class="number">-2f</span>;</span><br><span class="line">    <span class="built_in">float</span> topLeftZ = (height - <span class="number">1</span>) / <span class="number">2f</span>;</span><br><span class="line"></span><br><span class="line">    MeshData meshData = <span class="keyword">new</span> MeshData(width, height);</span><br><span class="line">    <span class="built_in">int</span> vertexIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            meshData.Vertices[vertexIndex] = <span class="keyword">new</span> Vector3(topLeftX + x, heightCurve.Evaluate(noiseMap[x, y]) * heightMultiplier, topLeftZ - y);</span><br><span class="line">            meshData.UVs[vertexIndex] = <span class="keyword">new</span> Vector2(x / (<span class="built_in">float</span>)width, y / (<span class="built_in">float</span>)height);</span><br><span class="line">            <span class="keyword">if</span> (x &lt; width - <span class="number">1</span> &amp;&amp; y &lt; height - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                meshData.AddTriangle(vertexIndex, vertexIndex + width + <span class="number">1</span>, vertexIndex + width);</span><br><span class="line">                meshData.AddTriangle(vertexIndex + width + <span class="number">1</span>, vertexIndex, vertexIndex + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            vertexIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> meshData.CreateMesh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，加入了<code>heightMultiplier</code>与<code>heightCurve</code>两个参数，其分别控制高度的系数与高度的变化曲线，使得我们可以更加细致地控制生成地形的效果。</p><p>如我们可以在<code>heightCurve</code>中将0~0.4都映射为0，这样可以保证海平面不会凸起或凹陷。</p><p>得到的效果如下所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281355566.gif" alt="image34"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281355788.gif" alt="image35"></p><h2 id="其他程序化生成算法">其他程序化生成算法</h2><p>在程序化地形生成中，除了基础柏林噪声外，还有许多其他算法也被广泛应用。本文将简要介绍其中的三种：Simplex 噪声、DLA算法与侵蚀算法。</p><h3 id="Simplex-噪声">Simplex 噪声</h3><p>Simplex 噪声也是由 Ken Perlin 于2001年发明的一种改进的噪声函数，它旨在克服传统柏林噪声的一些缺点。</p><p>Simplex 噪声具有以下几个显著特点：</p><ul><li>计算效率更高：柏林噪声在计算时需要为晶格赋予随机梯度，而随着维度的上升，需要计算的随机梯度数量会呈几何级上升，这让其在高维度下的性能难以让人接受；而Simplex 噪声在高维空间中的计算复杂度则要比柏林噪声低很多，这使得它在实时应用中更具优势。</li><li>视觉效果更好：Simplex 噪声在生成的图像中没有明显的轴对齐伪影（artifact），这使得生成的地形更加自然和逼真</li><li>更好的梯度分布：Simplex 噪声的梯度分布更加均匀，这有助于生成平滑过渡的地形。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281357455.png" alt="image36"></p><p>Simplex 噪声的具体实现相对复杂，这里不做深入的研究，可以参考[这一论文](<a target="_blank" rel="noopener" href="https://muugumuugu.github.io/bOOkshelF/generative">https://muugumuugu.github.io/bOOkshelF/generative</a> art/simplexnoise.pdf)中给出的实现；但其核心思想并不复杂，是通过将输入空间划分为一系列的单形（如三角形或四面体），并在这些形状的顶点上生成随机梯度。然后，通过对这些梯度进行插值，生成最终的噪声值。</p><h3 id="DLA-算法">DLA 算法</h3><p>DLA（Diffusion Limited Aggregation，扩散限制聚集）算法是一种基于随机游走的聚集模型。它最早由 T.A. Witten 和 L.M. Sander 于1981年提出，用于模拟自然界中的聚集现象，如电沉积、晶体生长和城市扩展等。</p><p>其基本思想是从一个初始种子点开始，通过随机游走的粒子不断附着到聚集体上，从而形成复杂的分形结构。具体步骤如下：</p><ol><li>初始化：在空间中设置一个种子点，作为聚集体的起点。</li><li>粒子生成：在空间边界随机生成一个粒子。</li><li>随机游走：粒子开始进行随机游走，直到它邻近聚集体。</li><li>附着：粒子附着到聚集体上，成为聚集体的一部分。</li><li>重复：重复步骤2-4，直到形成所需的聚集体结构。</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281357052.png" alt="image37" style="zoom:33%"><p>DLA算法非常擅长生成上图这种类似树梢的结构，而如果我们根据其相对位置为其赋予高度，并加上一些模糊操作，其也能成为生成山脉走向的良好结构。</p><p>但DLA算法由于需要不断迭代，其性能很成问题，且由于算法特性无法支持GPU并行计算，这让其应用收到了一定程度的限制。</p><h3 id="水侵蚀算法">水侵蚀算法</h3><p>这是一种力图用计算机模拟自然过程的算法，在自然地形的形成的过程中，侵蚀作用是极其重要的一部分，其会对地形产生显著影响；通过模拟这些过程，可以生成具有更高细节和真实感的地形。</p><p>水侵蚀模拟了降雨和河流对地形的侵蚀和沉积过程。其基本步骤如下：</p><ol><li>降雨：在地形上随机分布降雨</li><li>水流路径：模拟水流的路径，计算每个点的水流量</li><li>侵蚀和沉积：根据水流量和地形坡度，计算每个点的侵蚀和沉积量，更新地形高度</li></ol><p>其实现可以参考<a target="_blank" rel="noopener" href="https://github.com/SebLague/Hydraulic-Erosion">这一仓库</a>。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281358473.png" alt="image38" style="zoom:33%"><p>而侵蚀算法也存在其问题，因为侵蚀算法是一种类似“后处理”的过程，我们需要先生成地形后再进行侵蚀算法的迭代，意味着这会让柏林噪声生成的地形失去其可哈希性；同时，因为其基于迭代，其也会带来庞大的性能消耗。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hmxs.games">徽墨行深</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hmxs.games/posts/12002/">https://hmxs.games/posts/12002/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hmxs.games" target="_blank">Hmxs's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/Note/">Note</a><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281303069.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/9/" title="「吹气球」游戏创作2 week1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211553628.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">「吹气球」游戏创作2 week1</div></div></a></div><div class="next-post pull-right"><a href="/posts/13001/" title="「GAMES101」学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403130823578.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「GAMES101」学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/12001/" title="「Unity-Input System」学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303300143145.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">「Unity-Input System」学习笔记</div></div></a></div><div><a href="/posts/12003/" title="「Unity-Timeline」学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202312182321194.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-18</div><div class="title">「Unity-Timeline」学习笔记</div></div></a></div><div><a href="/posts/11300/" title="「Algorithm4」读书笔记零：目录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-13</div><div class="title">「Algorithm4」读书笔记零：目录</div></div></a></div><div><a href="/posts/11302/" title="「Algorithm4」读书笔记二：排序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-08</div><div class="title">「Algorithm4」读书笔记二：排序</div></div></a></div><div><a href="/posts/11301/" title="「Algorithm4」读书笔记一：基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-13</div><div class="title">「Algorithm4」读书笔记一：基础</div></div></a></div><div><a href="/posts/11303/" title="「Algorithm4」读书笔记三：查找"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-30</div><div class="title">「Algorithm4」读书笔记三：查找</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">徽墨行深</div><div class="author-info__description">ゲームをしましょう！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hmxsqaq"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hmxsqaq" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hmxsqaq@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/11752174" target="_blank" title="BiliBili"><i class="fab fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到徽墨的博客！<br>目前中传游戏系在读<br>想要成为一名游戏开发者<br>随缘更新，请多指教！😆</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">基于柏林噪声的程序化地形生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0"><span class="toc-number">1.2.</span> <span class="toc-text">什么是柏林噪声</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">柏林噪声的算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D-Tilemap%E7%94%9F%E6%88%90"><span class="toc-number">1.3.</span> <span class="toc-text">2D Tilemap生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%99%AA%E5%A3%B0%E5%9B%BE"><span class="toc-number">1.3.1.</span> <span class="toc-text">获取噪声图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90Tilemap"><span class="toc-number">1.3.2.</span> <span class="toc-text">生成Tilemap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%95%88%E6%9E%9C%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">生成效果优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3D%E7%B1%BB%E5%B1%B1%E5%9C%B0%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90"><span class="toc-number">1.4.</span> <span class="toc-text">3D类山地地形生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E5%9B%BETexture%E4%B8%8E%E7%9D%80%E8%89%B2Texture"><span class="toc-number">1.4.1.</span> <span class="toc-text">高度图Texture与着色Texture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BD%A2%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">分形柏林噪声</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%9C%B0%E5%BD%A2%E8%B5%8B%E4%BA%88%E9%AB%98%E5%BA%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">为地形赋予高度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">其他程序化生成算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Simplex-%E5%99%AA%E5%A3%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">Simplex 噪声</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DLA-%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">DLA 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E4%BE%B5%E8%9A%80%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">水侵蚀算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/10002/" title="「CS144」Introduction to Computer Networking"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202505231835208.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="「CS144」Introduction to Computer Networking"></a><div class="content"><a class="title" href="/posts/10002/" title="「CS144」Introduction to Computer Networking">「CS144」Introduction to Computer Networking</a><time datetime="2025-05-24T08:40:37.098Z" title="更新于 2025-05-24 16:40:37">2025-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11201/" title="「The Cherno-C++」学习笔记一（1-33）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304182342702.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="「The Cherno-C++」学习笔记一（1-33）"></a><div class="content"><a class="title" href="/posts/11201/" title="「The Cherno-C++」学习笔记一（1-33）">「The Cherno-C++」学习笔记一（1-33）</a><time datetime="2025-05-24T08:38:45.246Z" title="更新于 2025-05-24 16:38:45">2025-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/30001/" title="针对《异度神剑2》的批判看法与改造意见"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281809194.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="针对《异度神剑2》的批判看法与改造意见"></a><div class="content"><a class="title" href="/posts/30001/" title="针对《异度神剑2》的批判看法与改造意见">针对《异度神剑2》的批判看法与改造意见</a><time datetime="2025-05-24T08:38:09.036Z" title="更新于 2025-05-24 16:38:09">2025-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/10/" title="「BlindTrust」游戏创作2 week3"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211628143.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="「BlindTrust」游戏创作2 week3"></a><div class="content"><a class="title" href="/posts/10/" title="「BlindTrust」游戏创作2 week3">「BlindTrust」游戏创作2 week3</a><time datetime="2025-05-24T08:38:09.036Z" title="更新于 2025-05-24 16:38:09">2025-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/13/" title="「World Piece」-GMTK GameJam 2024"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202411281437810.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="「World Piece」-GMTK GameJam 2024"></a><div class="content"><a class="title" href="/posts/13/" title="「World Piece」-GMTK GameJam 2024">「World Piece」-GMTK GameJam 2024</a><time datetime="2025-05-24T08:38:09.036Z" title="更新于 2025-05-24 16:38:09">2025-05-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 徽墨行深</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hmxs.games/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div",{class:"katex-wrap"})})</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://hmxs-twikoo.netlify.app/.netlify/functions/twikoo",region:"",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://hmxs-twikoo.netlify.app/.netlify/functions/twikoo",region:"",urls:[window.location.pathname],includeReply:!1}).then(o=>{t.textContent=o[0].count}).catch(t=>{console.error(t)})})()},o=()=>{"object"==typeof twikoo?setTimeout(t,0):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(t)};o()})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>