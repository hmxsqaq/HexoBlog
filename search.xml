<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My Game List</title>
    <url>/posts/999/</url>
    <content><![CDATA[<h1>Game List</h1>
<p><em>记录一些玩过游戏的体验，排序纯看心情，没有任何意义；之前玩的很多还没加上，之后找机会慢慢写吧~</em></p>
<h2 id="Switch">Switch</h2>
<table>
<thead>
<tr>
<th style="text-align:center">游戏名</th>
<th style="text-align:center">体验</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">塞尔达传说：旷野之息</td>
<td style="text-align:center">伟大，无需多言</td>
</tr>
<tr>
<td style="text-align:center">十三机兵防卫圈</td>
<td style="text-align:center">荣登我最爱的游戏；令人震撼的剧情编排能力，无数信息与线索抽丝成茧，无与伦比的体验；香草社无愧匠人之名</td>
</tr>
<tr>
<td style="text-align:center">火焰纹章：风花雪月</td>
<td style="text-align:center">三条线平行世界的剧情，巨大的文本工作量，令人敬佩；但部分线路赶工明显；rpg体验格外良好，真的不想放弃任何一个学生啊</td>
</tr>
<tr>
<td style="text-align:center">火焰纹章：Engage</td>
<td style="text-align:center">战旗部分做的格外出色，但剧情整体较为俗套，讲故事的方式也比较传统王道；作为卖点宣传的“前代纹章士”却几乎没在剧情上做什么设计，颇为可惜</td>
</tr>
<tr>
<td style="text-align:center">异度之刃3</td>
<td style="text-align:center">优秀的传统JRPG，一如既往优秀的地图设计，引人入胜的剧情编排，战斗系统上限极高，部分支线设计较为拖沓，游戏中期显得比较枯燥，跑图十分折磨，个人认为需要快速代步工具</td>
</tr>
<tr>
<td style="text-align:center">星之卡比wii豪华版</td>
<td style="text-align:center">卡比可爱捏~~ 经典的2D横版过关，整体难度偏低，但很有趣，适合放松</td>
</tr>
</tbody>
</table>
<h2 id="PC">PC</h2>
<table>
<thead>
<tr>
<th style="text-align:center">游戏名</th>
<th style="text-align:center">体验</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">遗迹2</td>
<td style="text-align:center">与前作相比的全面进化之作，游戏逻辑、循环与驱动力自洽，场景与美术优秀，枪械手感很棒，部分BOSS设计让人眼前一亮，美中不足的是优化有待提升，bug偏多</td>
</tr>
<tr>
<td style="text-align:center">博德之门3</td>
<td style="text-align:center">年轻人的第一款CRPG，让人拜服的伟大作品</td>
</tr>
<tr>
<td style="text-align:center">火山的女儿</td>
<td style="text-align:center">莫名上头，女儿画得非常可爱；后期流程略显枯燥冗长，对战斗系统不是很满意</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>About Me</category>
      </categories>
      <tags>
        <tag>Game List</tag>
      </tags>
  </entry>
  <entry>
    <title>针对《异度神剑2》的批判看法与改造意见</title>
    <url>/posts/10000/</url>
    <content><![CDATA[<h1>针对《异度神剑2》的批判看法与改造意见</h1>
<p>​	<code>《异度神剑2》</code>是一款发售于Switch上的任天堂第一方JRPG。作为一名对JRPG充满兴趣的玩家，久闻异度系列的大名，之前却因听闻其不太友好的上手难度与地图引导而对其望而却步。而在系列新作异度神剑3发售后，我终于下定决心入手了这部作品，开始了自己的幽界之旅。在经过了超过100小时的旅程之后，我的心中却是五味杂陈的。<code>《异度神剑2》</code>无疑是一个好游戏，其人设、演出、音乐、地图设计、战斗系统之优秀足以令我心悦诚服，但其缺点却也是无比突出，下面我将从<strong>地图与战斗系统引导</strong>、<strong>异刃与抽卡系统</strong>、<strong>场景技能与锁钥设计</strong>3个方面谈谈我对<code>《异度神剑2》</code>的批评看法与改造意见。</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281801299.jpg" alt="垃圾游戏嗼" style="zoom: 33%;" />
<h3 id="薄弱的引导系统">薄弱的引导系统</h3>
<p>​	如果要用两个字来形容<code>《异度神剑2》</code>的新手引导系统的话，对我来说便是“灾难”，这点也是劝退了无数玩家的首要原因。而其引导系统的薄弱个人认为集中体现在地图与战斗系统上。</p>
<p>​	平心而论，如果把<code>《异度神剑2》</code>的地图设计与战斗系统单独拿出来看，可以说这二者都是极其优秀的。地图方面，其有着多张规模极大、颇具设计感的地图，且每张地图都独居特色，特别是其垂直层面的设计，山峦叠嶂，楼宇交错，可以深刻感受到地图设计的巧思。但，“成也地图，败也地图”，游戏中用于指引方向的导航系统只会给玩家一个大致的方向与距离，而游戏中又存在着许多“垂直”层面的设计，玩家则需要在极其复杂曲折的地图中凭借可以说“简陋”的指针导航找到任务地点，这无疑是极其困难的，无数玩家也因为无尽的迷路离开了幽界。</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281801256.png" alt="image-20221008204505701" style="zoom:33%;" />
<p>​	而战斗系统方面，游戏的战斗系统由异刃连击，御刃者连击与连锁攻击三套紧密相连的系统组成，同时有着不下40个各不相同的异刃可供选择，在玩家理解战斗系统后，这套复杂而精妙的战斗系统会给予玩家极高的构筑与操作上限，打出令人赏心悦目的伤害与操作系统。而问题就出在了“让玩家理解战斗系统”这一过程中，游戏的战斗系统是随游戏进程逐步开放的，解锁全部的系统大约需要20-30小时的时长，而在这漫长的过程中，游戏只会在玩家第一次使用某一系统时给出相应教程，且教程无法回看。要回顾教程只能去游戏中各地区的情报商人处购买，且购买到的教程都只有聊聊几句，实际意义不大。这使得玩家上手战斗系统的门槛变得异常地高，笔者也是观看了大量教程之后才逐渐上手其战斗系统。</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281801457.png" alt="image-20221008215052113"></p>
<p>​	令人欣慰的是，上面所说的引导问题，在其续作<code>《异度神剑：决定版》</code>与<code>《异度神剑3》</code>中都有了显著改善，地图引导方面添加了一目了然的傻瓜式引导线，虽然这种方式并不高明，但也不失为一种解题思路，而战斗系统方面则添加了可随时反复观看的教程与训练场供玩家练习掌握。</p>
<h3 id="割裂的抽卡系统">割裂的抽卡系统</h3>
<p>​	从游戏名<code>《异度神剑》</code>也可以看出，各式各样的异刃是游戏极重要的组成部分，他们是主角冒险中的好伙伴、好战友，在游戏的战斗与剧情部分都占有极大的比重，而令人诧异的是游戏中过半的稀有异刃的获取方式有且只有一个------抽卡。玩家通过不断的击败精英怪获取召唤水晶，再通过召唤水晶随机抽取异刃，这一反复刷怪刷素材的过程无比枯燥无聊，而在一款注重剧情体验的JRPG中，这样的玩法笔者认为是极其割裂的，这一过程无法带来快乐也无法带来感动，带给玩家的只有无聊与烦躁。</p>
<p>​	同时，更令人想吐槽的是，这个抽卡系统的设置也是极其的不人性化。抽卡系统没有设置连抽系统，只能一个个抽取，同时抽取操作也极其繁琐，需要反复确认，抽取50发召唤水晶的时间大约需要耗费玩家半个多小时，而这半个多小时内，玩家能干的只有机械化的点击确认。</p>
<p>​	好消息是，在之后的<code>《异度神剑3》</code>中已经移除了这个系统，而笔者认为，这个系统的失败有两方面原因：一是与游戏基调的割裂；二是系统设置的不人性化。在设置类似系统时，至少应做到优化交互，减少玩家无意义的机械操作。</p>
<h3 id="场景技能与锁钥设计">场景技能与锁钥设计</h3>
<p>​	<code>《异度神剑2》</code>中同样拥有在类银河恶魔城类游戏中被大量使用的软性锁钥设计，而其锁钥是通过异刃的场景技能解锁的。不同的异刃有不同的场景技能，凑齐所需的场景技能便可解锁锁钥，这本是一个不错的设计思路，但当异刃的获取与抽卡系统高度绑定时，问题便随之出现。没抽到特定异刃便无法凑齐某些场景技能需求，许多支线任务与奖励地点就无法推进，这逼迫玩家去进行极其枯燥无聊的刷召唤水晶与抽卡。同时场景技能的使用也十分不人性化，玩家在抽卡的过程中会获取大量异刃，而能触发场景技能的只有你携带的至多9个异刃，不同异刃的切换流程极其繁琐。</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303281802700.png" alt="image-20221008234328181"></p>
<p>改造意见：优化锁钥设计的触发，使其能自动检测背包内的异刃的场景技能</p>
]]></content>
      <categories>
        <category>Comment</category>
      </categories>
      <tags>
        <tag>Games</tag>
        <tag>Comment</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode】算法练习记录</title>
    <url>/posts/102/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309090059804.png" alt="leetcode"></p>
<blockquote>
<p><strong>力扣个人主页：<a href="https://leetcode.cn/u/nervous-i3elllb6/">https://leetcode.cn/u/nervous-i3elllb6/</a></strong></p>
</blockquote>
<hr>
<h2 id="template：">template：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## date</span><br><span class="line"></span><br><span class="line">### title</span><br><span class="line"></span><br><span class="line">#### 思路</span><br><span class="line"></span><br><span class="line">#### 题解</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="230905">230905</h2>
<h3 id="2605-从两个数字数组里生成最小数字"><a href="https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/">2605. 从两个数字数组里生成最小数字</a></h3>
<h4 id="思路">思路</h4>
<ul>
<li>哈希：通过哈希表筛出两个数组的重复数与最小数</li>
</ul>
<h4 id="题解">题解</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">10</span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(nums<span class="number">1.</span>begin(), nums<span class="number">1.</span>end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(num) != hash.<span class="built_in">end</span>())</span><br><span class="line">                result = <span class="built_in">min</span>(result, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="type">int</span> num1 = *<span class="built_in">min_element</span>(nums<span class="number">1.</span><span class="built_in">begin</span>(), nums<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> num2 = *<span class="built_in">min_element</span>(nums<span class="number">2.</span><span class="built_in">begin</span>(), nums<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">        result = num1 &lt; num2 ? num1 * <span class="number">10</span> + num2 : num2 * <span class="number">10</span> + num1;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-两数之和"><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h3>
<h4 id="思路-2">思路</h4>
<ul>
<li>遍历爆搜：把所有两两组合全试一遍</li>
<li>哈希：由<code>x + y = target</code>得<code>target - x = y</code>，建立哈希表进行索引，遍历过程中，设遍历到的数为<code>x</code>，在哈希表中寻找<code>target - x</code>，如果找不到就把<code>x</code>加入哈希表</li>
</ul>
<h4 id="题解-2">题解</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历爆搜</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> iterator = hash.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iterator != hash.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; iterator-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="230906">230906</h2>
<h3 id="2-两数相加"><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h3>
<h4 id="思路-3">思路</h4>
<p>链表题</p>
<ul>
<li>迭代模拟：模拟加法的过程，遍历即可，需要注意边界检查等细节，需要采用一个<code>dummy head</code>（傀儡头指针）对链表头进行标记</li>
<li>递归：<code>sum = l1 + l2 + carry_bit</code>，使用递归进行链表的递推</li>
</ul>
<h4 id="题解-3">题解</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* tail = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> carry_bit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> add1 = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> add2 = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = add1 + add2 + carry_bit;</span><br><span class="line">            carry_bit = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, tail);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry_bit &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry_bit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">add</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span> &amp;&amp; carry == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">        ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        node-&gt;next = <span class="built_in">add</span>(l1 ? l1-&gt;next : <span class="literal">nullptr</span>, l2 ? l2-&gt;next : <span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">add</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="230908">230908</h2>
<h3 id="3-无重复字符的最长子串"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3>
<h4 id="思路-4">思路</h4>
<ul>
<li>滑动窗口：使用一左一右两个索引“指针”，创造一个“窗口”，窗口中的元素是符合要求的，使其在字符串/数组上移动，完成遍历</li>
</ul>
<h4 id="题解-4">题解</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>;left &lt; s.<span class="built_in">length</span>();left++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; s.<span class="built_in">length</span>() &amp;&amp; hash.<span class="built_in">find</span>(s[right]) == hash.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                hash.<span class="built_in">insert</span>(s[right]);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left);</span><br><span class="line">            hash.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="230909">230909</h2>
<p>看了俩题都做寄了，摆！待我学成《算法4》归来</p>
<hr>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Algorithm</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#-泛型约束】学习笔记</title>
    <url>/posts/103/</url>
    <content><![CDATA[<h1>泛型约束</h1>
<blockquote>
<p>泛型约束：对泛型类型参数施加限制，用于限制可以传递到该类型参数的类型种类，共有6种</p>
</blockquote>
<p><strong>基本语法</strong>：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">struct</span>/<span class="keyword">class</span>/<span class="title">new</span>()/&lt;<span class="title">base</span> <span class="title">class</span> <span class="title">name</span>&gt;/&lt;<span class="title">interface</span> <span class="title">name</span>&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="结构约束-where-T-struct">结构约束 <code>where T : struct</code></h2>
<p>T必须是<strong>值类型</strong>，可以指定除 Nullable 以外的任何值类型</p>
<p>（值类型有int、float、char、bool、struct、enum、byte等，值类型声明后被直接分配内存）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">struct</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyGeneric&lt;<span class="built_in">int</span>&gt; myGenericint = <span class="keyword">new</span> MyGeneric&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="类关键词约束-where-T-class">类关键词约束 <code>where T : class</code></h2>
<p>T必须是<strong>引用类型</strong>，包括任何类、接口、委托或数组类型</p>
<p>（引用类型有string和class，引用类型被声明时只在栈中分配一小片内存用于容纳一个地址，其实例被创建时，才会为其在堆中分配内存，并将堆中被分配的内存地址保存到栈中）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyGeneric&lt;<span class="built_in">string</span>&gt; myGenericstring = <span class="keyword">new</span> MyGeneric&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="接口名约束-where-T-interface-name">接口名约束 <code>where T : &lt;interface name&gt;</code></h2>
<p>T必须<strong>继承所给名称的指定接口</strong>，并实现其中的所有方法</p>
<p>可以指定多个接口约束</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;This is a test.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IMyInterface</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyGeneric&lt;A&gt; myGenericA = <span class="keyword">new</span> MyGeneric&lt;A&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="类名约束-where-T-base-class-name">类名约束 <code>where T : &lt;base class name&gt;</code></h2>
<p>T必须<strong>是该类本身或是该类的子类</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    MyGeneric&lt;A&gt; myGenericA = <span class="keyword">new</span> MyGeneric&lt;A&gt;();</span><br><span class="line">    MyGeneric&lt;B&gt; myGenericB = <span class="keyword">new</span> MyGeneric&lt;B&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="构造约束-where-T-new">构造约束 <code>where T : new()</code></h2>
<p>T必须具<strong>有无参数的公共构造函数</strong></p>
<p>当与其他约束一起使用时，new() 约束必须最后指定</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">A</span>,<span class="title">new</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    MyGeneric&lt;A&gt; myGenericA = <span class="keyword">new</span> MyGeneric&lt;A&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1>泛型约束的应用</h1>
<h2 id="例：">例：</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyBaseGeneric</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>采用了**“类名约束”**</p>
<p>根据定义：T必须是该类本身或是该类的子类，即T必须是MyBaseGeneric<T>本身或是MyBaseGeneric<T>的子类</p>
<p>故当有其他类MyGeneric想要继承MyBaseGeneric<T>时，T便只能为MyGeneric本身或其他已经继承了MyBaseGeneric<T>的类</p>
<p>写法为：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGeneric</span> : <span class="title">MyBaseGeneric</span>&lt;<span class="title">MyGeneric</span>&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这样便通过类名泛型约束限制了泛型T</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>C#</tag>
        <tag>Generic</tag>
      </tags>
  </entry>
  <entry>
    <title>【3B1B-线性代数的本质】学习笔记</title>
    <url>/posts/100/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100312370.png" alt="image-20230410031239217" style="zoom:50%;" />
<blockquote>
<p>视频地址: <a href="https://www.bilibili.com/video/BV1ys411472E">https://www.bilibili.com/video/BV1ys411472E</a></p>
</blockquote>
<hr>
<h1>线性代数的本质</h1>
<h2 id="向量是什么">向量是什么</h2>
<h3 id="向量的三种理解">向量的三种理解</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100320590.png" alt="image-20230410032014523" style="zoom: 33%;" />
<ul>
<li>物理: 向量是空间中的箭头，决定一个向量的是它的长度与所指的方向</li>
<li>计算机: 向量是有序的数字列表</li>
<li>数学: A Vector can be anything! 只要保证两个向量相加/数乘有意义即可</li>
</ul>
<h3 id="线性代数中的向量">线性代数中的向量</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100328975.png" alt="image-20230410032831917" style="zoom:33%;" />
<p>从几何直观的角度出发，线代中的向量是位于坐标系中且始终出发于原点的箭头，其坐标代表了其距离坐标轴的距离</p>
<p>(因为绝大部分情况下，向量的起点都是原点，所以有时我们也可以将向量看做坐标系中的一个点来进行理解)</p>
<h3 id="向量的基本运算">向量的基本运算</h3>
<ul>
<li>加法: 三角形法则—描述了两个向量运动的叠加</li>
<li>数乘: 对于向量的拉伸、压缩、翻转</li>
</ul>
<hr>
<h2 id="线性组合、张成空间与基向量">线性组合、张成空间与基向量</h2>
<h3 id="线性组合">线性组合</h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100335051.png" alt="image-20230410033539016"></p>
<p>两个数乘向量的和被称为这两个向量的线性组合</p>
<p>“线性”的一种理解: 在向量的组合中，如果固定其中一个标量，让另一个标量自由变化，所产生的向量的终点会描出一条直线</p>
<p>线性组合存在不同情况: 大部分情况下，v和w的线性组合可以到达二维空间中的任意点，而少部分情况下(共线/都是零向量)时，它们只能到达一条直线/原点</p>
<h3 id="张成空间-span">张成空间(span)</h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100338169.png" alt="image-20230410033843131"></p>
<p>所有可以表示为给定向量线性组合的向量的集合被称为给定向量张成的空间</p>
<h3 id="线性相关与线性无关">线性相关与线性无关</h3>
<ul>
<li>线性相关:</li>
</ul>
<p>​	当我们有多个向量，并且可以移除其中的一个而不减小张成的空间，则这些向量“线性相关”</p>
<p>​	另一种表述，其中一个向量可以表示为其它向量的线性组合</p>
<ul>
<li>线性相关:</li>
</ul>
<p>​	如果所有的向量都给张成的空间增加了新的维度，则称这些向量“线性无关”</p>
<h3 id="基向量">基向量</h3>
<p>向量空间的一组基是张成该空间的一个线性无关的向量集</p>
<hr>
<h2 id="矩阵与线性变换">矩阵与线性变换</h2>
<h3 id="线性变换">线性变换</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100357189.png" alt="image-20230410035722134" style="zoom:50%;" />
<p>“线性变换”中“变换”一词的本质便是函数，其接受输入并输出对应结果。</p>
<p>采用“变换”一词来描述，着重突出了其带有的“运动属性”，即并不是单纯的由a得b，而是由a运动到b，这对于向量有着非常好的几何直观</p>
<p>而线性代数中的变换，便是将向量空间中的所有点移动到另一个位置上</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100402034.png" alt="image-20230410040256993" style="zoom:33%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100403770.png" alt="image-20230410040341704" style="zoom:33%;" />
<p>而线性变换便是一种特殊的变换，其有着两条性质:</p>
<ul>
<li>直线在变换后仍为直线</li>
<li>原点不能移动</li>
</ul>
<p>线性变换是让网格线保持平行且等距分布的变换，并保持原点不动</p>
<p><strong>只需要记录变换前后的一组基向量，即可用其的线性组合描述空间中任意向量的对应变换</strong></p>
<h3 id="矩阵乘法的几何意义">矩阵乘法的几何意义</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304100410685.webp" alt="img" style="zoom: 67%;" />
<p>方阵的每一列都是一个基向量变换后的值，用方阵乘以(x,y)向量即可得(x,y)经过对应线性变换后的值</p>
<p>每当看到矩阵时，我们都可以把它理解为对空间的一种特定变换</p>
<hr>
<h2 id="矩阵乘法与线性变换的复合">矩阵乘法与线性变换的复合</h2>
<p>线性变换可以复合，即多次独立的线性变换可以形成一个新的线性变换，这个变换被称为“复合变换”</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130148780.png" alt="image-20230413014833701" style="zoom:50%;" />
<p>而复合变换的变换矩阵即为之前的独立线性变换矩阵的积，根据变换顺序，从右往左相乘</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130151133.png" alt="image-20230413015109095" style="zoom:50%;" />
<p>同时需要注意的是，矩阵乘法不具有交换律，反映到几何直观上，同样两次独立的线性变换，改变变换的先后顺序会使最后的复合变换改变</p>
<hr>
<h2 id="行列式">行列式</h2>
<h3 id="行列式的几何意义">行列式的几何意义</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130156166.png" alt="image-20230413015615112" style="zoom:50%;" />
<p>线性变换改变空间面积的比例，成为变换的行列式</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130157043.png" alt="image-20230413015704985" style="zoom:50%;" />
<p>当行列式为0时，这意味着这次变换将一个平面压缩到了一条线/一个点上，将空间压缩到了更小的维度上</p>
<p>这对变换来说是一个非常有用重要的性质，这意味着这次变换是“线性相关”的</p>
<h3 id="行列式的负数情况">行列式的负数情况</h3>
<p>根据行列式的几何意义，其代表空间改变的比例，但这无法解释为什么行列式存在负数</p>
<p>而这其实是由于空间的翻转导致的，有时变换会导致空间发生翻转，使得空间的定向(Orientation)发生改变，而行列式的负号表明了这点，此时行列式的绝对值仍然代表着空间的改变比例</p>
<p>三维空间的行列式的负数含义：由右手系变为左手系</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130205801.png" alt="image-20230413020509744" style="zoom:50%;" />
<hr>
<h2 id="逆矩阵、列空间与零空间">逆矩阵、列空间与零空间</h2>
<h3 id="利用线性代数求解方程组">利用线性代数求解方程组</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130208815.png" alt="image-20230413020806766" style="zoom:50%;" />
<p>线性代数的一大应用便是其可以帮助我们求解线性方程组，我们可以将线性方程组抽象为一种将未知向量变为已知向量的特定的变换，赋予了方程组几何意义</p>
<ul>
<li>当A变换行列式不为0时：</li>
</ul>
<p>这代表着变换不会缩小空间的维度，意味着我们永远可以找到满足方程组的变换，之后只需要通过逆变换回溯变换就可以求出位置向量</p>
<ul>
<li>当A变换行列式为0时：</li>
</ul>
<p>这代表着变换会将空间压缩到更低的维度上，这种情况下逆变换将不存在，如果恰好目标向量正好仍在空间中，则可以求解，否则无解</p>
<p>对空间维度的压缩意味着会有多个输入对应一个输出</p>
<h3 id="秩-Rank">秩(Rank)</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130218890.png" alt="image-20230413021856846" style="zoom:50%;" />
<p>秩意味着变换后空间的维数</p>
<p>更准确的来说: 列空间的维数被称为秩</p>
<h3 id="列空间">列空间</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130220425.png" alt="image-20230413022023369" style="zoom:50%;" />
<p>某一变换所有可能的输出向量的集合，被称为此向量的列空间</p>
<p>矩阵的列告诉你基向量变换后的位置，这些变换后的基向量张成的空间就是所有可能的变换结果</p>
<p>列空间就是矩阵的列所张成的空间</p>
<p>需要注意的是，因为线性变换规定原点不可变，故零向量一定会被包含在列空间中</p>
<h3 id="零空间">零空间</h3>
<p>一些向量在变换后会落在零向量/原点上，这些向量的集合被称为零空间</p>
<p>对于满秩的变换来说，零空间就是原点自身</p>
<p>而对于一个非满秩的变换来说，因为其对空间的压缩，会有某个面/某条线成为零空间</p>
<hr>
<h2 id="点积与对偶性">点积与对偶性</h2>
<h3 id="点积的标准解释">点积的标准解释</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130230312.png" alt="image-20230413023002271" style="zoom:50%;" />
<p>两个维数相同的向量，将对应坐标配对相乘后相加</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130231015.png" alt="image-20230413023128940" style="zoom:50%;" />
<p>几何理解: 某一向量在另一向量上的投影长度与另一向量模长的乘积</p>
<h3 id="线性代数视角中的点积">线性代数视角中的点积</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130239670.png" alt="image-20230413023939605" style="zoom:50%;" />
<p>将点积中的某一向量看做一种由<strong>二维向一维的变换</strong></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304130244388.png" alt="image-20230413024445329" style="zoom:50%;" />
<p><strong>通过对称性，可以发现这种二维向一维的变换矩阵就是这一向量的x，y坐标，这太酷了！！！！！！！！！</strong></p>
<hr>
<h2 id="叉积">叉积</h2>
<h3 id="叉积的标准解释">叉积的标准解释</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304131755993.png" alt="image-20230413175520918" style="zoom:50%;" />
<p>模长为两个向量通过平移形成的平行四边形的面积</p>
<p>方向为VW向量的相对位置</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150406598.png" alt="image-20230415040637504" style="zoom:50%;" />
<p>对于三维向量，其几何意义是依据右手系导出一个同时垂直于v、w的向量，且其模长为v、w形成的平行四边形的面积，计算公式如上</p>
<h3 id="以线性代数的眼光看待叉积">以线性代数的眼光看待叉积</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150411093.png" alt="image-20230415041158985" style="zoom: 33%;" />
<hr>
<h2 id="基变换">基变换</h2>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150430127.png" alt="image-20230415043031077" style="zoom:50%;" />
<p>发生在向量与一组数之间的任意一种转化，都被称为一个坐标系</p>
<p>而坐标系的基向量规定了这种转化，采用不同的基向量，坐标系的映射关系便会发生改变</p>
<p>而通过变换矩阵可以实现基向量的变换</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150435050.png" alt="image-20230415043533994" style="zoom:33%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150436557.png" alt="image-20230415043651504" style="zoom: 50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150439622.png" alt="image-20230415043900570" style="zoom:50%;" />
<hr>
<h2 id="特征向量与特征值">特征向量与特征值</h2>
<h3 id="定义">定义</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150443258.png" alt="image-20230415044306169" style="zoom:50%;" />
<p>特征向量：在变换中张成方向保持不变的向量</p>
<p>特征值：特征向量被拉伸/压缩比例的系数</p>
<h3 id="计算思想">计算思想</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150446401.png" alt="image-20230415044635353" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150451537.png" alt="image-20230415045155504" style="zoom:50%;" />
<h3 id="特征基">特征基</h3>
<p>以特征向量为基向量会使许多计算变得简单</p>
<hr>
<h2 id="抽象向量空间">抽象向量空间</h2>
<h3 id="线性的严格定义">线性的严格定义</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150501610.png" alt="image-20230415050157546" style="zoom:50%;" />
<p>线性让一个线性变换可以通过它对基向量的作用来完全描述，这使得矩阵向量乘法成为可能</p>
<p>(求导就是一种线性运算)</p>
<h3 id="函数与向量">函数与向量</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304150507883.png" alt="image-20230415050754810" style="zoom:50%;" />
<h3 id="向量空间">向量空间</h3>
<p>向量空间是抽象出来的无形概念，任何满足公理的东西都可以被称为向量空间，并应用向量的性质</p>
<h3 id="万物皆可向量！">万物皆可向量！</h3>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Mathematics</category>
        <category>《Essence of Linear Algebra》</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#-反射】学习笔记</title>
    <url>/posts/104/</url>
    <content><![CDATA[<h1>反射</h1>
<h2 id="前言">前言</h2>
<p>反射（Reflection）是C#中的一种强大特性，其在Unity与游戏开发中被运用于诸多方面，而我之前对其早有耳闻，但一直是一知半解、望而生畏，关于什么是反射，以及反射的具体作用一直没有一个清晰的认知。</p>
<p>而本文是我较为系统的学习反射的一些笔记，希望对你有帮助😆</p>
<hr>
<h2 id="C-中的内存布局：类与类的实例化">C#中的内存布局：类与类的实例化</h2>
<p>类是C#中最为重要的概念之一，Unity的每个脚本都是一个类，编写C#代码时，几乎无时无刻都在和类打交道。</p>
<p>而关于类的本质，其可以被称为一种**“对类型的描述”或是“字段与方法的集合”**，类本身只是一种描述、一种声明，其说明了这个类型由那些数据和方法组成，仅此而已，其并不指向任何一片具体的内存。</p>
<p>而“类的实例化”过程则承担了将具体的内存与相关联的任务，所谓“实例化”便是根据类的声明为具体的实例分配内存空间的过程；对于普通的类，我们需要通过new方法对其进行实例化；而在Unity中，Unity会自动帮我们实例化挂载在<code>GameObject</code>上并继承了<code>Monobehavior</code>的类。</p>
<p>在我们实例化一个类时，一块具体的内存会被分配给类的数据成员，而类的成员函数则属于代码指令，会被共同编译成为指令集，存入代码段，所有这一类的实例全局共用一份。</p>
<hr>
<h2 id="反射的原理：类的忒休斯之船">反射的原理：类的忒休斯之船</h2>
<h3 id="类的描述与解构">类的描述与解构</h3>
<p>在Unity中，往往存在着这样一种场景，我们将一个脚本“<code>GameManager</code>”挂载在了“<code>Game</code>”物体上，并在Inspector界面中将<code>GameManager</code>中的<code>int</code>类型的变量<code>a</code>的值改为了1，之后我们关闭了Unity工程，在重新打开该工程时，我们可以发现<code>GameManager</code>仍然在<code>Game</code>上，且变量a仍然是1。</p>
<p>上述场景看起来稀松平常，但若细究其中的原理便会发现其不寻常。</p>
<p>“挂载脚本“实际上是一个“实例化”的过程，当我们把一个脚本挂载到游戏物体上的时候，实际发生的过程是通过脚本中的类实例化了一个对象挂载到游戏物体上，而当项目被关闭，其实例自然也会被销毁，而数据会以字符串的形式被保存在<code>scene</code>文件中，当我们再次打开项目时，如果要实现上述场景，那么Unity便需要根据上次保存的字符串动态的为我们的脚本进行实例化，这并不容易。在正常场景中，若要根据字符串进行实例化，那么代码往往会变成下面这样：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;GameManager&quot;</span>)&#123;</span><br><span class="line">    Game.AddComponent&lt;GameManager&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (...)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (...)</span><br></pre></td></tr></table></figure>
<p>如果用这种方式实现上述场景，便意味着每次用户更改脚本，引擎底层都需要进行更改与重新编译，这将是极其灾难性的</p>
<p>而问题的实质便是：<strong>每个类都有自己独立的描述，每个类都是不同的类型，而我们无法通过统一的方式来处理不同的描述、不同的类型</strong></p>
<p>若我们能找到一种统一的方式来描述任意的类，那么这一问题便可以迎刃而解，这便是“反射”的核心，我将其称之为<strong>类的忒休斯之船</strong></p>
<p>任一类都可以转化为这样一种描述：</p>
<ul>
<li>类实例的内存大小：类的实例便是一块内存空间，我们在编译时可以获得其大小</li>
<li>数据成员信息：通过数组或其他方式，我们可以将类的数据成员的名字、类型、地址偏移等信息保存起来</li>
</ul>
<p>如：<code>&#123;“name”,type string,1&#125;,&#123;“damage”,type int,2&#125;</code></p>
<ul>
<li>成员函数信息：通过数组或其他方式，我们可以将类中的方法的名字、类型、地址等信息保存起来</li>
</ul>
<p>如：<code>&#123;“add”,type func,0xaa&#125;</code></p>
<p>通过这种描述，我们可以用其来表达任意不同的类型，也就是表达任意不同的类，这样统一的处理不同类便成为了可能。</p>
<h3 id="类的重新实例化-Type类的引入">类的重新实例化-Type类的引入</h3>
<p>而在C#中我们会通过<code>System</code>命名空间下的<code>Type</code>类型来对具体类的信息进行存储，需要进行实例化时根据<code>Type</code>实例中的数据对具体类进行实例化。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">FiledData</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">int</span> type;</span><br><span class="line">    <span class="built_in">int</span> offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MethodData</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">int</span> type;</span><br><span class="line">    <span class="built_in">int</span> offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Type</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> size;</span><br><span class="line">    List&lt;FiledData&gt; datas;</span><br><span class="line">    List&lt;MethodData&gt; funcs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上描述了<code>Type</code>类大致的组织方式，其中存储了具体类的各个信息，通过这些信息我们便可以完整的描述一个类</p>
<p>根据<code>Type</code>类中的数据，引擎的底层便可以通过调用OS等API，动态的分配内存，构建不同的类型</p>
<p>以下是通过<code>Type</code>类构建对象的流程：</p>
<ol>
<li>
<p>编译某个类时，可以为该类生成一个<code>Type</code>类型的全局数据，其中存放了该类的描述数据</p>
<p>我们可以通过<code>System.Type.GetType(“类名”)/typeof(T)</code>等API，根据类型/类名获取类的描述对象实例（即Type数据）</p>
</li>
<li>
<p><code>Type</code>类型中，系统已经封装好了描述一个类需要的信息，包含：<code>FieldsInfos</code>（数据成员信息）、<code>MethodInfos</code>（成员方法信息）等</p>
</li>
<li>
<p>通过反射API（<code>Activator.CreateInstance</code>），便可以根据<code>Type</code>数据构建对象</p>
</li>
<li>
<p>在Type中可以说拥有类的一切数据，我们不仅可以构建类，同时也能更改、调用它们</p>
</li>
</ol>
<hr>
<h2 id="反射的应用：以Unity中的反射为例">反射的应用：以Unity中的反射为例</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类，通过反射对Data类进行操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Data</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        <span class="keyword">this</span>.Value = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Value:&quot;</span> + Value);</span><br><span class="line">        Debug.Log(<span class="string">&quot;Name:&quot;</span> + Name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构建Data类的Type对象</span></span><br><span class="line">        Type type = Type.GetType(<span class="string">&quot;Data&quot;</span>);</span><br><span class="line">        ShowConstructor(type);</span><br><span class="line">        ShowPublicMethod(type);</span><br><span class="line">        CreateObjectByConstructor(type);</span><br><span class="line">        CreateObjectByActivator(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取构造函数的所有参数与类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowConstructor</span>(<span class="params">Type type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过Type获取Data类中所有构造函数的信息</span></span><br><span class="line">        ConstructorInfo[] constructorInfos = type.GetConstructors();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> constructorInfo <span class="keyword">in</span> constructorInfos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取每个构造函数的所有参数</span></span><br><span class="line">            ParameterInfo[] parameterInfos = constructorInfo.GetParameters();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> parameterInfo <span class="keyword">in</span> parameterInfos)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">$&quot;类型:<span class="subst">&#123;parameterInfo.ParameterType&#125;</span>, 变量名:<span class="subst">&#123;parameterInfo.Name&#125;</span>;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取类中的公开方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowPublicMethod</span>(<span class="params">Type type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MethodInfo[] methodInfos = type.GetMethods();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> methodInfo <span class="keyword">in</span> methodInfos)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;方法:<span class="subst">&#123;methodInfo&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过反射用构造函数动态生成对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateObjectByConstructor</span>(<span class="params">Type type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ConstructorInfo constructorInfo = type.GetConstructor(<span class="keyword">new</span> []&#123;<span class="keyword">typeof</span>(<span class="built_in">string</span>),<span class="keyword">typeof</span>(<span class="built_in">int</span>)&#125;);</span><br><span class="line">        <span class="built_in">object</span>[] parameters = &#123; <span class="string">&quot;Hmxs&quot;</span>, <span class="number">100</span> &#125;;</span><br><span class="line">        <span class="built_in">object</span> obj = constructorInfo!.Invoke(parameters);</span><br><span class="line">        ((Data)obj).Show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过反射用Activator静态生成对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateObjectByActivator</span>(<span class="params">Type type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">object</span>[] parameters = &#123; <span class="string">&quot;Hmxs2&quot;</span>, <span class="number">200</span> &#125;;</span><br><span class="line">        <span class="built_in">object</span> obj = Activator.CreateInstance(type, parameters);</span><br><span class="line">        ((Data)obj).Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，通过C#提供的反射API对Data类进行了读取、构建</p>
<blockquote>
<p>总的来说，反射由于API贼长，且较为繁杂，给人以非常复杂的第一印象，但实际上，反射并不难以理解</p>
</blockquote>
]]></content>
      <categories>
        <category>Notes</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>C#</tag>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>《Cyberpsychosis》-AI Game Jam 2022</title>
    <url>/posts/3/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261558559.png" alt="qN0WZOY3ZLuswAaY2CB4RM3NRHPgpBfQE9G2VaSz"></p>
<h1>Cyberpsychosis</h1>
<blockquote>
<p><strong>游戏页面</strong>：<a href="https://gmhub.com/game/2005">https://gmhub.com/game/2005</a></p>
<p><strong>介绍视频</strong>：<a href="https://www.bilibili.com/video/BV1U44y1Z7oU/">https://www.bilibili.com/video/BV1U44y1Z7oU/</a></p>
</blockquote>
<p>我在本次项目中担任程序，使用Unity引擎负责了部分代码的编写</p>
<h2 id="小组成员">小组成员</h2>
<p><strong>定福庄AI小队：</strong></p>
<ul>
<li>
<p>策划：虚虚、TenGo</p>
</li>
<li>
<p>程序：紫地丁、<strong>徽墨行深(伍泽华)</strong></p>
</li>
<li>
<p>美术：范静云</p>
</li>
</ul>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261601861.jpg" alt="tjM0fNlKlAXcGfzvM1iy4WCGjKLP7xijILJWeR2j"></p>
<h2 id="游戏简介">游戏简介</h2>
<p>一款联合移动的推箱子游戏，由5名中国传媒大学的大一学生共同完成。</p>
<p>本次Game Jam的主题是「和谐的缝合怪」，我们的创作思路是在一个经典简洁的游戏机制上，做一些小的调整和创新。游戏故事背景设定参照了「赛博朋克」，其中的人类进行进行大量机械植入又要保证人性不丧失，避免「赛博精神病」，我们想这种人性与机械的平衡正符合本次大赛的主题，因而游戏名也取作「Cyberpsychosis」。</p>
<p>游戏女主因车祸而需要进行机械移植治疗，手术后检测报告显示她很大概率会因免疫排斥而出现双向情感障碍，而她不富裕的家境无法承担高额的免疫抑制剂费用。在医生的建议下，她通过控制虚拟游戏中分裂的两个自我（狂躁和抑郁），去协作完成游戏目标，来达到训练自我达到平衡的效果。</p>
<p>游戏内背景、人物立绘、BGM都是由AI进行创作。（策划和美术都被AI驯服了）</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261601694.png" alt="6dAGl1r5fzLbMt6RppK7lLODYiCtMPYapnhXBoud"></p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2022</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity-Input System】学习笔记</title>
    <url>/posts/105/</url>
    <content><![CDATA[<h1>Input System：浅尝Unity新输入系统</h1>
<blockquote>
<p>官方文档：<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/index.html">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/index.html</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>Input System是Unity新推出的输入控制系统（好像也不是很新了），我之前对其的使用只能说是一知半解，本文是我根据网上的一些资料与官方文档对Input System的使用方法的学习笔记，希望对你有帮助。😉</p>
<hr>
<h2 id="Input-System的导入">Input System的导入</h2>
<p>于Unity自带的<code>Windows-&gt;Package Manager</code>安装即可，安装后需要重启项目</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303291955069.png" alt="image-20230329195514972" style="zoom:67%;" />
<p>之后将<code>Project Settings-&gt;Player-&gt;Others-&gt;Configuration-&gt;Active Input Handling</code></p>
<p>设置为<code>Both/Input System Package(New)</code>以启用Input System</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303291959502.png" alt="image-20230329195944467" style="zoom:67%;" />
<hr>
<h2 id="Action概述">Action概述</h2>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303292017544.png" alt="image-20230329201723515" style="zoom:67%;" />
<p><strong>Action</strong>可以说是Input System中最重要的新引入的概念之一</p>
<p>Input System通过Action对用户的输入方式进行了映射，即一个Action可以关联多个输入，而原先的Input系统不同的是，与具体逻辑关联的也是Action，而非用户的具体输入</p>
<p>相当于Action成为了输入与逻辑之间的中间商，用户输入-&gt;Action-&gt;具体逻辑</p>
<p>Input System通过Action系统实现了输入与逻辑的分离，使得对于用户输入的管理与多端设备兼容更加容易</p>
<p>如我们可以将多个不同设备的移动输入绑定到同一个Action上，这样无论我们在手柄上移动摇杆，还是按下键盘的WASD，Action都会为我们返回统一的返回值，我们在编写移动逻辑时，便只需要关心Action的返回值即可，而无需分平台分设备地单独编写逻辑</p>
<hr>
<h2 id="Action的创建">Action的创建</h2>
<p>在Input System中存在着多种创建Action的方式，以下介绍通过序列化单独创建，与通过ActionMap统一创建管理两个方式：</p>
<ol>
<li><strong>通过序列化创建单一Action</strong></li>
</ol>
<p>可以通过在继承了<code>Monobehavior</code>的脚本中声明<code>InputAction</code>类型的变量(需要引入<code>UnityEngine.InputSystem</code>命名空间)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> InputAction moveAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挂载脚本后便可以在Inspector界面看到声明的<code>moveAction</code></p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303292039605.png" alt="image-20230329203921581"></p>
<p>点击齿轮符号便可对<code>moveAction</code>进行编辑，设置Action的属性</p>
<p>点击加减号可以为Action添加/删除按键绑定，为Action绑定对应按键后，按下按键便可触发与Action相关联的方法</p>
<ol start="2">
<li><strong>通过ActionMap文件统一创建Action</strong></li>
</ol>
<p>成功安装Input System包之后，于Assets界面<code>右键-&gt;Create-&gt;Input Actions</code>便可创建Input Actions Asset文件</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303292046474.png" alt="image-20230329204610432" style="zoom: 50%;" />
<p>双击创建出的InputActions即可于专门的界面中统一创建管理Actions</p>
<p>其中ActionMaps可以理解为Action的集合，我们可以创建多个Map进行随时切换，如UI和Game</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303292049942.png" alt="image-20230329204920905" style="zoom: 50%;" />
<hr>
<h2 id="Action的属性">Action的属性</h2>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303292052522.png" alt=""></p>
<p>一个Action有着多种属性，其影响着Action的触发方式、返回值等信息</p>
<h3 id="Types">Types</h3>
<p>Action共有三种默认的Type，<strong>其影响的是Action对于输入值的响应规则</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Button</th>
<th style="text-align:center">Pass Through</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">phase.started</td>
<td style="text-align:center">返回值从初始状态被改变时</td>
<td style="text-align:center">按钮开始被按下，但尚未超过阈值</td>
<td style="text-align:center">第一个控制器的返回值从初始状态被改变时</td>
</tr>
<tr>
<td style="text-align:center">phase.performed</td>
<td style="text-align:center">返回值改变时</td>
<td style="text-align:center">按钮被按下超过阈值时</td>
<td style="text-align:center">返回值改变时</td>
</tr>
<tr>
<td style="text-align:center">phase.canceled</td>
<td style="text-align:center">返回值不再改变时</td>
<td style="text-align:center">按钮被释放</td>
<td style="text-align:center">返回值不再改变时</td>
</tr>
</tbody>
</table>
<p>Pass Through与Value基本一致，区别是Value只会响应一个最活跃的输入，而Pass Through会响应所有绑定了这一Action的按键的输入</p>
<h3 id="Interactions">Interactions</h3>
<p>Action共有6种Interactions，<strong>其影响的是Action对于输入行为的响应规则</strong></p>
<p>当不设置时会设定为Default，响应与Types相同，其余Interactions理解并不困难，可见官方文档:</p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/Interactions.html#predefined-interactions">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/Interactions.html#predefined-interactions</a></p>
<hr>
<h2 id="Action与方法的绑定">Action与方法的绑定</h2>
<p>创建Actions后，便可以将Actions与具体的方法进行绑定，同时也存在着有多种方式来进行</p>
<p><strong>主要可以分为两个步骤：</strong></p>
<ol>
<li><strong>Action的获取</strong></li>
<li><strong>方法的触发</strong></li>
</ol>
<p>我们有多种方法可以进行以上两步，以下是两个例子：</p>
<h3 id="通过Player-Input组件进行绑定">通过Player Input组件进行绑定</h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303300101984.png" alt=""></p>
<p>在导入Input System包导入后，我们可以为GmaeObject添加Player Input组件对ActionMap进行管理</p>
<p><strong>Action的获取</strong>：将我们的InputActionAsset拖入组件中Actions之后，PlayerInput组件便会自动获取其中的Action</p>
<p><strong>方法的触发</strong>：PlayerInput组件为我们提供了4种方式触发方法，如上图所示，在Behavior属性中可以进行选择</p>
<ul>
<li>Send Messages：通过Unity本身的消息机制触发方法，只要在对应GameObject挂载的脚本中编写名为OnT（T为对应Action的名字，在选择Send Messages方法后会在下方显示应该编写的方法名）的方法即可，这种方法应用方便，但是Unity的消息利用的是反射机制，效率较差</li>
</ul>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305231927303.png" alt="image-20230523192728237"></p>
<ul>
<li>Broadcast Messages：通过Unity的消息广播触发方法，本质与Send Messages并不不同，区别是可以将消息广播到子物体，但效率更差了</li>
<li>Invoke Unity Events：利用UnityEvents触发方法，与Button等利用UnityEvents的方法一样，在Inspector中对应Action的EventsList中添加事件即可，缺点是需要拖来拖出，非常繁琐，在需要处理大量事件时操作麻烦</li>
<li>Invoke C Sharp Events：利用C#的Events在脚本中手动注册回调，触发方法，效率较高，利用C#的Events写起来也会比较优雅，需要在脚本中先获取PlayerInput组件，通过其中的onActionTriggered触发事件，缺点是只有onActionTriggered一个事件，若有多个Action需要进行单独判断</li>
</ul>
<p><em>在使用PlayerInput时，其实我们并不一定要采取其提供给我们的四种方法进行操作，我们可以直接在脚本中获取PlayerInput组件的实例，直接在实例中获取特定Action，后通过Action直接进行方法的绑定，这种使用方法与下面要说的利用InputActionAssets生成C#类类似，故不再赘述</em></p>
<h3 id="通过ActionMap生成C-类进行绑定">通过ActionMap生成C#类进行绑定</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305232310377.png" style="zoom: 50%;" />
<p>在创建完成InputActionAsset后，点击创建的文件，在Inspector界面中便可以看到Generate C# Class选项，勾选该选项，点击Apply便可以生成与InputActionAsset文件同名的C#类，这个类中包含了InputActionAsset中的所有数据</p>
<p>之后我们便可以直接在脚本中通过new对刚刚生成的C#类进行实例化，调用其中的数据与回调函数、</p>
<p><em>记得一定要先Enable，不然不会起作用</em></p>
<p>测试代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// IS_Test 为InputActionAsset与生成的C#类的名字</span></span><br><span class="line">    <span class="keyword">private</span> IS_Test _inputAction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        _inputAction = <span class="keyword">new</span> IS_Test();</span><br><span class="line">        <span class="comment">// 注册回调</span></span><br><span class="line">        _inputAction.Games.Move.performed += OnMove;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _inputAction.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _inputAction.Disable();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回调函数，注意*回调函数的参数必须为InputAction.CallbackContext</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMove</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(obj.ReadValue&lt;Vector2&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="基于Input-System的InputManager的实现">基于Input System的InputManager的实现</h2>
<p>在上文中，我梳理了一遍Input System的使用方法，而现在让我们实现一个基于Input System的输入管理器模块吧！</p>
<p><em>摆了！以后再写</em></p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Unity</tag>
        <tag>Input System</tag>
      </tags>
  </entry>
  <entry>
    <title>【GAMES101】学习笔记</title>
    <url>/posts/101/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403130823578.jpeg" alt="img"></p>
<h1>Lecture 01 Overview of Computer Graphics</h1>
<blockquote>
<p><strong>Computer Graphics is AWESOME</strong></p>
</blockquote>
<p>课程主题 Course Topics：</p>
<ul>
<li>光栅化 Rasterization</li>
<li>曲线与曲面 Curves and Meshes</li>
<li>光线追踪 Ray Tracing</li>
<li>动画与模拟 Animation / Simulation</li>
</ul>
<h2 id="光栅化-Rasterization">光栅化 Rasterization</h2>
<p>把三维空间的几何形体显示在屏幕上</p>
<p>实时渲染：&gt;30FPS 每秒生成30张以上的图片；否则为离线渲染</p>
<h2 id="曲线与曲面-Curves-and-Meshes">曲线与曲面 Curves and Meshes</h2>
<p>如何表现曲线与曲面</p>
<h2 id="光线追踪-Ray-Tracing">光线追踪 Ray Tracing</h2>
<p>从相机中发射光线穿过每个像素来获取极尽真实的画面效果</p>
<h2 id="动画与模拟-Animation-Simulation">动画与模拟 Animation / Simulation</h2>
<p>布料模拟、弹性模拟等物理模拟</p>
<h2 id="GAMES101是什么">GAMES101是什么</h2>
<blockquote>
<p>We learn Graphics, not Graphics API</p>
</blockquote>
<p>不教OpenGL / DirectX / Vulkan</p>
<h1>Lecture 02 Review of Linear Algebra</h1>
<h2 id="点积-Dot-Product">点积 Dot Product</h2>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>a</mi><mo>⃗</mo></mover><mo>⋅</mo><mover accent="true"><mi>b</mi><mo>⃗</mo></mover><mo>=</mo><mi mathvariant="normal">∣</mi><mover accent="true"><mi>a</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>b</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mspace linebreak="newline"></mspace><mover accent="true"><mi>a</mi><mo>⃗</mo></mover><mo>⋅</mo><mover accent="true"><mi>b</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><msub><mi>x</mi><mi>a</mi></msub><msub><mi>y</mi><mi>a</mi></msub></mfrac><mo fence="true">)</mo></mrow><mo>⋅</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><msub><mi>x</mi><mi>b</mi></msub><msub><mi>y</mi><mi>b</mi></msub></mfrac><mo fence="true">)</mo></mrow><mo>=</mo><msub><mi>x</mi><mi>a</mi></msub><msub><mi>x</mi><mi>a</mi></msub><mo>+</mo><msub><mi>y</mi><mi>a</mi></msub><msub><mi>y</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}| \cos \theta
\newline 
\vec{a}\cdot\vec{b}=\binom{x_a}{y_a}\cdot\binom{x_b}{y_b}=x_ax_a+y_ay_b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2274em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord">∣∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>找到两个向量之间的夹角：由点积除以两个向量的模即可得到向量夹角的余弦值</li>
<li>找到向量的投影：由一个向量的模乘以夹角余弦值即可得到投影的长度，从而可以进行向量的分解</li>
<li>得到向量是否接近</li>
<li>得到向量的方向性</li>
</ul>
<h2 id="叉积-Cross-Product">叉积 Cross Product</h2>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mover accent="true"><mi>a</mi><mo>⃗</mo></mover><mo>×</mo><mover accent="true"><mi>b</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mover accent="true"><mi>a</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mover accent="true"><mi>b</mi><mo>⃗</mo></mover><mi mathvariant="normal">∣</mi><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mspace linebreak="newline"></mspace><mover accent="true"><mi>a</mi><mo>⃗</mo></mover><mo>×</mo><mover accent="true"><mi>b</mi><mo>⃗</mo></mover><mo>=</mo><mo>−</mo><mover accent="true"><mi>b</mi><mo>⃗</mo></mover><mo>×</mo><mover accent="true"><mi>a</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">|\vec{a} \times \vec{b}| = |\vec{a}||\vec{b}|\sin \theta
\newline
\vec{a} \times  \vec{b} = -\vec{b} \times \vec{a}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2274em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2274em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord">∣∣</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.7973em;vertical-align:-0.0833em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0608em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>判断向量的左右</li>
<li>判断向量的内外</li>
</ul>
<p>给定一个点P，要求判断其是否在三角形ABC内部</p>
<p>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow><mo stretchy="true">→</mo></mover><mo>×</mo><mover accent="true"><mrow><mi>A</mi><mi>P</mi></mrow><mo stretchy="true">→</mo></mover><mtext>、</mtext><mover accent="true"><mrow><mi>B</mi><mi>C</mi></mrow><mo stretchy="true">→</mo></mover><mo>×</mo><mover accent="true"><mrow><mi>B</mi><mi>P</mi></mrow><mo stretchy="true">→</mo></mover><mtext>、</mtext><mover accent="true"><mrow><mi>C</mi><mi>A</mi></mrow><mo stretchy="true">→</mo></mover><mo>×</mo><mover accent="true"><mrow><mi>C</mi><mi>P</mi></mrow><mo stretchy="true">→</mo></mover></mrow><annotation encoding="application/x-tex">\overrightarrow{AB} \times \overrightarrow{AP}、\overrightarrow{BC} \times \overrightarrow{BP}、\overrightarrow{CA} \times \overrightarrow{CP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887em;vertical-align:-0.0833em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2053em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span class="svg-align" style="top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2887em;vertical-align:-0.0833em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2053em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span><span class="svg-align" style="top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2053em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span></span></span><span class="svg-align" style="top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2887em;vertical-align:-0.0833em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2053em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">BP</span></span></span><span class="svg-align" style="top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2053em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">A</span></span></span><span class="svg-align" style="top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2053em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2053em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span></span></span><span class="svg-align" style="top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span></span></span></span></span></span></span>​三个叉乘所得的符号相同，则P在ABC内部</p>
<ul>
<li>建立正交坐标系</li>
</ul>
<h2 id="矩阵-Matrices">矩阵 Matrices</h2>
<p>矩阵乘法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>M</mi><mo>×</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>N</mi><mo>×</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mo>×</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(M\times N)(N\times P)=(M\times P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span>才能乘​</p>
<p><strong>没有交换律 Non-commutative</strong></p>
<h1>Lecture 03 Transformation</h1>
<h2 id="二维变换">二维变换</h2>
<ul>
<li>缩放矩阵 Scale Matrix</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403092146666.png" alt="image-20240309214631581" style="zoom:50%;" />
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>s</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>s</mi><mi>y</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
 x&#x27; \\
 y&#x27;
\end{bmatrix}
=
\begin{bmatrix}
s_{x} &amp; 0 \\
0 &amp; s_{y}
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<ul>
<li>反射矩阵 Reflection Matrix</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403092147432.png" alt="image-20240309214700369" style="zoom:50%;" />
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
 x&#x27; \\
 y&#x27;
\end{bmatrix}
=
\begin{bmatrix}
-1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<ul>
<li>错切矩阵 Shear Matrix</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403092147093.png" alt="image-20240309214715015" style="zoom:50%;" />
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
 x&#x27; \\
 y&#x27;
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; a \\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<ul>
<li>旋转矩阵 Rotation Matrix</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403092148427.png" alt="image-20240309214808366" style="zoom:50%;" />
<p>默认逆时针沿原点旋转</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
 x&#x27; \\
 y&#x27;
\end{bmatrix}
=
\begin{bmatrix}
\cos\theta &amp; -\sin\theta \\
\sin\theta &amp; \cos\theta
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<blockquote>
<p>线性变换：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>M</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x&#x27;=Mx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">x</span></span></span></span></p>
</blockquote>
<h2 id="齐次坐标-Homogeneous-Coordinate">齐次坐标 Homogeneous Coordinate</h2>
<h3 id="为什么我们需要齐次坐标">为什么我们需要齐次坐标</h3>
<p>平移变换不能用矩阵变换的形式表示出来</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>x</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>y</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
 x&#x27; \\
 y&#x27;
\end{bmatrix}
=
\begin{bmatrix}
a &amp; b \\
c &amp; d
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
+
\begin{bmatrix}
t_{x} \\
t_{y}
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<p>这并不是一个线性变换</p>
<p>但是我们不希望让平移变换变成一个特殊情况</p>
<blockquote>
<p>齐次坐标的引入可以表示这点</p>
</blockquote>
<h3 id="解决方法：齐次坐标">解决方法：齐次坐标</h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>w</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>x</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>y</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>+</mo><msub><mi>t</mi><mi>x</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>+</mo><msub><mi>t</mi><mi>y</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
 x&#x27; \\
 y&#x27; \\
 w&#x27;
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0 &amp; t_{x} \\
0 &amp; 1 &amp; t_{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
=
\begin{bmatrix}
x + t_{x} \\
y + t_{y} \\
1
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>通过增加一个维度可以将平移也写成矩阵相乘的形式</p>
<ul>
<li>2D point = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(x,y,1)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></li>
<li>2D vector = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mn>0</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(x,y,0)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<h3 id="仿射变换-Affine-Transformations">仿射变换 Affine Transformations</h3>
<blockquote>
<p>仿射变换是指在几何中，一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间</p>
</blockquote>
<p>仿射变换可以通过齐次坐标的形式转换为一次线性变换</p>
<h2 id="变换的组合-Composing-Transforms">变换的组合 Composing Transforms</h2>
<ul>
<li>复杂的变换可以由多个简单的变换组合而成</li>
<li>变换的顺序很重要</li>
</ul>
<h2 id="变换的分解-Decomposing-Complex-Transforms">变换的分解 Decomposing Complex Transforms</h2>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403092217260.png" alt="image-20240309221700197" style="zoom:50%;" />
<h2 id="三维变换">三维变换</h2>
<ul>
<li>3D point = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(x,y,z,1)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></li>
<li>3D vector = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mn>0</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(x,y,z,0)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>仿射变换先变换再平移</p>
<p>旋转矩阵是正交矩阵，即其转置矩阵是其逆矩阵</p>
<h1>Lecture 04 Transformation Cont.</h1>
<h2 id="三维变换-3D-Transformation">三维变换 3D Transformation</h2>
<ul>
<li>Scale</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>z</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>s</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>s</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>s</mi><mi>z</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">S(s_{x},s_{y},s_{z}) =
\begin{bmatrix}
s_{x} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; s_{y} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; s_{z} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>Translation</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>z</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>x</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>y</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>z</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">T(t_{x},t_{y},t_{z}) =
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; t_{x} \\
0 &amp; 1 &amp; 0 &amp; t_{y} \\
0 &amp; 0 &amp; 1 &amp; t_{z} \\
0 &amp; 0 &amp; 0 &amp; 1 
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>Rotate</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>R</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><msub><mi>R</mi><mi>y</mi></msub><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><msub><mi>R</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><msub><mi>R</mi><mrow><mi>x</mi><mi>y</mi><mi>z</mi></mrow></msub><mo stretchy="false">(</mo><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo separator="true">,</mo><mi>γ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>R</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><msub><mi>R</mi><mi>y</mi></msub><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><msub><mi>R</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_{x}(\alpha) =
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos\alpha &amp; -\sin\alpha &amp; 0 \\
0 &amp; \sin\alpha &amp; \cos\alpha &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 
\end{bmatrix}
\newline
R_{y}(\alpha) =
\begin{bmatrix}
\cos\alpha &amp; 0 &amp; \sin\alpha &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
-\sin\alpha &amp; 0 &amp; \cos\alpha &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 
\end{bmatrix}
\newline
R_{z}(\alpha) =
\begin{bmatrix}
\cos\alpha &amp; -\sin\alpha &amp; 0 &amp; 0 \\
\sin\alpha &amp; \cos\alpha &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 
\end{bmatrix}
\newline
R_{xyz}(\alpha,\beta,\gamma)=R_{x}(\alpha)R_{y}(\beta)R_{z}(\gamma)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">yz</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span></span></span></span></span></p>
<p>上面的变换形式被称为欧拉角</p>
<p>其常被用于飞行模拟中：滚转roll, 俯仰pitch, 偏航yaw</p>
<p><strong>罗德里格斯旋转公式</strong></p>
<p>四元数(quaternion)可以Lerp</p>
<h2 id="观测变换-Viewing-Transformation">观测变换 Viewing Transformation</h2>
<blockquote>
<p>MVP变换：模型（model），视图（view），投影（projection）</p>
</blockquote>
<h3 id="视图变换-View-Camera-Transformation">视图变换 View/Camera Transformation</h3>
<p>定义相机</p>
<ul>
<li>Position <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>e</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{e}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">e</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span></li>
<li>Look-at / gaze direction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span></li>
<li>Up direction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>t</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8785em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">t</span></span><span style="top:-3.1841em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>相机拍摄的是相对运动，那么为何不让相机固定住呢</p>
<ul>
<li><strong>相机永远在原点，永远以Y轴为向上，相机永远看向-Z方向（约定俗成）</strong></li>
<li>其他物体的运动都是相对相机的运动</li>
</ul>
<p>将相机变换到上述固定位置</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>M</mi><mrow><mi>v</mi><mi>i</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mi>R</mi><mrow><mi>v</mi><mi>i</mi><mi>e</mi><mi>w</mi></mrow><mi>T</mi><mrow><mi>v</mi><mi>i</mi><mi>e</mi><mi>w</mi></mrow><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mtext>设相机原点在</mtext><mover accent="true"><mi>e</mi><mo>⃗</mo></mover><mtext>，看向</mtext><mover accent="true"><mi>g</mi><mo>^</mo></mover><mtext>，</mtext><mover accent="true"><mi>t</mi><mo>^</mo></mover><mtext>为上</mtext><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mover accent="true"><mi>e</mi><mo>⃗</mo></mover><mtext>平移至原点：</mtext><msub><mi>T</mi><mrow><mi>v</mi><mi>i</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mi>x</mi><mi>e</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mi>y</mi><mi>e</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mi>z</mi><mi>e</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mover accent="true"><mi>g</mi><mo>^</mo></mover><mtext>旋转至</mtext><mo>−</mo><mi>Z</mi><mtext>，</mtext><mover accent="true"><mi>t</mi><mo>^</mo></mover><mtext>旋转至</mtext><mi>Y</mi><mtext>，</mtext><mo stretchy="false">(</mo><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo>×</mo><mover accent="true"><mi>t</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mtext>旋转至</mtext><mi>X</mi><mspace linebreak="newline"></mspace><mtext>这样的旋转矩阵很难写，但其逆矩阵很简单，因为旋转矩阵是正交矩阵，写出其逆矩阵后转置即可得到要求的矩阵</mtext><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><msubsup><mi>R</mi><mrow><mi>v</mi><mi>i</mi><mi>e</mi><mi>w</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo>×</mo><mover accent="true"><mi>t</mi><mo>^</mo></mover></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mrow><mo>−</mo><mi>g</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>y</mi><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo>×</mo><mover accent="true"><mi>t</mi><mo>^</mo></mover></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>y</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>y</mi><mrow><mo>−</mo><mi>g</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>z</mi><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo>×</mo><mover accent="true"><mi>t</mi><mo>^</mo></mover></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>z</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>z</mi><mrow><mo>−</mo><mi>g</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>→</mo><msub><mi>R</mi><mrow><mi>v</mi><mi>i</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo>×</mo><mover accent="true"><mi>t</mi><mo>^</mo></mover></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>y</mi><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo>×</mo><mover accent="true"><mi>t</mi><mo>^</mo></mover></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>z</mi><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo>×</mo><mover accent="true"><mi>t</mi><mo>^</mo></mover></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>y</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>z</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mrow><mo>−</mo><mi>g</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>y</mi><mrow><mo>−</mo><mi>g</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>z</mi><mrow><mo>−</mo><mi>g</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">M_{view}=R{view}T{view} \\ \\
设相机原点在\vec{e}，看向\hat{g}，\hat{t}为上 \\ \\
\vec{e}平移至原点：
T_{view}=
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -x_{e} \\
0 &amp; 1 &amp; 0 &amp; -y_{e} \\
0 &amp; 0 &amp; 1 &amp; -z_{e} \\
0 &amp; 0 &amp; 0 &amp; 1 
\end{bmatrix} \\ \\
\hat{g}旋转至-Z，\hat{t}旋转至Y，(\hat{g}\times\hat{t})旋转至X \\
这样的旋转矩阵很难写，但其逆矩阵很简单，因为旋转矩阵是正交矩阵，写出其逆矩阵后转置即可得到要求的矩阵 \\ \\
R_{view}^{-1}=
\begin{bmatrix}
x_{\hat{g}\times\hat{t}} &amp; x_{t} &amp; x_{-g} &amp; 0 \\
y_{\hat{g}\times\hat{t}} &amp; y_{t} &amp; y_{-g} &amp; 0 \\
z_{\hat{g}\times\hat{t}} &amp; z_{t} &amp; z_{-g} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 
\end{bmatrix} \to
R_{view}=
\begin{bmatrix}
x_{\hat{g}\times\hat{t}} &amp; y_{\hat{g}\times\hat{t}} &amp; z_{\hat{g}\times\hat{t}} &amp; 0 \\
x_{t} &amp; y_{t} &amp; z_{t} &amp; 0 \\
x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.073em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">设相机原点在</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">e</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord cjk_fallback">，看向</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">t</span></span><span style="top:-3.1841em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mord cjk_fallback">为上</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.864em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">e</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mord cjk_fallback">平移至原点：</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mord cjk_fallback">旋转至</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1285em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mord cjk_fallback">，</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">t</span></span><span style="top:-3.1841em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mord cjk_fallback">旋转至</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord cjk_fallback">，</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1285em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">t</span></span><span style="top:-3.1841em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">旋转至</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">这样的旋转矩阵很难写，但其逆矩阵很简单，因为旋转矩阵是正交矩阵，写出其逆矩阵后转置即可得到要求的矩阵</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.1311em;vertical-align:-0.267em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.433em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.267em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.9388em;vertical-align:-2.2194em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7194em;"><span style="top:-4.8794em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4298em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord mtight">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight">t</span></span><span style="top:-2.8841em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord mtight">^</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4063em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.6331em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4298em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord mtight">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight">t</span></span><span style="top:-2.8841em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord mtight">^</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4063em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4298em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord mtight">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight">t</span></span><span style="top:-2.8841em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord mtight">^</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4063em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.1406em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2194em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7194em;"><span style="top:-4.8794em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.6331em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.1406em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2194em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7194em;"><span style="top:-4.8794em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.6331em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.1406em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2194em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7194em;"><span style="top:-4.8794em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.6331em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.1406em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2194em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8463em;vertical-align:-2.1731em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6731em;"><span style="top:-4.8331em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4298em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord mtight">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight">t</span></span><span style="top:-2.8841em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord mtight">^</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4063em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.5869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.1869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1731em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6731em;"><span style="top:-4.8331em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4298em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord mtight">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight">t</span></span><span style="top:-2.8841em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord mtight">^</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4063em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.5869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.1869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1731em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6731em;"><span style="top:-4.8331em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4298em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord mtight">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8785em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight">t</span></span><span style="top:-2.8841em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord mtight">^</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4063em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.5869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.1869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1731em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6731em;"><span style="top:-4.8331em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.5869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.1869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1731em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>视图变换和模型变换常常被一起提到，模型和相机常常一起变换，称为模型视图变换</p>
<h2 id="投影变换-Projection-Transformation">投影变换 Projection Transformation</h2>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403092344036.png" alt="image-20240309234448916" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403092345565.png" alt="image-20240309234548442" style="zoom:50%;" />
<p>正交投影不会有近大远小</p>
<h3 id="正交投影-Orthographic-Projection">正交投影 Orthographic Projection</h3>
<p>一个易于理解的方法：</p>
<ul>
<li>把相机放到原点上，向-Z方向看，Y为上</li>
<li><strong>扔掉Z坐标</strong></li>
<li>平移缩放得到的结果到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">]</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">[-1,1]^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>​（约定俗成）</li>
</ul>
<p>正式的做法：</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403092349505.png" alt="image-20240309234954407" style="zoom:50%;" />
<ul>
<li>把一个立方体变换为正则(canonical)立方体：平移，缩放</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>M</mi><mrow><mi>o</mi><mi>r</mi><mi>t</mi><mi>h</mi><mi>o</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn><mrow><mi>t</mi><mo>−</mo><mi>b</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mi>f</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mrow><mi>r</mi><mo>+</mo><mi>l</mi></mrow><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mrow><mi>t</mi><mo>+</mo><mi>b</mi></mrow><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mi>f</mi></mrow><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">M_{ortho}=
\begin{bmatrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\
0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\
0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">or</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:5.0231em;vertical-align:-2.2615em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7615em;"><span style="top:-4.9164em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.668em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4196em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.0985em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2615em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7615em;"><span style="top:-4.9164em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.668em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.4196em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.0985em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2615em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7615em;"><span style="top:-4.9164em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.668em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4196em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.0985em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2615em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7615em;"><span style="top:-4.9164em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.668em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4196em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.0985em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2615em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7362em;"><span style="top:-4.8561em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.616em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3238em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.1238em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2362em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7362em;"><span style="top:-4.8561em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.616em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.3238em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.1238em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2362em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7362em;"><span style="top:-4.8561em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.616em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3238em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.1238em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2362em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7362em;"><span style="top:-4.8561em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.616em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3238em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.1238em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2362em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="透视投影-Perspective-Projection">透视投影 Perspective Projection</h3>
<ul>
<li>首先挤压四椎体使其称为一个立方体</li>
<li>进行正交投影</li>
</ul>
<p>近平面点不变，远平面z不变</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403122040291.jpg" alt="f1a9a8eafe39abf782f7389e2838cf4" style="zoom:50%;" />
<h1>Lecture 05 Rasterization 1 (Triangles)</h1>
<h2 id="视场角（FOV-Field-of-View）和宽高比（Aspect-Ratio）与视锥各参数的转化">视场角（FOV-Field of View）和宽高比（Aspect Ratio）与视锥各参数的转化</h2>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403122053492.png" alt="image-20240312205336381" style="zoom:50%;" />
<h2 id="从正则立方体到屏幕空间">从正则立方体到屏幕空间</h2>
<p>通过在变换中推导出的MVP矩阵，我们可以将所有物体压缩进正则立方体中，而下一步便是将这些东西放到屏幕上了</p>
<h3 id="屏幕-Screen">屏幕 Screen</h3>
<ul>
<li>一个二维的像素数组</li>
<li>数组的大小：分辨率（resolution）</li>
<li>一种典型的光栅（raster）成像设备</li>
</ul>
<p>光栅（Raster）就是屏幕（Screen）的德语，光栅化（Rastize）就是将物体显示在屏幕上</p>
<h3 id="屏幕空间">屏幕空间</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403122101781.png" alt="image-20240312210102675" style="zoom:50%;" />
<ul>
<li>像素通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的坐标形式表示，像素的中心在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>0.5</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x+0.5, y+0.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0.5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0.5</span><span class="mclose">)</span></span></span></span></li>
<li>如果我们认为屏幕的分辨率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo>∗</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">width*height</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>，那么共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(width-1, height-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 个像素</li>
<li>屏幕空间覆盖了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(width, height)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>的范围</li>
</ul>
<h3 id="视口变换">视口变换</h3>
<ul>
<li>与z轴无关</li>
<li>由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">]</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">[-1,1]^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,width]\times[0,height]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>M</mi><mrow><mi>v</mi><mi>i</mi><mi>e</mi><mi>w</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi></mrow><mn>2</mn></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi></mrow><mn>2</mn></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><mn>2</mn></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><mn>2</mn></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">M_{viewport}=
\begin{bmatrix}
\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \\
0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">wp</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">or</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.9323em;vertical-align:-2.2162em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7162em;"><span style="top:-4.8361em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.5438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.1438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2162em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7162em;"><span style="top:-4.8361em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.5438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.1438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2162em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7162em;"><span style="top:-4.8361em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.5438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.1438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2162em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.7162em;"><span style="top:-4.8361em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.5438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.1438em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2162em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="三角形">三角形</h2>
<h3 id="为什么是三角形">为什么是三角形</h3>
<ul>
<li>三角形是最基础的多边形</li>
<li>可以用三角形来表示其他多边形</li>
<li>内部一定是平面的</li>
<li>内外定义非常清楚</li>
<li>方便进行内部差值</li>
</ul>
<h2 id="采样-Sampling">采样 Sampling</h2>
<p>这是最简单的光栅化方法</p>
<blockquote>
<p><strong>把一个函数离散化：给定一个函数，得到一个个具体的值</strong></p>
</blockquote>
<p>采样一个像素的中心是否在三角形内部</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mspace width="1em"/><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>i</mi><mi>n</mi><mtext> </mtext><mi mathvariant="normal">△</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mspace width="1em"/><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">inside(t,x,y)=
\begin{cases}
1 \quad (x,y)\ in\ \triangle t\\
0 \quad otherwise
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal">in</span><span class="mspace"> </span><span class="mord">△</span><span class="mord mathnormal">t</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">se</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<p>通过三次叉积即可判断点是否在三角形内部</p>
</li>
<li>
<p>边界问题：要么不做处理，要么特殊处理，自洽即可</p>
</li>
<li>
<p>通过三角形的包围盒（Bounding Box）提高采样效率：只要在包围盒内的像素才有可能被覆盖到</p>
</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403122148477.png" alt="image-20240312214834322" style="zoom:50%;" />
<ul>
<li>还有很多加速光栅化的方式：如下面的只从三角形每行的第一个像素开始</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403122150281.png" alt="image-20240312215039137" style="zoom:50%;" />
<blockquote>
<p><strong>光栅化图形学的严重问题：抗锯齿（Jaggies）与反走样（Aliasing）</strong></p>
</blockquote>
<h1>Lecture 06 Rasterization 2 (Antialiasing and Z-Buffering)</h1>
<p>采样（sample）在计算机图形学中无处不在</p>
<ul>
<li>光栅化是一种对2D像素点的采样</li>
<li>摄影是一种对感光元件的采样</li>
<li>视频是一种对时间的采样</li>
</ul>
<p>采样会产生一系列Sample Artifacts（瑕疵）</p>
<ul>
<li>
<p>锯齿 Jaggies</p>
</li>
<li>
<p>摩尔纹 Moire Pattern</p>
</li>
<li>
<p>Wagon wheel effect（False Motion）</p>
</li>
</ul>
<blockquote>
<p><strong>在走样的背后：信号变化太快，但采样频率太慢</strong></p>
</blockquote>
<p>反走样采样（Antialiased Sampling）</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403200822183.png" alt="image-20240320082236039" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403200824233.png" alt="image-20240320082428051" style="zoom:50%;" />
<blockquote>
<p><strong>走样Alias：同样采样方法采样两个不一样的函数，得到的结果我们无法区分</strong></p>
<p><strong>滤波Filtering：去掉一系列特定频率</strong></p>
</blockquote>
<p>高通滤波：去掉低频信号 - 锐化、剩余边界</p>
<p>低通滤波：去掉高频信号 - 模糊</p>
<ul>
<li>
<p>滤波Filtering = 卷积convolution</p>
</li>
<li>
<p>时域上的卷积 = 频域上的乘积</p>
</li>
<li>
<p>从频率上说：采样Sampling = 重复Repeating</p>
</li>
</ul>
<p>如何减少走样问题</p>
<ul>
<li>增加采样率</li>
<li>反走样：先模糊（低通滤波）再采样</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403212332833.png" alt="image-20240321233214688" style="zoom:50%;" />
<h2 id="Antialiasing-By-Supersampling">Antialiasing By Supersampling</h2>
<h3 id="MSAA-Multisample-Anti-Aliasing">MSAA - Multisample Anti-Aliasing</h3>
<p>使用更多的采样点近似地改善走样 - 信号的模糊</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403212337411.png" alt="image-20240321233735273" style="zoom:50%;" />
<p>代价：增加了计算量</p>
<h3 id="FXAA-Fast-Approximate-Anti-Aliasing">FXAA - Fast Approximate Anti-Aliasing</h3>
<p>图像的后期处理 - 替换有锯齿的边界</p>
<p>和采样本身无关</p>
<h3 id="TAA-Temporal-Anti-Aliasing">TAA - Temporal Anti-Aliasing</h3>
<p>把MSAA增加的采样点分布在时间维度上</p>
<p>帧与帧之间采样点不同，通过与上一帧的比较进行反走样</p>
<h3 id="超分辨率-Super-Resolution">超分辨率 Super Resolution</h3>
<ul>
<li>超分辨率是将低分辨率映射至高分辨率时进行的画面优化</li>
<li>某种程度上和反走样异曲同工，本质相同</li>
<li>DLSS (Deep Learning Super Sampling)</li>
</ul>
<h1>Lecture 07 Shading 1 (Illumination, Shading and Graphics Pipeline)</h1>
<h2 id="画家算法-Painter’s-Algorithm">画家算法 Painter’s Algorithm</h2>
<p>类似油画的算法：先画远处的，后画的会覆盖先画的</p>
<ul>
<li>
<p>需要进行深度排序，对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个三角形需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>在处理类似下面的情况会发生问题</p>
</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403242138614.png" alt="image-20240324213827464" style="zoom:50%;" />
<h2 id="Z-Buffer">Z-Buffer</h2>
<ul>
<li>对每个像素记录当前的最小z值</li>
<li>需要一个额外的Buffer记录深度值：Frame Buffer记录颜色值，Depth Buffer记录深度值</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403242141861.png" alt="image-20240324214127685" style="zoom:50%;" />
<h3 id="Algorithm">Algorithm</h3>
<ul>
<li>
<p>将所有的深度值初始化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></p>
</li>
<li>
<p>在光栅化时：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (each trangle T) &#123;</span><br><span class="line">    <span class="keyword">for</span> (each <span class="built_in">sample</span>(x, y, z) in T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z &lt; depthBuffer[x, y]) &#123;</span><br><span class="line">            frameBuffer[x, y] = rgb;</span><br><span class="line">            depthBuffer[x, y] = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Complexity：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>和计算顺序无关</p>
</li>
</ul>
<h2 id="着色-Shading">着色 Shading</h2>
<blockquote>
<p><strong>着色：向物体应用材质的过程</strong></p>
</blockquote>
<h3 id="一个简单的着色模型：Blinn-Phong-Reflectance-Model">一个简单的着色模型：Blinn-Phong Reflectance Model</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403242205009.png" alt="image-20240324220557877" style="zoom:50%;" />
<ul>
<li>View direction - v</li>
<li>Surface normal - n</li>
<li>Light direction - l</li>
<li>Surface parameters - colors, shininess…</li>
</ul>
<p>Shading is Local: shading ≠ shadow</p>
<h4 id="漫反射-Diffuse-Reflection">漫反射 Diffuse Reflection</h4>
<ul>
<li>光线会均匀地散射向各个方向</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403242209917.png" alt="image-20240324220949796" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403242213527.png" alt="image-20240324221351392" style="zoom:50%;" />
<ul>
<li>需要考虑接收到光的能量：Lambert’s cosine law，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>=</mo><mi>l</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">cos\theta = l *n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403242216385.png" alt="image-20240324221643233" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403242217528.png" alt="image-20240324221723383" style="zoom:50%;" />
<p>公式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mi>d</mi></msub><mo>=</mo><msub><mi>k</mi><mi>d</mi></msub><mo stretchy="false">(</mo><mi>I</mi><mi mathvariant="normal">/</mi><msup><mi>r</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_d = k_d(I/r^2)max(0,n \ast l)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span></span></p>
<h1>Lecture 08 Shading 2 (Shading, Pipeline and Texture Mapping)</h1>
<h2 id="镜面反射项-Specular-Term-Blinn-Phong">镜面反射项 Specular Term (Blinn-Phong)</h2>
<p>当观察向量和反射向量足够接近时，就会出现高光现象</p>
<p>Blinn-Phong模型：当观察向量和反射向量很接近时，就说明半程向量（half vector）和法线很接近</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252254502.png" alt="image-20240325225419328" style="zoom:50%;" />
<p><em>Blinn-Phong简化了被吸收的光，省略了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(0, n\ast l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>​</em></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>L</mi><mi>s</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>k</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>I</mi><mi mathvariant="normal">/</mi><msup><mi>r</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>cos</mi><mo>⁡</mo><mi>α</mi><msup><mo stretchy="false">)</mo><mi>p</mi></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>k</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>I</mi><mi mathvariant="normal">/</mi><msup><mi>r</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>∗</mo><mi>h</mi><msup><mo stretchy="false">)</mo><mi>p</mi></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
L_s &amp; = k_s(I/r^2)max(0,\cos\alpha)^p \\
&amp; = k_s(I/r^2)max(0,n\ast h)^p
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0482em;vertical-align:-1.2741em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7741em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3859em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2741em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7741em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3859em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">h</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2741em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>为什么会有p次方：直接用cos函数的容忍度太高了，如下图所示，一般Blinn-Phong模型中p取100~200</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252258203.png" alt="image-20240325225858065" style="zoom:50%;" />
<h2 id="环境光照项-Ambient-Term">环境光照项 Ambient Term</h2>
<p>真实的环境光极度复杂，很难直接进行模拟</p>
<p>在这里直接假设所有物体收到的环境光永远都是相同的</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mi>a</mi></msub><mo>=</mo><msub><mi>k</mi><mi>a</mi></msub><msub><mi>I</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">L_a = k_a I_a
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><em>这是一个估值、一个假设</em></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252305304.png" alt="image-20240325230543165" style="zoom:50%;" />
<p>环境光和观察角度、入射角度、法线都无关，其是一个常数</p>
<h2 id="Blinn-Phong反射模型">Blinn-Phong反射模型</h2>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>L</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>L</mi><mi>a</mi></msub><mo>+</mo><msub><mi>L</mi><mi>d</mi></msub><mo>+</mo><msub><mi>L</mi><mi>s</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>k</mi><mi>a</mi></msub><msub><mi>I</mi><mi>a</mi></msub><mo>+</mo><msub><mi>k</mi><mi>d</mi></msub><mo stretchy="false">(</mo><mi>I</mi><mi mathvariant="normal">/</mi><msup><mi>r</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>I</mi><mi mathvariant="normal">/</mi><msup><mi>r</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>∗</mo><mi>h</mi><msup><mo stretchy="false">)</mo><mi>p</mi></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
L &amp; = L_a + L_d + L_s \\
&amp; = k_a I_a + k_d(I/r^2)max(0,n \ast l) + k_s(I/r^2)max(0,n\ast h)^p
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0241em;vertical-align:-1.2621em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7621em;"><span style="top:-3.9221em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">L</span></span></span><span style="top:-2.3979em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2621em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7621em;"><span style="top:-3.9221em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3979em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">h</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2621em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252311840.png" alt="image-20240325231149673" style="zoom:50%;" />
<h2 id="着色频率-Shading-Frequencies">着色频率 Shading Frequencies</h2>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252313316.png" alt="image-20240325231345179" style="zoom:50%;" />
<p>这三个球的几何表示其实完全相同，只是着色频率的区别</p>
<p>三个球分别对应：对平面着色、对顶点着色（使用差值计算内部颜色）、对像素（使用差值计算内部法线）着色</p>
<h3 id="平面着色-Shade-each-triangle-flat-shading">平面着色 Shade each triangle (flat shading)</h3>
<ul>
<li>三角形是一个面，有一条法线</li>
<li>对光滑平面来说效果并不好</li>
</ul>
<h3 id="高洛德着色-Shade-each-vertex-Gouraud-shading">高洛德着色 Shade each vertex (Gouraud shading)</h3>
<ul>
<li>通过顶点差值计算像素的颜色</li>
<li>每个顶点有一条法线</li>
</ul>
<h3 id="古罗着色-Shade-each-pixel-Phong-shading">古罗着色 Shade each pixel (Phong shading)</h3>
<ul>
<li>通过顶点差值计算像素的法线</li>
<li>为每个像素应用着色模型</li>
</ul>
<h3 id="着色方法的比较">着色方法的比较</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252325256.png" alt="image-20240325232509091" style="zoom:50%;" />
<p>当模型面数很高时，简单的着色模型效果也会不错</p>
<h3 id="顶点-像素法线的计算">顶点/像素法线的计算</h3>
<ul>
<li>顶点法线：顶点周围面的法线的平均（普通或加权）</li>
</ul>
<p>通过顶点法线差值计算像素法线</p>
<h2 id="图形（实时渲染）管线-Graphics-Real-time-Rendering-Pipeline">图形（实时渲染）管线 Graphics (Real-time Rendering) Pipeline</h2>
<p>管线：如何从场景到图</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252331445.png" alt="image-20240325233137272" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252337141.png" alt="image-20240325233721974" style="zoom:50%;" />
<h3 id="Shader-Programs">Shader Programs</h3>
<ul>
<li>编写顶点和片元的处理策略</li>
<li>描述一个单一顶点或片元的操作（会应用到所有顶点/片元上）</li>
</ul>
<h2 id="纹理映射-Texture-Mapping">纹理映射 Texture Mapping</h2>
<blockquote>
<p><strong>定义任何一个点的属性</strong></p>
</blockquote>
<p>任何一个三维物体的表面其实是二维的，纹理就是三维物体表面再开后的二维面</p>
<p>模型上的每个三角形顶点都会被分配给纹理上的一个坐标（u,v）</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252352771.png" alt="image-20240325235251522" style="zoom:50%;" />
<p>纹理可以被多次映射</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403252354483.png" alt="image-20240325235422215" style="zoom:50%;" />
<h1>Lecture 09 Shading 3 (Texture Mapping Cont.)</h1>
<h2 id="在三角形内部进行插值：重心坐标-Barycentric-Cooridnates">在三角形内部进行插值：重心坐标 Barycentric Cooridnates</h2>
<h3 id="定义">定义</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262156699.png" alt="image-20240326215604537" style="zoom:50%;" />
<p><em>重心坐标是定义在某一三角形上的</em></p>
<p>给定任意一个三角形，其平面上任意点的坐标都可以表示为其顶点坐标的线性组合</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>α</mi><mi>A</mi><mo>+</mo><mi>β</mi><mi>B</mi><mo>+</mo><mi>γ</mi><mi>C</mi><mspace linebreak="newline"></mspace><mi>α</mi><mo>+</mo><mi>β</mi><mo>+</mo><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(x,y) = \alpha A + \beta B + \gamma C \\
\alpha + \beta + \gamma = 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">βB</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>对于坐标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo separator="true">,</mo><mi>γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\alpha,\beta,\gamma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span></span></span></span>便是其重心坐标</p>
<p>而对于三角形内部的点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&gt;</mo><mn>0</mn><mtext>且</mtext><mi>β</mi><mo>&gt;</mo><mn>0</mn><mtext>且</mtext><mi>γ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\alpha&gt;0且\beta&gt;0且\gamma&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262203840.png" alt="image-20240326220337674" style="zoom:50%;" />
<p>而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mtext>、</mtext><mi>β</mi><mtext>、</mtext><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha、\beta、\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>的值可以通过面积比得到</p>
<p>由上述推导可得，三角形的重心的重心坐标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mo separator="true">,</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mo separator="true">,</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\frac{1}{3},\frac{1}{3},\frac{1}{3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></p>
<h3 id="应用">应用</h3>
<p>我们可以用重心坐标得到三角形内部任意点的插值</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262207274.png" alt="image-20240326220755100" style="zoom:50%;" />
<p>重心坐标虽好用，但是其不能保证在投影后重心坐标不变，我们理论上不应该对投影后的三角形应用重心坐标进行插值，我们应该使用逆变换得到其原来的三维坐标，再对三维坐标进行计算</p>
<h2 id="应用纹理">应用纹理</h2>
<p>我们可以通过采样得到采样点/屏幕坐标计算得到其对应的uv值，然后根据uv值从纹理上得到对应的颜色，之后通过光照反射模型（比如Blinn-Phong）将颜色应用到反射系数上了</p>
<p>但是这样会带来一些问题：</p>
<h3 id="纹理放大-Texture-Magnification">纹理放大 Texture Magnification</h3>
<h4 id="如果纹理太小了">如果纹理太小了</h4>
<p>如果纹理很小但是分辨率很高，纹理就会被拉大</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262219466.png" alt="image-20240326221920235" style="zoom:50%;" />
<p>我们可以通过简单的四舍五入找最佳的点来解决这一点，这样一个texel就会被映射到多个临近pixel上，但这会带来很多锯齿</p>
<p>一些方法可以改善这一问题</p>
<ul>
<li>双线性插值 Bilinear Interpolation</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262226072.png" alt="image-20240326222613903" style="zoom:50%;" />
<ul>
<li>双三次插值 Bicubic Interpolation</li>
</ul>
<p>开销更大，效果更好</p>
<h4 id="如果纹理太大了">如果纹理太大了</h4>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262235004.png" alt="image-20240326223554785" style="zoom:50%;" />
<p>每个像素覆盖的texel数量不同，有的像素覆盖了过多的texel</p>
<p>超采样可以一定程度解决这个问题，但是这开销太高了</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262240347.png" alt="image-20240326224000188" style="zoom:50%;" />
<p><em>范围查询</em></p>
<p>Mipmap：允许进行范围查询（快速，近似，正方形）</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262241414.png" alt="image-20240326224136187" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262249570.png" alt="image-20240326224907408" style="zoom:50%;" />
<p>三线性插值</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262252400.png" alt="image-20240326225258233" style="zoom:50%;" />
<p>Mipmap可能让远处的细节糊掉：Overblur</p>
<p>一个方法可以一定程度改善这一问题：各向异性过滤 Anisotropic Filtering</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262257700.png" alt="image-20240326225758529" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262258957.png" alt="image-20240326225814755" style="zoom:50%;" />
<p>各向异性过滤会将图片按长宽分别进行压缩从而得以支持矩形的范围查询，改善了Mipmap只支持正方形的问题</p>
<p>其可以一定程度上解决问题，但是对于一些非常难搞的情况，比如实际的映射范围是斜着的，其仍然存在走样的情况</p>
<p>因此人们还发明了一些其他方法：EWA - 通过将范围转变为圆形进行多次查询</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202403262301401.png" alt="image-20240326230142240" style="zoom:50%;" />
<h2 id="纹理的广泛作用">纹理的广泛作用</h2>
<blockquote>
<p>纹理本质上可以被理解为一块可以进行查询的内存（数据）</p>
</blockquote>
<h3 id="环境光映射-环境光贴图-Environment-Map">环境光映射 / 环境光贴图 Environment Map</h3>
<p>用纹理球描述环境光 Spherical Enviroment Map</p>
<p>问题：靠近极点会产生扭曲 - Cube Map</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092312558.png" alt="image-20240409231234338" style="zoom:50%;" />
<h3 id="凹凸贴图-法线贴图">凹凸贴图 / 法线贴图</h3>
<p>纹理不一定只能用来表示颜色，我们可以用纹理来表示凹凸</p>
<p>这可以在不改变模型的情况下制造凹凸的视觉效果</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092322745.png" alt="image-20240409232251581" style="zoom:50%;" />
<p>位移贴图 Displacement map 会真的改变顶点，但是要求模型足够细致</p>
<h3 id="3D纹理">3D纹理</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092324084.png" alt="image-20240409232421871" style="zoom:50%;" />
<h3 id="预计算着色">预计算着色</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092325567.png" alt="image-20240409232558384" style="zoom:50%;" />
<h3 id="体渲染">体渲染</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092327410.png" alt="image-20240409232729220" style="zoom:50%;" />
<h1>Lecture 10 Geometry 1 (Introduction)</h1>
<h2 id="如何表示几何">如何表示几何</h2>
<h3 id="隐式-Implicit">隐式 Implicit</h3>
<blockquote>
<p>基于满足特定关系的点的集合</p>
</blockquote>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092336071.png" alt="image-20240409233629874" style="zoom:50%;" />
<ul>
<li>很难直观地描述几何形体，难以确定具体有哪些点在几何表面</li>
<li>易于判定给定点与几何的相对位置关系，是否在几何内/外</li>
</ul>
<h3 id="显式-Explicit">显式 Explicit</h3>
<blockquote>
<p>所有点都直接显式给予或通过参数映射（uv）给予</p>
</blockquote>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092339411.png" alt="image-20240409233958221"></p>
<ul>
<li>易于进行直观地描述</li>
<li>但难以判定点是否在几何内/外</li>
</ul>
<h2 id="几何表示法">几何表示法</h2>
<h3 id="直接通过算术方法表示-Implicit">直接通过算术方法表示 - Implicit</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092345841.png" alt="image-20240409234509657" style="zoom:50%;" />
<h3 id="构造实体集合-Constructive-Solid-Geometry-Implicit">构造实体集合 Constructive Solid Geometry - Implicit</h3>
<p>通过定义简单的基本几何与基本运算组合出复杂几何</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092346733.png" alt="image-20240409234633507" style="zoom:50%;" />
<h3 id="距离函数-Distance-Functions-Implicit">距离函数 Distance Functions - Implicit</h3>
<p>定义距离函数来表示几何：用空间中的每个点到边界的最佳距离来描述几何 - SDF</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092347498.png" alt="image-20240409234744278" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092348094.png" alt="image-20240409234819893" style="zoom:50%;" />
<p>任意两个距离函数都可以被很好地Blend</p>
<p>距离函数的表示能力非常强</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092352466.png" alt="image-20240409235257267" style="zoom:50%;" />
<h3 id="分形-Implicit">分形 - Implicit</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404092354694.png" alt="image-20240409235412470" style="zoom:50%;" />
<h1>Lecture 11 Geometry 2 (Curves and Surfaces)</h1>
<h2 id="几何表示法-2">几何表示法</h2>
<h3 id="点云-Point-Cloud-Explicit">点云 Point Cloud - Explicit</h3>
<p>最简单的显式表示法 - 一个点的列表</p>
<p>扫描直接得到的三维数据通常是点云</p>
<h3 id="多边形面-Polygon-Mesh-Explicit">多边形面 Polygon Mesh - Explicit</h3>
<p>最常用的形式</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404232222295.png" alt="image-20240423222236050" style="zoom: 50%;" />
<p><code>.obj</code>最直接的文件格式</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404232223228.png" alt="image-20240423222321040" style="zoom:50%;" />
<h2 id="曲线-Curves">曲线 Curves</h2>
<h3 id="贝赛尔曲线">贝赛尔曲线</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404232226592.png" alt="image-20240423222657426" style="zoom:50%;" />
<h4 id="De-Casteljau-Algorithm">De Casteljau Algorithm</h4>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404232229954.png" alt="image-20240423222928765" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404232233365.png" alt="image-20240423223359167" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404232239942.png" alt="image-20240423223938757" style="zoom:50%;" />
<ul>
<li>仿射变换不变</li>
<li>一定在凸包内</li>
</ul>
<h4 id="分段贝塞尔曲线-Piecewise">分段贝塞尔曲线 Piecewise</h4>
<p>当贝塞尔曲线控制点过多时，容易出现曲线不明显且十分耗时的情况</p>
<p>可以通过分段求解贝塞尔曲线来解决这点</p>
<p>一般会采用每四个控制点一组，这有利于对曲线的控制</p>
<p>只要保证导数连续便可以保证贝塞尔曲线的光滑</p>
<h3 id="其他曲线">其他曲线</h3>
<h4 id="Splines-样条">Splines - 样条</h4>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404232249974.png" alt="image-20240423224901762" style="zoom:50%;" />
<h4 id="B-Splines">B-Splines</h4>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404232249699.png" alt="image-20240423224939546" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404232250769.png" alt="image-20240423225058605" style="zoom:50%;" />
<h2 id="曲面-Surfaces">曲面 Surfaces</h2>
<h3 id="贝塞尔曲面">贝塞尔曲面</h3>
<p>可以用贝塞尔曲线得到贝塞尔曲面</p>
<p>类似双线性插值</p>
<h3 id="网格操作：几何处理">网格操作：几何处理</h3>
<ul>
<li>网格细分 Mesh subdivision</li>
<li>网格简化 Mesh simplification</li>
<li>网格正规化 Mesh regularization</li>
</ul>
<h1>Lecture 12 Geometry 3</h1>
<h2 id="网格细分">网格细分</h2>
<h3 id="Loop-Subdivision">Loop Subdivision</h3>
<ul>
<li>把每个三角形分为4个</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241048302.png" alt="image-20240424104823067" style="zoom:50%;" />
<ul>
<li>根据权重分配新的顶点</li>
</ul>
<p>对于新的顶点：</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241049683.png" alt="image-20240424104950516" style="zoom:50%;" />
<p>对于旧的顶点：</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241050741.png" alt="image-20240424105058537" style="zoom:50%;" />
<h3 id="Catmull-Clark-Subdivision">Catmull-Clark Subdivision</h3>
<p>Loop Subdiversion只能作用于全部由三角形构成的网格</p>
<p>而Catmull-Clark细分可以作用于所有的网格</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241101142.png" alt="image-20240424110141944" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241105123.png" alt="image-20240424110527959" style="zoom:50%;" />
<p>每个非四边形面在一次C-C细分后都会为增加一个奇异点，但一次细分之后，奇异点数量不再改变</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241108310.png" alt="image-20240424110807142" style="zoom:50%;" />
<h2 id="网格简化">网格简化</h2>
<p>目标：减少网格数量，但保持整体的形体</p>
<h3 id="边坍缩-Collapsing-An-Edge">边坍缩 Collapsing An Edge</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241113525.png" alt="image-20240424111334348" style="zoom:50%;" />
<h4 id="二次误差度量-Quadric-Error-Metrics">二次误差度量 Quadric Error Metrics</h4>
<p>决定边坍缩的目标</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241115784.png" alt="image-20240424111520623" style="zoom:50%;" />
<h4 id="通过二次度量误差进行简化">通过二次度量误差进行简化</h4>
<p>让最终点到其他点的距离的平方和最小</p>
<p>对模型中的每条边，假设其被坍缩，计算其探索后的最佳点的二次度量误差值，最后取所有边中误差值最小的边进行探索</p>
<p><em>使用优先队列/堆</em></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241119726.png" alt="image-20240424111924542" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241120249.png" alt="image-20240424112001065" style="zoom:50%;" />
<h2 id="阴影映射-Shadow-Mapping">阴影映射 Shadow Mapping</h2>
<ul>
<li>一种图像空间算法</li>
<li>可能会产生走样</li>
<li>Key Idea: 不在阴影里的点一定同时被光源和摄像机照到</li>
</ul>
<p>Shadow Mapping只能应用于点光源</p>
<p>PASS:</p>
<ol>
<li>Render from Light</li>
</ol>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241127343.png" alt="image-20240424112754130" style="zoom:50%;" />
<p>得到光源视角的深度图</p>
<ol start="2">
<li>Render from Eye</li>
</ol>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241129167.png" alt="image-20240424112929974" style="zoom:50%;" />
<p>得到相机视角的标准图（带深度）</p>
<ol start="3">
<li>Project to Light</li>
</ol>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241130726.png" alt="image-20240424113009525" style="zoom:50%;" />
<p>将相机视角看到的点投影回光源</p>
<p>比较二者的深度，如果深度相同则在阴影外；反之则在阴影内</p>
<h3 id="硬阴影与软阴影">硬阴影与软阴影</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202404241141826.png" alt="image-20240424114158623" style="zoom:50%;" />
<h1>Lecture 13 Ray Tracing 1 (Whitted-Style Ray Tracing)</h1>
<h2 id="Why-Ray-Tracing">Why Ray Tracing?</h2>
<ul>
<li>光栅化在处理全局效果时并不好</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072049431.png" alt="image-20240507204933189" style="zoom:50%;" />
<ul>
<li>光栅化很快，但是质量却不太好</li>
<li>光线追踪很准确，但是很慢</li>
</ul>
<h2 id="光线">光线</h2>
<ul>
<li>光线沿直线传播</li>
<li>光线之间不会相互影响</li>
<li>光线从光源出发最后到达我们的眼睛（光线是可逆的）</li>
</ul>
<h2 id="光线投射">光线投射</h2>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072124998.png" alt="image-20240507212453824"></p>
<h2 id="Whitted-Style-Ray-Tracing">Whitted-Style Ray Tracing</h2>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072124773.png" alt="image-20240507212405482" style="zoom:50%;" />
<p>任一点的光线可以继续传播（反射、折射）</p>
<p>对每一个弹射点计算其着色，最后一起加到原先的像素点上</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072130835.png" alt="image-20240507213021646"></p>
<h3 id="求交点">求交点</h3>
<p>对于隐式几何：求方程组的解即可</p>
<p>对于显式几何：</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142307562.png" alt="image-20240514230719291" style="zoom: 33%;" />
<p>点与平面求交：</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142309811.png" alt="image-20240514230933593" style="zoom:33%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142310306.png" alt="image-20240514231002061" style="zoom:33%;" />
<p>MT算法：重心坐标求点是否在三角形内</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072218406.png" alt="image-20240507221808203" style="zoom:50%;" />
<h3 id="加速求交">加速求交</h3>
<p>包围盒 / 包围体积</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072226231.png" alt="image-20240507222603012" style="zoom:50%;" />
<p>长方体：空间中三个对面的交集</p>
<p>AABB-轴对齐包围盒</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072228393.png" alt="image-20240507222836202" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072236234.png" alt="image-20240507223617046" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072238262.png" alt="image-20240507223830054" style="zoom:50%;" />
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>e</mi><mi>x</mi><mi>i</mi><mi>t</mi></mrow></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_{exit}&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> - 盒子在射线之后，没有交点</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>e</mi><mi>x</mi><mi>i</mi><mi>t</mi></mrow></msub><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_{exit}&gt;=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_{enter}&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> - 射线起点在盒子内部，一定有交点</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow></msub><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>e</mi><mi>x</mi><mi>i</mi><mi>t</mi></mrow></msub><mtext>且</mtext><msub><mi>t</mi><mrow><mi>e</mi><mi>x</mi><mi>i</mi><mi>t</mi></mrow></msub><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_{enter}&lt;t_{exit}且t_{exit}&gt;=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">且</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405072245252.png" alt="image-20240507224554035" style="zoom: 33%;" />
<h1>Lecture 14 Ray Tracing 2 (Acceleration &amp; Radiometry)</h1>
<h2 id="使用AABBs（轴对齐包围盒）加速光追">使用AABBs（轴对齐包围盒）加速光追</h2>
<h3 id="Uniform-grids">Uniform grids</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142321436.png" alt="image-20240514232118267" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142322381.png" alt="image-20240514232222213" style="zoom:50%;" />
<ol>
<li>找到包围盒</li>
<li>创建格子</li>
<li>标记有东西的盒子</li>
</ol>
<p>多做和盒子的求交，少做和物体的求交</p>
<p>格子的密度需要平衡</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142324136.png" alt="image-20240514232412971" style="zoom:50%;" />
<p>物体分布越均匀越适合使用Uniform Grids</p>
<h3 id="Spatial-partitions-空间划分">Spatial partitions - 空间划分</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142326994.png" alt="image-20240514232623799" style="zoom:50%;" />
<ul>
<li>
<p>Oct-Tree 八叉树：在维度升高后划分数量会几何级增加，不适合处理高维坐标</p>
</li>
<li>
<p>KD-Tree：和八叉树原理基本相同，但是其划分不会受到维度影响，每次只切一刀；横竖交替划分，使得划分更加均匀</p>
</li>
<li>
<p>BSP-Tree：和KD-Tree很想，但划分不是延轴的</p>
</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142332774.png" alt="image-20240514233253563" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142333445.png" alt="image-20240514233316280" style="zoom:50%;" />
<p>KD-Tree的问题：</p>
<ul>
<li>包围盒和三角形是否有交点的计算十分复杂</li>
<li>一个物体可能出现在多个叶子结点中</li>
</ul>
<h3 id="Object-partitions-Bounding-Volume-Hierarch-BVH">Object partitions &amp; Bounding Volume Hierarch (BVH)</h3>
<p>最常用，很大程度上解决了KD-Tree的问题</p>
<p>BVH不划分空间，而是划分物体</p>
<p>先分物体，再求包围盒</p>
<ul>
<li>优点：一个物体只可能出现在一个叶子结点</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142343757.png" alt="image-20240514234327580" style="zoom:50%;" />
<ul>
<li>缺点：BVH划分的出的区块有可能重叠</li>
</ul>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142345456.png" alt="image-20240514234546284" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142350081.png" alt="image-20240514235045913" style="zoom:50%;" />
<p>BVH算法伪代码：</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142351584.png" alt="image-20240514235130386" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405142352401.png" alt="image-20240514235235220" style="zoom:50%;" />
<h2 id="Basic-Radiometry-辐射度量学">Basic Radiometry - 辐射度量学</h2>
<p>在之前的着色与反射模型中，我们常常通过经验来定义公式，这是可行的，也可以得到很好的效果。但经验始终只是经验，辐射度量学可以给出基于物理的准确定义光照的方法</p>
<ul>
<li>描述光照的单位与体系</li>
<li>基于空间光学</li>
<li>Radiant Flux 辐射通量 - Intensity 辐射强度 - Irradiance 辐照度 - Radiance 辐亮度</li>
</ul>
<h3 id="Radient-Energy-and-Flux-Power">Radient Energy and Flux(Power)</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405150913641.png" alt="image-20240515091324405" style="zoom:50%;" />
<p>流明 lm - 功率 W</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405150929536.png" alt="image-20240515092941308" style="zoom:50%;" />
<p>Flux另一种理解：单位时间内通过某一平面的光子量</p>
<h3 id="光的度量">光的度量</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405150931959.png" alt="image-20240515093116778" style="zoom:50%;" />
<h4 id="Radiant-Intensity">Radiant Intensity</h4>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405150932953.png" alt="image-20240515093209773" style="zoom:50%;" />
<p>单位立体角发出的能量 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>W</mi><mrow><mi>s</mi><mi>r</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>l</mi><mi>m</mi></mrow><mrow><mi>s</mi><mi>r</mi></mrow></mfrac><mo>=</mo><mi>c</mi><mi>d</mi><mo>=</mo><mi>c</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>l</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\frac{W}{sr}=\frac{lm}{sr}=cd=candela</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">sr</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">sr</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span></span></span></span>​</p>
<h5 id="立体角">立体角</h5>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405150949079.png" alt="image-20240515094958876" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405150953029.png" alt="image-20240515095316837" style="zoom:50%;" />
<h5 id="Intensity">Intensity</h5>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405150955483.png" alt="image-20240515095519264" style="zoom:50%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202405150957736.png" alt="image-20240515095702532" style="zoom:50%;" />
<h4 id="Irradiance">Irradiance</h4>
<h4 id="Radiance">Radiance</h4>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Graphics</category>
        <category>《GAMES101》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>《EscapeFromVirus》-严肃游戏工坊作品</title>
    <url>/posts/2/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261533351.png" alt="logo" style="zoom: 50%;" />
<h1>躲避病毒</h1>
<blockquote>
<p><strong>项目介绍</strong>：<a href="https://mp.weixin.qq.com/s/vUAJRW31vuiZmy-ZV_FtrA">https://mp.weixin.qq.com/s/vUAJRW31vuiZmy-ZV_FtrA</a></p>
</blockquote>
<p>我在本次项目中独自担任程序，使用Unity引擎负责了全部代码的编写</p>
<h2 id="小组成员">小组成员</h2>
<ul>
<li>
<p>策划：唐诗</p>
</li>
<li>
<p>美术：王子彤 刘月映</p>
</li>
<li>
<p>程序：<strong>伍泽华</strong></p>
</li>
<li>
<p>测试：杨光平</p>
</li>
</ul>
<h2 id="游戏内容">游戏内容</h2>
<p>这是一款竖版弹幕类、动作敏捷类平面游戏。</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261547150.png" alt="640 (1)" style="zoom:50%;" />
<h2 id="游戏机制">游戏机制</h2>
<p>玩家需要扮演角色“阿尼”或“A喵”，在屏幕上躲避从屏幕四周袭来的象征冠状病毒的弹幕，期间尽可能收集口罩等防疫物品，获得有助于通关的增益效果。</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261548998.png" alt="640" style="zoom:50%;" />
<h2 id="游戏介绍">游戏介绍</h2>
<p>通过回答防疫相关问题，获取猫粮，尽可能长时间地生存下来，生存时间越长得分越高。</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261548606.png" alt="640 (2)" style="zoom:50%;" />
<h2 id="创作立意">创作立意</h2>
<p>希望通过制作这样的一款严肃游戏，能让玩家关注防疫政策的变化，学习到防范病毒的小知识，学会做自己健康第一责任人。</p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2022</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>《电击小子》-CiGA GameJam 2023</title>
    <url>/posts/7/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307161555859.webp" alt="img" style="zoom:50%;" />
<h1>电击小子</h1>
<blockquote>
<p><strong>游戏页面</strong>：<a href="https://gmhub.com/game/2698">https://gmhub.com/game/2698</a></p>
<p><strong>介绍视频</strong>：<a href="https://www.bilibili.com/video/BV1TW4y1f7ai/">https://www.bilibili.com/video/BV1TW4y1f7ai/</a></p>
</blockquote>
<p>我在本次项目中独自担任程序，使用Unity引擎负责了全部代码的编写</p>
<h2 id="小组成员">小组成员</h2>
<ul>
<li>
<p>策划：戴子逸、林弘涛</p>
</li>
<li>
<p>程序：伍泽华</p>
</li>
<li>
<p>美术：酷灰啃鸡、二狗、水水</p>
</li>
</ul>
<h2 id="游戏简介">游戏简介</h2>
<p>想想北京的冬天吧！当你从寒冷的户外走入温暖的室内，当你脱下你的大棉袄，想和舍友击掌——啪！的一下，静电把人电麻了。这种TOUCH真是令人影响深刻。</p>
<p>在我们的游戏中，我们尝试去还原这一种生活经历：主角要和其他人TOUCH来积攒静电，再去TOUCH别人去电他们。</p>
<p>TOUCH既是过程，也是目的。</p>
<p>希望大家都能够享受这种令人影响深刻的“TOUCH”</p>
<h2 id="截图">截图</h2>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307161603087.webp" alt="img"></p>
<p><img src="https://files.gmhub.com/storage/upload/hYjVX1ws7olyqOOGhz57oGULQU6pTz0wiXeDtmnt.png.webp" alt="img"></p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity-Timeline】学习笔记</title>
    <url>/posts/106/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202312182321194.jpg" alt="Unity_Timeline"></p>
<h1>Timeline：强大的可视化流程控制工具</h1>
<blockquote>
<p>官方文档：<a href="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.html">https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.html</a></p>
</blockquote>
<hr>
<h2 id="前言">前言</h2>
<p><code>Timeline</code>是Unity中的一个强大的可视化工具，用于创建、编辑和控制复杂的时间线动画和剧情序列，可以轻松实现剪辑、动画、特效和音频的精确时间控制和协调</p>
<p>而从笔者目前的了解来说，<code>Timeline</code>可以做的远不止“做剧情过程”这么简单，其本质上是一个强大的可视化时间轴控制器，我们可以通过其实现一定程度的流程控制，即从某一时刻开始以既定序列执行一系列事件，而得益于其提供了可供自定义的接口，这个“事件”的定义可以非常广泛，如可以用其实现：<code>在玩家按下开火键后立刻触发一个粒子特效，3帧后，生成子弹预制体，1秒后播放玩家动画</code>之类的效果</p>
<p>如果只从这个角度来说，<code>Animation</code>组件也可以实现这一效果，但其只能承载一些比较简单的流程控制，并且可视化编辑体验并不算好；而<code>Timeline</code>相比来说更加强大，可供拓展的范围更广，并且可以实现一定程度的节点复用，在可视化编辑体验上来说也更加现代；同时，<code>Timeline</code>也可以很好地和原先的<code>Animation</code>系统交互</p>
<p>之前在Unity中，若要在不借助第三方插件的前提下进行较为精确的时间轴控制，往往使用协程或难用的<code>Animation</code>，而<code>Timeline</code>可以说补足了Unity功能的一大空缺，可以说非常强大了</p>
<hr>
<h2 id="Timeline概念概述">Timeline概念概述</h2>
<h3 id="运作方式：Timeline与Animation">运作方式：Timeline与Animation</h3>
<p>在整体的运作方式上，<code>Timeline</code>与<code>Animation</code>非常相像；在使用<code>Animation</code>时，我们需要创建<code>Animation Clip</code>资源文件，并在对应物体上挂载<code>Animation</code>/<code>Animator</code>组件，通过组件驱动<code>Animation Clip</code>进行播放；而<code>Timeline</code>与其几乎一样，我们需要创建<code>Timeline</code>资源文件，并在物体上挂载<code>Playable Director</code>组件，通过其来驱动<code>Timeline</code>进行播放</p>
<p>而二者不同的地方在于，<code>Animation</code>在设计上是与挂载了<code>Animation</code>/<code>Animator</code>组件物体高度相关的，即动画应该是属于某一物体的，一段主角身上的动画应该是属于主角的，其应该只影响主角，我们当然也可以通过一些手段让其控制其他物体，但总的来说很不方便也很不优雅；而在<code>Timeline</code>中，<code>Playable Director</code>正如其名只是一个“导演”，其只承担<code>Timeline</code>的驱动和管理，而可以不与<code>Timeline</code>所影响的物体相关，即导演在大部分情况下不会参演其导演的作品，这赋予了<code>Timeline</code>无比的自由度，你可以在其中控制场景中的一切</p>
<h3 id="构成方式：Track-Clip">构成方式：Track - Clip</h3>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202312300219644.png" alt="image-20231230021929575" style="zoom: 67%;" />
<p>了解了<code>Timeline</code>的大体运作方式后，我们该认识一个<code>Timeline</code>的构成了；实际上，如果你了解或使用过任何视频剪辑软件，如：PR、达芬奇，你便会对<code>Timeline</code>的结构一目了然，<code>Timeline</code>的构成方式与视频剪辑软件非常相似</p>
<p><strong>Track</strong>：</p>
<ul>
<li>一个<code>Timeline</code>由0~N个<code>Track</code>构成，<code>Track</code>是一个无限长的时间轴，一个<code>Timeline</code>中的所有<code>Track</code>共用一个时间轴</li>
<li><code>Track</code>的存在允许我们方便地管理多个物体的行为，如我们希望A物体在1.0s出现、3.0s小时，B物体在2.0s出现、4.0s消失，我们便可以使用两个<code>Track</code>来实现这点</li>
<li><code>Track</code>有不同的类型，其描述了<code>Track</code>的基本功能，Unity已经为我们提供了一些预制好的<code>Track</code>，如最基本的<code>Activation Track</code>便是控制一个物体的<code>Active</code>状态的</li>
</ul>
<p><strong>Clip</strong>：</p>
<ul>
<li>
<p>一个<code>Track</code>由0~N个<code>Clip</code>构成，<code>Clip</code>是一个有开始时间和结束时间的区块，其存在于<code>Track</code>之上，当时间运行到对应<code>Clip</code>时，其便会执行对应行为</p>
</li>
<li>
<p><code>Clip</code>允许我们对物体的状态在时间轴上进行精确的并行的控制，其与<code>Track</code>的结合可以很好地帮助我们实现想要的效果</p>
</li>
</ul>
<p><strong>需要注意的是，Track和Clip本身实际上都不具有具体的功能，它们都是回调的触发者，真正的逻辑位于Behavior之上，这点在后续的自定义Track部分会详细说明</strong></p>
<hr>
<h2 id="各默认Track介绍">各默认Track介绍</h2>
<h3 id="Activation-Track"><code>Activation Track</code></h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401072301841.png" alt="image-20240107230145773"></p>
<p><code>Activation Track</code>用于在特定时间启用或禁用游戏对象</p>
<p>Track上可以绑定一个<code>GameObject</code>对象（这一对象最好不是Director，禁用Director将会终止Timeline的播放），一个<code>Activation Track</code>只能控制一个对象；Clip则决定了对象显隐的具体时间</p>
<p><em><strong>需要注意的是，Clip在设计上是从属于Track的，从抽象层来说不应该访问Track上的数据（被控制对象的引用是绑定在Track上的），此处实际上使用了<code>Track Mixer</code>进行实现，在后续的自定义Track部分会详细说明</strong></em></p>
<h3 id="Animation-Track"><code>Animation Track</code></h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401072311002.png" alt="image-20240107231151968"></p>
<p><code>Animation Track</code>用于播放Animator控制器上的动画片段（<code>Animation Clip</code>）</p>
<p>Track上可以绑定一个<code>Animator</code>对象，Clip则由对象的动画片段构成；同时，Track上实现了<code>Track Mixer</code>，我们可以将两个的Clip进行重叠，实现动画的平滑过渡，并且自由地编辑过渡曲线</p>
<h3 id="Audio-Track"><code>Audio Track</code></h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401072320908.png" alt="image-20240107232004861"></p>
<p><code>Audio Track</code>用于控制音频的播放</p>
<p>Track上可以绑定一个<code>Audio Source</code>对象，该对象用于播放音频；而Clip则是具体需要播放的音频片段（<code>Audio Clip</code>）；同时，其也实现了<code>Track Mixer</code>，我们可以将两个的Clip进行重叠，实现音频的平滑过渡，并且自由地编辑过渡曲线</p>
<h3 id="Control-Track"><code>Control Track</code></h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401072326535.png" alt="image-20240107232611495"></p>
<p><code>Control Track</code>允许你控制其他<code>Player Director</code>的播放，可以用来触发其他Timeline</p>
<p>其Track上没有数据，Clip则由其他<code>Player Director</code>构成</p>
<h3 id="Playable-Track"><code>Playable Track</code></h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401072328418.png" alt="image-20240107232843380"></p>
<p><code>Playable Track</code>较为特殊，其本身没有实际的逻辑，但其可以驱动自定义Clip</p>
<p>当我们想进行一定程度的自定义，但不需要用到Track时，我们便可以只自定义Clip，并在<code>Playable Track</code>对其进行应用</p>
<h3 id="Signal-Track"><code>Signal Track</code></h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401072332456.png" alt="image-20240107233201429"></p>
<p><code>Signal</code>是Timeline中内置的“事件系统”，其基于观察者模式进行搭建，如果你有使用过事件中心，那么你便能很快上手这个概念</p>
<p>在使用它时，我们需要先右击创建后缀为<code>.signal</code>的资产文件，这相当于事件系统中的“事件”，需要注意的时，其本身不具有逻辑，其只是一个“概念”，一个逻辑的容器</p>
<p>之后我们需要在事件作用的对象身上创建<code>Signal Receiver</code>组件，在其之上，我们便可以在<code>Inspector</code>中对需要触发的事件进行绑定，如下图所示</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401072338800.png" alt="image-20240107233841768"></p>
<p>这一组件是时间的“订阅者”，需要注意的是，<code>Signal</code>在这一过程中是可以被复用的，一个<code>Signal</code>可以被绑定给多个<code>Reveiver</code></p>
<p>之后，我们便可以右击Track，选择<code>Add Signal Emitter</code>，当Track运行到该节点时，对应<code>Signal</code>便会被触发</p>
<p>事实上，我们可以在任何Track上添加<code>Signal Emitter</code>，而独立出来的<code>Signal Track</code>或许是希望让<code>Signal</code>的触发更加容易管理</p>
<p><em>Signal系统由于基于Timeline而生，在某些情况下并不那么好用，因其只支持在Inspector中进行事件的绑定，有时然而会让事情变得复杂，难以管理，或许我们可以在之后使用自定义Track功能创建自己的事件系统</em></p>
<h3 id="Cinemachine-Track"><code>Cinemachine Track</code></h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401072348212.png" alt="image-20240107234802182"></p>
<p>这并不是Timeline中自带的功能，其由<code>Cinemachine</code>插件提供</p>
<p>其可以非常方便地通过Timeline控制<code>Cinemachine</code>中的虚拟相机，是个非常强大便捷的功能</p>
<p><code>Cinemachine</code>不是本文的主角，故此处对其用法不过多赘述</p>
<hr>
<h2 id="自定义Track">自定义Track</h2>
<h3 id="概述">概述</h3>
<p>接下来终于来到了个人认为Timeline中最激动人心的部分：强大的自定义功能</p>
<p>Unity为我们提供了<code>TrackAsset</code>、<code>PlayableAsset</code>与<code>PlayableBehaviour</code>三个类与一些接口，通过继承它们，我们便可以实现对于Track的完全自定义</p>
<p><em>上面介绍过的Timeline提供的默认Track也都是通过这些类实现的，其没有被写在Unity内核中，这也意味着我们可以在项目中直接找到实现它们的C#代码，这相当于官方范例，我想这可以给我们的自定义带来很大的帮助</em></p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401082030081.png" alt="image-20240108203042955"></p>
<p>上图展示了一个完整Track的基本构成方式（括号中是它们背后的类）</p>
<ul>
<li>
<p><code>PlayerBehaviour</code>是承载具体逻辑的基类，其具有多个回调，如<code>OnBehaviourPlay</code>（开始调用时）、<code>ProcessFrame</code>（每个逻辑帧）等；其既可以绑定在Clip上也可以由Track创建</p>
</li>
<li>
<p><code>PlayableAsset</code>是Clip的基类，实现其<code>CreatePlayable</code>函数即可将一个<code>PlayerBehaviour</code>与其绑定，从而触发<code>PlayerBehaviour</code>中的回调函数</p>
</li>
<li>
<p><code>TrackAsset</code>是Track的基类，其定义了一个Track的方方面面，包括Track上绑定的物体的类型、Track上Clip的类型、Track的颜色等；而实现<code>CreateTrackMixer</code>可以将一个<code>PlayerBehaviour</code>与其绑定，我们通常称其为Mixer，其可以访问整个Track上的绑定对象与其中的Clip的数据；尽管绑定在Clip上的<code>PlayerBehaviour</code>实际上也可以获取到Track上的绑定对象，但从面向对象的角度出发，和Track绑定对象相关的逻辑应该写在Mixer中，同时Mixer也负责处理Clip之间的融合逻辑，例如默认Track中的<code>Animation Track</code>与<code>Audio Track</code>便实现了对应功能</p>
</li>
</ul>
<h3 id="具体实现">具体实现</h3>
<h4 id="Track类">Track类</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Timeline</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TrackColor(0.5f, 0.5f, 0.5f)</span>]          <span class="comment">// Track颜色</span></span><br><span class="line">    [<span class="meta">TrackClipType(typeof(CustomClip))</span>]     <span class="comment">// Track上的Clip类型</span></span><br><span class="line">    [<span class="meta">TrackBindingType(typeof(GameObject))</span>]  <span class="comment">// Track上的绑定对象类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomTrack</span> : <span class="title">TrackAsset</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// inputCount即为Track上的Clip数量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Playable <span class="title">CreateTrackMixer</span>(<span class="params">PlayableGraph graph, GameObject go, <span class="built_in">int</span> inputCount</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ScriptPlayable&lt;CustomMixer&gt;.Create(graph, inputCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Clip类">Clip类</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Timeline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomClip</span> : <span class="title">PlayableAsset</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Playable <span class="title">CreatePlayable</span>(<span class="params">PlayableGraph graph, GameObject owner</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ScriptPlayable&lt;CustomBehavior&gt;.Create(graph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Behavior类">Behavior类</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Timeline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomBehavior</span> : <span class="title">PlayableBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBehaviourPlay</span>(<span class="params">Playable playable, FrameData info</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;OnBehaviourPlay&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBehaviourPause</span>(<span class="params">Playable playable, FrameData info</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;OnBehaviourPause&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ProcessFrame</span>(<span class="params">Playable playable, FrameData info, <span class="built_in">object</span> playerData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;OnBehaviourProcessFrame&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mixer类">Mixer类</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Timeline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomMixer</span> : <span class="title">PlayableBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> GameObject _boundObject;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBehaviourPlay</span>(<span class="params">Playable playable, FrameData info</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;OnMixerPlay&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBehaviourPause</span>(<span class="params">Playable playable, FrameData info</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;OnMixerPause&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ProcessFrame</span>(<span class="params">Playable playable, FrameData info, <span class="built_in">object</span> playerData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果_boundObject为空则尝试获取绑定对象</span></span><br><span class="line">            _boundObject ??= playerData <span class="keyword">as</span> GameObject;</span><br><span class="line">            <span class="keyword">if</span> (_boundObject == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> inputCount = playable.GetInputCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; inputCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取融合权重</span></span><br><span class="line">                <span class="keyword">var</span> weight = playable.GetInputWeight(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取当前Clip</span></span><br><span class="line">                <span class="keyword">var</span> clipPlayable = (ScriptPlayable&lt;CustomBehavior&gt;)playable.GetInput(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取Clip上的Behavior</span></span><br><span class="line">                <span class="keyword">var</span> behavior = clipPlayable.GetBehaviour();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// do something......</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Debug.Log(<span class="string">&quot;OnMixerProcessFrame&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Unity</tag>
        <tag>Timeline</tag>
      </tags>
  </entry>
  <entry>
    <title>《Revive》-UE GameJam 2022</title>
    <url>/posts/1/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261605787.png" alt="Logo"></p>
<h1>Revive</h1>
<blockquote>
<p><strong>介绍视频</strong>：<a href="https://www.bilibili.com/video/BV1p44y1Q7tY/">https://www.bilibili.com/video/BV1p44y1Q7tY/</a></p>
</blockquote>
<p>我在本次项目中担任程序，使用Unity引擎负责了部分代码的编写</p>
<h2 id="小组成员">小组成员</h2>
<p><strong>新发地农贸批发市场</strong>：</p>
<ul>
<li>
<p>程序：李健豪、<strong>伍泽华</strong></p>
</li>
<li>
<p>美术：成可</p>
</li>
<li>
<p>音乐：赵永炜</p>
</li>
<li>
<p>文案：孙诗佳</p>
</li>
</ul>
<h2 id="游戏主题">游戏主题</h2>
<blockquote>
<p><em>“I shall die again and again to know that life is inexhaustible. ”</em></p>
<p><em>——泰戈尔《飞鸟集》</em></p>
</blockquote>
<p>作为人类，我们的生命是有限的。然而，我们体内的基因会一直随着我们的繁衍不断延续下去。“基因既是遗传的基本单位，也是自然选择的基本单位。”在道金斯《自私的基因》一书中，他指出，基因的本质是自私的，它们控制生物的各种行为活动，只为了自己更多更快速地复制，以达到不断地延续。</p>
<p>以母亲十月怀胎为例，母子之间**并非和平共生，而是不断的抗争。**母体为了延续自己的基因而生育，但在胎儿的成长之中，他不断吸取甚至掠夺养分，不顾母体死活保证自己的存活和生长。与此同时，为了防止自身的死亡，母体也会时刻警惕胎儿，保证自己排异的权利，一旦胎儿吸取过多营养或产生不健康反应，就会立刻停止供应排出婴儿。</p>
<p>基因一直是自私的，胎儿的基因无意识地只以生存为目的伤害了母体，然而成长之后自己成为母亲却又被伤害，目睹死亡到自己接受死亡，被延续到自己继续延续，一次一次的生命的继承即是<strong>Revive</strong>，在不断的死中明白生的无穷尽。</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261616467.png" alt="Snipaste_2023-03-26_16-12-31"></p>
<h2 id="游戏玩法">游戏玩法</h2>
<p>游戏共有三个关卡，主要以WASD进行操作**。**玩家将操控一个球体，在游玩中，球体将不断成长，其寓意着生命由精子—受精卵—胚胎的发展，最后长成婴儿出生。玩家逐步完成关卡的过程，实际就是胎儿与母体斗争伤害直至出生离开母体的过程。游戏将营造一个较为抽象的形象，并不会直接体现具体要素，只有在完成三个关卡后，游戏的真面目才会真正揭开。</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261616505.png" alt="Snipaste_2023-03-26_16-13-31"></p>
<h2 id="关卡设计">关卡设计</h2>
<p>**（1）   第一关：**模拟受精卵的形成。玩家将操控代表精子的球体在类似输卵管的地图中不断前行，以接近卵子进行结合。但过程中将会有障碍：紫色粘液代表受到子宫颈粘液的阻挡，玩家经过会减缓速度；白色晶体会在一定范围内追踪玩家，如果被追上将会被吞食，关卡将重新开始。玩家需操控角色躲避，顺利到达终点，完成精卵结合。</p>
<p>**（2）   第二关：**模拟受精卵从母体中汲取养分。玩家需操控球体吞食周边的养料，以不断壮大自身，同时也要暂时避开难以吞食的养分。使用空格键可以短暂加速，但使用一次后需要时间恢复体力。每当有养料被吞食时，都会出现血丝，意为从母体获得的养分对母体的伤害。地图二进制的设计代表计算机语言的最初始，也体现着当今科技时代的初始，亦与生命的开始相呼应，连接着虚拟与现实。当球体壮大到一定程度时，将自动进入下一关。</p>
<p>**（3）   第三关：**模拟胎儿反向输送激素，榨取更多能量。玩家以AD键操作，当白球到判定线时需按下D，红球即为A，每连击一次加一分，掉落一次减一分，达到一定分数时，背景将会发生变化，树的根会越来越多越来越长，下落速度也会发生变化，同时传出流血音效，意为血管扎根和对母体心跳加速的影响。完成激素输送，游戏结束，迎来婴儿诞生。</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261616278.png" alt="Snipaste_2023-03-26_16-15-14"></p>
<h2 id="美术风格">美术风格</h2>
<p>整体美术风格以黑白为主，中间穿插红蓝等饱和度较低的色调，体现真相的残忍。背景以母体生育器官为基础，为保留神秘性并非完全具象，进行了艺术加工。主角球体的采用也寓意着基因的不断延续，宿命的不断轮回。</p>
<h2 id="音乐风格">音乐风格</h2>
<p>游戏背景音乐采用纯钢琴演奏，在悲伤静谧的氛围中感受生命的残忍和基因的自私，迎合游戏主题，叙事感较强。</p>
<h2 id="创意理念">创意理念</h2>
<p>灵感来源即为《自私的基因》一书。游戏策划过程中，关于机制均参考了胚胎的形成和发育过程，并体现出其在成长过程中对母体的伤害。制作过程中，第一关地图以输卵管为基础进行加工，使其更加扭曲和抽象，迎合游戏氛围；第二关活动区域模拟子宫环境，以人体所需葡萄糖为养料之一进行设计；第三关，以不断长大的胎儿作为树冠，以逆卡巴拉生命树象征反输送激素，不顾母体安危。红键象征流血，而白键象征生命延续的希望，体现出母体受伤和基因延续的矛盾性。胚胎反向输送激素时，母体的流血会增加，即为音效采用流血的原因；心跳会加速，也是判定线采用心电图的原因。</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303261616663.png" alt="Snipaste_2023-03-26_16-16-02"></p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2022</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>《Just Suck.》-吉比特GameJam2023</title>
    <url>/posts/8/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202311010242672.jpeg" alt="img"></p>
<h1>JUST SUCK.</h1>
<blockquote>
<p><strong>演示视频：<a href="https://www.bilibili.com/video/BV1aN41137tc/">https://www.bilibili.com/video/BV1aN41137tc/</a></strong></p>
<p><strong>介绍视频：<a href="https://www.bilibili.com/video/BV1uN4y1a75f/">https://www.bilibili.com/video/BV1uN4y1a75f/</a></strong></p>
<p><strong>项目地址：<a href="https://github.com/JBT-GameJam-23/JustSuck">https://github.com/JBT-GameJam-23/JustSuck</a></strong></p>
</blockquote>
<p>我在本次项目中独自担任程序，使用Unity引擎负责了全部代码的编写</p>
<p>在本次比赛中，我们的作品获得了<strong>三等奖</strong></p>
<h2 id="小组成员">小组成员</h2>
<ul>
<li>
<p>策划：顾宸彦、林繁森</p>
</li>
<li>
<p>程序：<strong>伍泽华</strong></p>
</li>
<li>
<p>美术：王嘉誉</p>
</li>
<li>
<p>音效：马小龙Matti</p>
</li>
</ul>
<h2 id="游戏简介">游戏简介</h2>
<p>本次GameJam以“吸收”作为主题展开，我们选择了极简的设计风格，将“吸”作为唯一的玩法，尽量减少多余画面元素的堆砌，同时辅以大量音效、动效作为玩家操作的反馈，以为玩家带来独特的游戏体验</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202312182356619.png" alt="image-20231218235608482"></p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202312182356792.png" alt="image-20231218235624709"></p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>《SCP》-游戏创作1 week3</title>
    <url>/posts/5/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305221534305.jpg" alt="SCP"></p>
<h1>SCP</h1>
<blockquote>
<p><strong>项目地址</strong>：<a href="https://github.com/hmxsqaq/Unity-SCP">https://github.com/hmxsqaq/Unity-SCP</a></p>
</blockquote>
<p>我在本次项目中独自担任程序，使用Unity引擎负责了全部代码的编写</p>
<h2 id="小组成员">小组成员</h2>
<ul>
<li>
<p>策划：杜修臣</p>
</li>
<li>
<p>程序：<strong>伍泽华</strong></p>
</li>
<li>
<p>美术：魏可欣</p>
</li>
<li>
<p>音效：高祎祎、王菲阳</p>
</li>
</ul>
<h2 id="游戏简介">游戏简介</h2>
<p>这是一款基于Unity的2D恐怖游戏，【游戏创作1】课程第三周的小组作业，围绕拍卖到的主题“SCP”进行展开</p>
<p>故事发生在SCP收容失败的背景下，玩家可以通过W/A/S/D控制侥幸存活的D级人员，与各类物品进行交互</p>
<p>途中玩家会遇到各类SCP，运用你的知识与手段逃出去吧！</p>
<h2 id="截图">截图</h2>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305221535994.png" alt="截图1"></p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305221535175.png" alt="截图2"></p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305221535877.png" alt="截图3"></p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>《联机象棋》-游戏编程实训</title>
    <url>/posts/4/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307161608249.png" alt="image-20230716150851155" style="zoom: 80%;" />
<h1>联机象棋</h1>
<blockquote>
<p><strong>项目地址</strong>：<a href="https://github.com/hmxsqaq/C-ChineseChessWithLAN">https://github.com/hmxsqaq/C-ChineseChessWithLAN</a></p>
</blockquote>
<p>我在本次项目中担任程序，使用C++Socket实现了局域网p2p联机，同时完成了棋子合法性判断的逻辑</p>
<h2 id="小组成员">小组成员</h2>
<ul>
<li>
<p>伍泽华：负责网络模块、棋子合法性判断</p>
</li>
<li>
<p>李建豪：负责游戏前端、游戏流程</p>
</li>
</ul>
<h2 id="游戏简介">游戏简介</h2>
<p>一款可局域网联机的中国象棋游戏</p>
<p>局域网联机功能通过C语言Socket实现</p>
<p>游戏前端通过EasyX图形库呈现</p>
<p>大学生练习作品</p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>《辟邪傩狮》-游戏创作1结课</title>
    <url>/posts/6/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307161452197.png" alt="image-20230716135205003" style="zoom: 67%;" />
<h1>辟邪傩狮</h1>
<blockquote>
<p><strong>游玩视频</strong>：<a href="https://www.bilibili.com/video/BV1Su411t7b8/">https://www.bilibili.com/video/BV1Su411t7b8/</a></p>
</blockquote>
<p>我在本次项目中独自担任程序，使用Unity引擎负责了全部代码的编写</p>
<h2 id="小组成员">小组成员</h2>
<ul>
<li>
<p>组长、策划：沈品旭</p>
</li>
<li>
<p>策划：谢承子昂</p>
</li>
<li>
<p>程序：<strong>伍泽华</strong></p>
</li>
<li>
<p>美术：夏子茹</p>
</li>
<li>
<p>美术：郭宜林</p>
</li>
<li>
<p>指导老师：陈京炜老师、张梦雨老师、王巍寅老师</p>
</li>
</ul>
<h2 id="游戏简介">游戏简介</h2>
<p>《辟邪傩狮》是一款2d平台跳跃游戏，玩家扮演除夕夜披着舞狮服出逃的少女歌沂，在一只会说话的石狮子的指引下，探寻爷爷作为老舞狮队成员生前的秘密。</p>
<p>**亮点：**将传统舞狮文化合理游戏化，可爱的舞狮小姑娘！！！</p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>《AssAssIn》-游戏创作2结课</title>
    <url>/posts/11/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211639045.png" alt="宣传图5" style="zoom:50%;" />
<h1>AssAssIn</h1>
<blockquote>
<p><strong>演示视频</strong>：<a href="https://www.bilibili.com/video/BV1Kr421A7tC/">https://www.bilibili.com/video/BV1Kr421A7tC/</a></p>
<p><strong>项目地址</strong>：<a href="https://github.com/GameCreation2-2024-NoName/AssAssInPro">https://github.com/GameCreation2-2024-NoName/AssAssInPro</a></p>
</blockquote>
<h2 id="小组成员">小组成员</h2>
<ul>
<li>策划：<a href="https://space.bilibili.com/423851637">@gu0kke </a>、<a href="https://space.bilibili.com/178969683">@夜之凝殇_</a></li>
<li>程序：<a href="https://space.bilibili.com/89364405">@紫地丁Pditine </a>、<a href="https://space.bilibili.com/11752174">@徽墨行深</a></li>
<li>美术：<a href="https://space.bilibili.com/26404651">@Starlight点点 </a>、<a href="https://space.bilibili.com/505778653">@无骨小鸡</a></li>
</ul>
<h2 id="游戏简介">游戏简介</h2>
<blockquote>
<p>“互戳”即是正义。	——“AssAssIn”之王</p>
</blockquote>
<p>在一个遥远之地，每个生灵都由“刺”和“ASS”两部分构成。“刺”坚硬锋利，是每个生灵独一无二的武器；“ASS”脆弱不堪，是每个生灵的动力之源、生命之本。在如此独特结构的影响下，这片大地演变出了一项最为盛大的竞技项目“AssAssIn”——双方在竞技场中横冲直撞，用自己的“刺”戳爆对方的“ASS”！每一位生灵都为了能成为这项竞技的胜者而不断努力，在这片场地中肆意碰撞，避免“ASS”被戳爆，直至仅剩自己屹立于竞技场之上。</p>
<p>扮演一位“AssAssIn”大赛的参赛者，利用独特的冲刺技巧和场地中不断生成的能量球，在不同的竞技场中与对手战斗。觉得自己太过平庸？没关系！改造自身的“刺”和“ASS”是每一位参赛者的权利。找到适合自己的身体与战斗技巧，在大赛中不断胜利，成为“AssAssIn”之王！</p>
<p>《AssAssIn》是一款以双人对战模式为核心的2D派对游戏。你需要在这片虚拟的竞技场中戳爆每一个在你面前的“ASS”，甚至它的所有者就坐在你的旁边。将自己的“刺”磨砺为最坚韧的“刺”，将自己的“ASS”保护得密不透风，将每一次冲撞视作必中的一击：你无敌了，孩子。</p>
<p>当然，如果对一次次“AssAssIn”比赛后的现实世界“真人快打”感到厌倦，你可以试试一些攻击性并没有那么强的竞技项目：足球大战、竞速比赛、涂色攻坚……不过，一切仍在开发中。</p>
<p><strong>冲刺、碰撞、戳爆、胜利</strong>、你将在《AssAssIn》中获得难以忘怀的快乐体验。</p>
<h2 id="游戏特色">游戏特色</h2>
<ul>
<li>别出心裁的双人娱乐竞技：随时叫上三五好友，在虚拟的游戏世界中以冲刺的方式戳爆朋友的“ASS”，看看谁才是真正的“AssAssIn”之王！</li>
<li>简单易懂的操作模式：仅需最多两个按键即可流畅操作，让你随时感受最纯真的派对游戏体验。（目前游玩双人本地模式必须接入手柄）</li>
<li>风格多样的装备系统：可供任意选择的多种“刺”和“ASS”，各有自身独特之处。随意搭配，自由组合。找寻最喜爱的一对“刺”与“ASS”，以属于自己的方式取得游戏的胜利。</li>
<li>精心设计的竞技场地：每一个地图都有着各自的地图特性。利用好每一个竞技场的特点，你会在比赛中取得巨大优势。也许了解全部的竞技场，才能算是“AssAssIn”之王。</li>
</ul>
<h2 id="游戏截图">游戏截图</h2>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211641753.png" alt="宣传图2"></p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211641832.png" alt="宣传图3"></p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211641044.png" alt="宣传图1"></p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2024</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>《BlindTrust》-游戏创作2 week3</title>
    <url>/posts/10/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211628143.jpeg" alt="img" style="zoom:50%;" />
<h1>BlindTrust</h1>
<blockquote>
<p><strong>演示视频</strong>：<a href="https://www.bilibili.com/video/BV1yx4y1e7Eo/">https://www.bilibili.com/video/BV1yx4y1e7Eo/</a></p>
<p><strong>项目地址</strong>：<a href="https://github.com/GameCreation2-2024-NoName/Blind-Trust">https://github.com/GameCreation2-2024-NoName/Blind-Trust</a></p>
</blockquote>
<h2 id="小组成员">小组成员</h2>
<ul>
<li>策划：<a href="https://space.bilibili.com/423851637">@gu0kke </a>、<a href="https://space.bilibili.com/178969683">@夜之凝殇_</a></li>
<li>程序：<a href="https://space.bilibili.com/89364405">@紫地丁Pditine </a>、<a href="https://space.bilibili.com/11752174">@徽墨行深</a></li>
<li>美术：<a href="https://space.bilibili.com/26404651">@Starlight点点 </a>、<a href="https://space.bilibili.com/505778653">@无骨小鸡</a></li>
</ul>
<h2 id="游戏简介">游戏简介</h2>
<p>这是一个简易的模拟盲人出行的略有一些些严肃向的游戏，两位玩家分别饰演盲人与导盲犬，在没有牵引绳的情况下，盲人是否能完全信任导盲犬的指引？导盲犬又是否能指引主人找到正确的道路？一切的结局，都取决于玩家自己的行为……</p>
<p>“满头大汗了家人们”，“这么难的吗这玩意”，“太可怕了”……当你真的看不见这个世界，走在路上，你才能体会到，黑暗中，手脚和内心的无助。这些我们仅仅只体验了几分钟的困难，也许就是视障人群的一辈子。希望我们都能尊重视障人群的生活，从不占用盲道这些点滴小事做起！！</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211629783.png" alt="image-20240721162946624" style="zoom:50%;" />
]]></content>
      <categories>
        <category>Projects</category>
        <category>2024</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>《吹气球》-游戏创作2 week1</title>
    <url>/posts/9/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202407211553628.png" alt="image-20240721155347372" style="zoom:50%;" />
<h1>吹气球</h1>
<blockquote>
<p><strong>演示视频</strong>：<a href="https://www.bilibili.com/video/BV1ZD42177Gp/">https://www.bilibili.com/video/BV1ZD42177Gp/</a></p>
<p><strong>项目地址</strong>：<a href="https://github.com/hmxsqaq/Unity-BlowUpTheFxxkingBalloon">https://github.com/hmxsqaq/Unity-BlowUpTheFxxkingBalloon</a></p>
</blockquote>
<p>我在本次项目中独自担任程序，使用Unity引擎负责了全部代码的编写</p>
<h2 id="小组成员">小组成员</h2>
<ul>
<li>策划：<a href="https://space.bilibili.com/423851637">@gu0kke</a></li>
<li>程序：<a href="https://space.bilibili.com/11752174">@徽墨行深</a></li>
<li>特效：<a href="https://space.bilibili.com/26404651">@Starlight点点</a></li>
<li>美术：<a href="https://space.bilibili.com/505778653">@无骨小鸡</a></li>
<li>音乐：<a href="https://space.bilibili.com/178969683">@夜之凝殇_</a></li>
</ul>
<h2 id="游戏简介">游戏简介</h2>
<p>如果你无聊的话，那就来吹气球吧！！</p>
<p>这是一个十分简单的吹气球模拟器，你只需要按住屏幕，即可为气球吹气！气球抖动的频率会暗示气球什么时候爆炸哦～ 我们不给游戏本身设定任何规则。</p>
<p>作为一个派对游戏“道具”，玩家可以自行设定任何自己喜欢的规则，无论是轮流吹气球到谁那吹爆了谁输，还是往上叠加回合计时、微操计分等规则，只要享受开心瞬间就好！o(≧v≦)o</p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2024</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的C++软光栅渲染器</title>
    <url>/posts/12/</url>
    <content><![CDATA[<h1>从零开始的C++软光栅渲染器开发</h1>
<blockquote>
<p>项目地址：<a href="https://github.com/hmxsqaq/Graphics-TinyRenderer">https://github.com/hmxsqaq/Graphics-TinyRenderer</a></p>
<p>GitHub中有更加详细的英语项目文档与实时更新的项目源码</p>
<p><em>这个项目是我进行图形学学习的起点，存在着诸多不完善与我自己不满意的地方，我正在基于<code>Win32API</code>对项目进行重构，感兴趣的话可以查看<a href="https://github.com/hmxsqaq/HmxsRenderer">这里</a></em></p>
</blockquote>
<h2 id="概述">概述</h2>
<p>这是一个基于 <a href="https://github.com/ssloy/tinyrenderer/wiki">tinyrenderer</a> 的微型 C++ 软光栅渲染器，可以读取<code>.obj</code>模型文件与<code>.tga</code>纹理图像，对模型进行渲染后将结果输出到<code>.tga</code>文件中</p>
<p>我的目标是创建一个不依赖任何第三方库的足够灵活的渲染器，在这一实践中我会亲自编写从最基础的几何数学库到光栅化渲染器的全部代码，在这一过程中，我可以全面地了解并控制渲染器中的一切，提升自己对图形学、C++与软件架构设计的理解，这对我之后的学习大有裨益。</p>
<p>以下是一些输出图片的例子：</p>
<p><em>因为md不支持原生显示tga图片，为方便展示，这里的图片经由外部转换为了png格式</em></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202406202341390.png" alt="image-20240620234127293" style="zoom: 25%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202406202345553.png" alt="african_head_gouraud_shader" style="zoom: 25%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202406202345558.png" alt="african_head_static_layer_value_shader" style="zoom: 25%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202406202351974.png" alt="boggie" style="zoom: 25%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202406202351979.png" alt="diablo3_tangent_shader" style="zoom: 25%;" />
<h2 id="特性">特性</h2>
<ul>
<li>[x] 无第三方库依赖</li>
<li>[x] 小型灵活的架构</li>
<li>[x] 自建几何库（向量与矩阵操作）</li>
<li>[x] <code>.obj</code> 模型读取</li>
<li>[x] <code>.tga</code> 图片读取与写入（带 RLE 压缩算法）</li>
<li>[x] 线段绘制</li>
<li>[x] 重心坐标计算</li>
<li>[x] 三角形光栅化</li>
<li>[x] 深度缓冲</li>
<li>[x] 法线贴图</li>
<li>[x] 纹理映射</li>
<li>[x] Phong 着色</li>
<li>[x] 可定制的着色器</li>
<li>[ ] 阴影映射</li>
<li>[ ] 抗锯齿</li>
</ul>
<h2 id="架构">架构</h2>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202406202351924.png" alt="class_diagram"></p>
<ul>
<li><code>main.cpp</code></li>
</ul>
<p>这是程序的主渲染流程。</p>
<ol>
<li>定义基本信息，如图像大小、模型路径、相机等</li>
<li>加载模型和纹理</li>
<li>初始化渲染器与着色器</li>
<li>设置MVP矩阵和视口矩阵</li>
<li>渲染!!!</li>
<li>保存图像</li>
</ol>
<p>你可以在 <code>main.cpp</code> 文件中定义你自己的着色器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; object_infos = &#123;</span><br><span class="line">            <span class="comment">// R&quot;(..\model\african_head\african_head.obj)&quot;,</span></span><br><span class="line">            <span class="comment">// R&quot;(..\model\african_head\african_head_eye_inner.obj)&quot;,</span></span><br><span class="line">            <span class="comment">// R&quot;(..\model\diablo3_pose\diablo3_pose.obj)&quot;,</span></span><br><span class="line">            <span class="comment">// R&quot;(..\model\boggie\body.obj)&quot;,</span></span><br><span class="line">            <span class="comment">// R&quot;(..\model\boggie\eyes.obj)&quot;,</span></span><br><span class="line">            <span class="comment">// R&quot;(..\model\boggie\head.obj)&quot;,</span></span><br><span class="line">            <span class="string">R&quot;(..\model\cottage.obj)&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">const</span> std::string output_filename = <span class="string">&quot;../image/output.tga&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Renderer <span class="title">renderer</span><span class="params">(width, height, Color::RGB)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; model_path : object_infos) &#123;</span><br><span class="line">        <span class="function">Object <span class="title">object</span><span class="params">(model_path, &#123;<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>&#125;, <span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">set_model_mat</span>(object.angle, object.scale, object.position);</span><br><span class="line">        <span class="built_in">set_view_mat</span>(camera.position);</span><br><span class="line">        <span class="built_in">set_projection_mat</span>(camera.fov, camera.aspect_ratio, camera.zNear, camera.zFar);</span><br><span class="line">        <span class="function">GouraudShader <span class="title">shader</span><span class="params">(object.model, &#123;light1, light2&#125;)</span></span>;</span><br><span class="line">        renderer.<span class="built_in">draw_object</span>(object, shader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TGAHandler::<span class="built_in">write_tga_file</span>(output_filename,</span><br><span class="line">                               renderer.<span class="built_in">width</span>(),</span><br><span class="line">                               renderer.<span class="built_in">height</span>(),</span><br><span class="line">                               renderer.<span class="built_in">bpp</span>(),</span><br><span class="line">                               renderer.<span class="built_in">frame_data</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>geometry.h</code> 和 <code>color.h</code></li>
</ul>
<p>它们是基本的几何和颜色类，用于定义程序的基本数据结构。</p>
<p><code>geometry</code> 使用 <code>template</code> 定义了 <code>Vec&lt;int&gt;</code>、<code>Mat&lt;int, int&gt;</code> 类，用于表示向量和矩阵。它实现了一些基本的向量和矩阵操作，如 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 等，以及一些有用的函数，如 <code>cross()</code>、<code>normalize()</code>、<code>invert()</code>、<code>transpose()</code> 等。</p>
<p><code>color</code> 定义了 <code>Color</code> 类，用于表示图像的颜色，使用四位 <code>uint8_t</code> 存储颜色数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ColorFormat</span> &#123; GRAYSCALE = <span class="number">1</span>, RGB = <span class="number">3</span>, RGBA = <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    std::array&lt;std::<span class="type">uint8_t</span>, 4&gt; bgra = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// BLUE, GREEN, RED, alpha</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> std::<span class="type">uint8_t</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> i) <span class="keyword">noexcept</span> &#123; <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; <span class="number">4</span>); <span class="keyword">return</span> bgra[i]; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> std::<span class="type">uint8_t</span> <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> i) <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; <span class="number">4</span>); <span class="keyword">return</span> bgra[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> std::<span class="type">uint8_t</span> <span class="title">R</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> bgra[<span class="number">2</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> std::<span class="type">uint8_t</span> <span class="title">G</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> bgra[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> std::<span class="type">uint8_t</span> <span class="title">B</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> bgra[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> std::<span class="type">uint8_t</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> bgra[<span class="number">3</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Vec3 <span class="title">to_vec3</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123; <span class="built_in">R</span>() / <span class="number">255.0</span>, <span class="built_in">G</span>() / <span class="number">255.0</span>, <span class="built_in">B</span>() / <span class="number">255.0</span> &#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out, <span class="type">const</span> Color &amp;color) &#123;</span><br><span class="line">    out &lt;&lt;</span><br><span class="line">    <span class="string">&quot;R &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(color.<span class="built_in">R</span>()) &lt;&lt;</span><br><span class="line">    <span class="string">&quot; G &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(color.<span class="built_in">G</span>()) &lt;&lt;</span><br><span class="line">    <span class="string">&quot; B &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(color.<span class="built_in">B</span>()) &lt;&lt;</span><br><span class="line">    <span class="string">&quot; A &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(color.<span class="built_in">A</span>());</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Color <span class="keyword">operator</span>*(<span class="type">const</span> Color &amp;color, <span class="type">const</span> <span class="type">double</span> scalar) &#123;</span><br><span class="line">    Color result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        result[i] = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint8_t</span>&gt;(color[i] * scalar);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>texture.h</code> 和 <code>model.h</code></li>
</ul>
<p>它们用于加载纹理和模型。</p>
<p><code>texture</code> 定义了 <code>Texture</code> 类，存储纹理图像的颜色数据。并且它提供了 <code>get_color(uv)</code> 函数，让其他类可以在给定的 uv 坐标处获取纹理图像的颜色。</p>
<p><code>model</code> 定义了 <code>Model</code> 类，可以读取 <code>.obj</code> 模型文件并将其数据（顶点，面，纹理等）加载到内存中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Texture</span> &#123;</span><br><span class="line">    <span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint8_t</span> bpp = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::<span class="type">uint8_t</span>&gt; data = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Texture</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> <span class="type">int</span> _width, <span class="type">const</span> <span class="type">int</span> _height, <span class="type">const</span> std::<span class="type">uint8_t</span> _bpp)</span><br><span class="line">        : <span class="built_in">width</span>(_width), <span class="built_in">height</span>(_height), <span class="built_in">bpp</span>(_bpp), <span class="built_in">data</span>(_width * _height * _bpp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Color <span class="title">get_color</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>() || x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= width || y &gt;= height) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;get pixel fail: x &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Color ret = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">const</span> std::<span class="type">uint8_t</span> *pixel = data.<span class="built_in">data</span>() + (x + y * width) * bpp;</span><br><span class="line">        std::<span class="built_in">copy_n</span>(pixel, bpp, ret.bgra.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Color <span class="title">get_color</span><span class="params">(<span class="type">const</span> Vec2&amp; uv)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_color</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(uv[<span class="number">0</span>] * width), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(uv[<span class="number">1</span>] * height));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flip_horizontally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> half = width &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; half; ++x)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; height; ++y)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; bpp; ++b)</span><br><span class="line">                    std::<span class="built_in">swap</span>(data[(x + y * width) * bpp + b],</span><br><span class="line">                              data[(width - <span class="number">1</span> - x + y * width) * bpp + b]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flip_vertically</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> half = height &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; width; ++x)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; half; ++y)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; bpp; ++b)</span><br><span class="line">                    std::<span class="built_in">swap</span>(data[(x + y * width) * bpp + b],</span><br><span class="line">                              data[(x + (height - <span class="number">1</span> - y) * width) * bpp + b]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>renderer.h</code></li>
</ul>
<p>它定义了 <code>Renderer</code> 类，这是程序的核心。它包含了主要的渲染算法，如线条绘制、重心获取、三角形光栅化等。</p>
<p>图像颜色数据将存储在一个名为 <code>frame_buffer</code> 的 <code>vector&lt;uint8_t&gt;</code> 中，这是一种格式较为底层的格式，我想这有利于后续的开发。我使用 bpp（每像素位数）作为偏移量来存储像素颜色和索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_model_mat</span><span class="params">(<span class="type">double</span> angle, <span class="type">double</span> scale, <span class="type">const</span> Vec3 &amp;translate)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_view_mat</span><span class="params">(<span class="type">const</span> Vec3&amp; eye_point)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_projection_mat</span><span class="params">(<span class="type">double</span> fov, <span class="type">double</span> aspect_ratio, <span class="type">double</span> zNear, <span class="type">double</span> zFar)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_viewport_mat</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Renderer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Renderer</span>(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> bbp);</span><br><span class="line"></span><br><span class="line">    <span class="function">Color <span class="title">get_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Color &amp;color)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw_line</span><span class="params">(Vec2 p0, Vec2 p1, <span class="type">const</span> Color &amp;color)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw_triangle_linesweeping</span><span class="params">(Vec2 p0, Vec2 p1, Vec2 p2, <span class="type">const</span> Color &amp;color)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw_object</span><span class="params">(<span class="type">const</span> Object &amp;object, IShader &amp;shader)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> width_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> height_; &#125;</span><br><span class="line">    <span class="function">std::<span class="type">uint8_t</span> <span class="title">bpp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bpp_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">frame_data</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> frame_buffer_.<span class="built_in">data</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span>&amp; <span class="title">frame_buffer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> frame_buffer_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">depth_data</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> depth_buffer_.<span class="built_in">data</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span>&amp; <span class="title">depth_buffer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> depth_buffer_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw_triangle</span><span class="params">(<span class="type">const</span> Mat&lt;<span class="number">3</span>, <span class="number">4</span>&gt; &amp;t_vert_clip, IShader &amp;shader)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Vec3 <span class="title">get_barycentric2D</span><span class="params">(<span class="type">const</span> std::array&lt;Vec2, <span class="number">3</span>&gt; &amp;t_vert, <span class="type">const</span> Vec2&amp; p)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">is_inside_triangle_cross_product</span><span class="params">(<span class="type">const</span> Vec2 *t, <span class="type">const</span> Vec2&amp; P)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> width_ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> height_ = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint8_t</span> bpp_ = <span class="number">0</span>; <span class="comment">// bits per pixel</span></span><br><span class="line">    std::vector&lt;std::<span class="type">uint8_t</span>&gt; frame_buffer_ = &#123;&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; depth_buffer_ = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>shader.h</code></li>
</ul>
<p>它是与渲染相关的类和方法的集合，包括 <code>Object</code> 和 <code>Camera</code> 等工具。它还定义了基本的 <code>IShader</code> 接口，作为所有着色器的基类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Camera</span> &#123;</span><br><span class="line">    Vec3 position;</span><br><span class="line">    <span class="type">double</span> fov;</span><br><span class="line">    <span class="type">double</span> aspect_ratio;</span><br><span class="line">    <span class="type">double</span> zNear;</span><br><span class="line">    <span class="type">double</span> zFar;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(<span class="type">const</span> Vec3&amp; position, <span class="type">double</span> fov, <span class="type">double</span> aspect_ratio, <span class="type">double</span> zNear, <span class="type">double</span> zFar)</span><br><span class="line">            : <span class="built_in">position</span>(position), <span class="built_in">fov</span>(fov), <span class="built_in">aspect_ratio</span>(aspect_ratio), <span class="built_in">zNear</span>(zNear), <span class="built_in">zFar</span>(zFar) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">const</span> Model model;</span><br><span class="line">    Vec3 position;</span><br><span class="line">    <span class="type">double</span> angle;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> std::string &amp;model_path, <span class="type">const</span> Vec3 &amp;position, <span class="type">const</span> <span class="type">double</span> angle, <span class="type">const</span> <span class="type">double</span> scale)</span><br><span class="line">            : <span class="built_in">model</span>(<span class="built_in">Model</span>(model_path)), <span class="built_in">position</span>(position), <span class="built_in">angle</span>(angle), <span class="built_in">scale</span>(scale) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    Vec3 direction;</span><br><span class="line">    Vec3 intensity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IShader</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IShader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IShader</span><span class="params">(<span class="type">const</span> Model &amp;model, std::vector&lt;Light&gt;&amp;&amp; lights = std::vector&lt;Light&gt;())</span></span></span><br><span class="line"><span class="function">        : model_(model), lights_(std::move(lights)) &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vertex</span><span class="params">(<span class="type">int</span> i_face, <span class="type">int</span> nth_vert, Vec4 &amp;ret_vert)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fragment</span><span class="params">(<span class="type">const</span> Vec3 &amp;bc, Color&amp; ret_color)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">const</span> Model&amp; model_;</span><br><span class="line">    std::vector&lt;Light&gt; lights_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tga-handler.h</code></li>
</ul>
<p>这是一个静态的 TGA 图像读取器和写入器，可以读取和写入带有 RLE 压缩的 TGA 图像。</p>
<p>Run-Length Encoding（RLE）是一种简单且高效的数据压缩算法，特别适用于压缩包含大量重复元素的数据。RLE的基本思想是将连续出现的相同数据值替换为一个单一的值和一个计数。</p>
<p>例如，考虑字符串 “AAAABBBCCDAA”。使用RLE，这个字符串可以被压缩为 “4A3B2C1D2A”。这里，“4A”表示字母 ‘A’ 连续出现四次，“3B”表示 ‘B’ 连续出现三次，以此类推。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// standard TGA header</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TGAHeader</span> &#123;</span><br><span class="line">    std::<span class="type">uint8_t</span>  id_length = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint8_t</span>  color_map_type = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint8_t</span>  data_type_code = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint16_t</span> color_map_origin = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint16_t</span> color_map_length = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint8_t</span>  color_map_depth = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint16_t</span> x_origin = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint16_t</span> y_origin = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint16_t</span> width = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint16_t</span> height = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint8_t</span>  bits_per_pixel = <span class="number">0</span>;</span><br><span class="line">    std::<span class="type">uint8_t</span>  image_descriptor = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TGAHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TGAHandler</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Texture <span class="title">read_tga_file</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">write_tga_file</span><span class="params">(<span class="type">const</span> std::string &amp;filename, <span class="type">int</span> width, <span class="type">int</span> height, std::<span class="type">uint8_t</span> bpp, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">bool</span> v_flip = <span class="literal">false</span>, <span class="type">bool</span> rle = <span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">load_rle_data</span><span class="params">(std::ifstream &amp;in, Texture &amp;texture)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">unload_rle_data</span><span class="params">(std::ofstream &amp;out, <span class="type">int</span> width, <span class="type">int</span> height, std::<span class="type">uint8_t</span> bpp, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *data)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Projects</category>
        <category>2024</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>【Algorithm4】读书笔记零：目录</title>
    <url>/posts/4000/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202310081701001.png" alt="algorithm4" style="zoom: 50%;" />
<blockquote>
<p><strong>官网：<a href="https://algs4.cs.princeton.edu/home/">https://algs4.cs.princeton.edu/home/</a></strong></p>
</blockquote>
<hr>
<p>《算法4》作为算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述，是非常棒算法的入门书籍</p>
<p><strong>以下是我对于《算法4》的读书笔记</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Introduction</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/4001/">【Algorithm4】读书笔记一</a></td>
<td style="text-align:center">第一章：基础</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/4002/">【Algorithm4】读书笔记二</a></td>
<td style="text-align:center">第二章：排序</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/4003/">【Algorithm4】读书笔记三</a></td>
<td style="text-align:center">第三章：查找</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Algorithm</category>
        <category>《Algorithms, 4th Edition》</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Note</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Algorithm4】读书笔记一：基础</title>
    <url>/posts/4001/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309132308381.png" alt="algorithm4" style="zoom: 50%;" />
<blockquote>
<p><strong>官网：<a href="https://algs4.cs.princeton.edu/home/">https://algs4.cs.princeton.edu/home/</a></strong></p>
<p><strong>笔记目录：<a href="https://hmxs.games/posts/4000/">https://hmxs.games/posts/4000/</a></strong></p>
</blockquote>
<hr>
<h1>基础</h1>
<h2 id="基础编程模型">基础编程模型</h2>
<blockquote>
<p><strong>《算法4》中主要采用了Java作为编程语言，而这章主要介绍了Java的语言基础</strong></p>
</blockquote>
<h3 id="Java基础">Java基础</h3>
<h4 id="编译流程">编译流程</h4>
<p>Java是一个完全遵循面向对象编程思想（<code>OOP</code>）进行设计的语言，其中通过<code>class</code>来组织所有的代码</p>
<p>在Java中，我们编写的是后缀名为<code>.java</code>的源代码文件，每个<code>.java</code>文件中都包含着一个同名类，每个类中都可以包含一个<code>main</code>入口函数</p>
<p>在命令行中使用<code>javac</code>命令可以对<code>.java</code>文件进行编译，编译通过后会生成后缀为<code>.class</code>的Java字节码文件，通过<code>java</code>命令即可运行<code>.class</code>文件中的<code>main</code>函数</p>
<h4 id="Java原理">Java原理</h4>
<p>Java是一门半解释半编译的语言，其会将源文件的高级语言先编译为Java字节码后运行在Java虚拟机（JVM）上</p>
<p>Java因此得以拥有了良好地跨平台性，Java字节码是不分平台的，只要对应平台实现了Java虚拟机，Java字节码即可运行在该平台上</p>
<p>同时Java虚拟机会在运行时对代码进行优化处理，使得Java同时拥有了比纯解释型语言更快的速度，在这一过程中还可以使得语言获得一定的运行时特性</p>
<hr>
<h3 id="重定向、管道与输入-输出">重定向、管道与输入/输出</h3>
<h4 id="标准输入">标准输入</h4>
<p>在Java中，<code>main</code>函数会接受一个<code>String[] args</code>类型的参数作为<code>main</code>函数的输入</p>
<p>而当我们使用<code>java</code>命令运行<code>.class</code>文件时（进行这一步时<code>.class</code>文件不需要输入后缀名），我们可以直接在后面追加参数作为<code>args</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java test abc 123 qwe</span><br></pre></td></tr></table></figure>
<p>如在上面这行命令中，我们通过<code>java</code>命令运行了<code>test.class</code>文件，而后续的<code>abc</code>、<code>123</code>、<code>qwe</code>则为输入，即<code>String[] args = &#123;&quot;abc&quot;, &quot;123&quot;, &quot;qwe&quot;&#125;;</code></p>
<h4 id="标准输出">标准输出</h4>
<p>在一般情况下，我们可以调用<code>System.out</code>库或本书作者提供的<code>Stdout</code>库将我们想要的内容输出到控制台上</p>
<p>同时<code>Stdout</code>也支持格式化输出，即类似<code>C/C++</code>中的<code>printf()</code></p>
<p>使用并无特殊之处，故不再详细赘述</p>
<h4 id="重定向">重定向</h4>
<p>在上面的标准输入/输出中我们都是在和控制台进行交互，这在进行一些大量数据的输入/输出时并不方便</p>
<p>而重定向允许我们直接从文本文件中读取输入，或直接将内容输出至文件中</p>
<p>重定向输入操作符为<code>&lt;</code>，输出则为<code>&gt;</code>，在其后面追加需要读取/输出到的文件路径即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java test &lt; data.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
<p>上述意思为从<code>data.txt</code>文件中读取输入，并将输出内容输出至<code>output.txt</code></p>
<p>同时，重定向输入是可以和上述的标准输入混用的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java test data1.txt &lt; data2.txt</span><br></pre></td></tr></table></figure>
<p>如上面这段语句代表着<code>String[] args = &#123;&quot; data.txt&quot;, ...&#125;</code>，<code>...</code>为从<code>data2.txt</code>中读取到的内容</p>
<h4 id="管道">管道</h4>
<p>管道是进一步的重定向，其可以将上一个<code>.class</code>文件的输出作为下一个文件的输入，操作符为<code>|</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java test1 100 200 | java test2</span><br></pre></td></tr></table></figure>
<p>如上面这段语句代表将<code>args = [100, 200]</code>作为参数输入<code>test1.class</code>，后将<code>test1.class</code>的输出输入<code>test2.class</code></p>
<hr>
<h2 id="数据抽象">数据抽象</h2>
<blockquote>
<p><strong>数据类型指的是一组值和一组对这些值的操作的集合；本章主要介绍了数据类型的定义与使用，这个过程也被称为<code>数据抽象</code></strong></p>
</blockquote>
<h3 id="抽象数据类型的使用">抽象数据类型的使用</h3>
<h4 id="API与继承">API与继承</h4>
<p>我们使用API来对抽象数据类型中的函数与方法进行描述，这近似于静态方法库</p>
<p>同时我们可以通过继承类，覆写父类中的方法来实现API的灵活改变</p>
<h4 id="对象">对象</h4>
<p>而与静态方法库不同的是，数据类型往往需要依托于对象存在</p>
<blockquote>
<p><strong>对象是能够承载数据类型的值的实体</strong></p>
</blockquote>
<p>所有对象都具有三大重要特性：</p>
<ul>
<li>状态：即数据类型中的值</li>
<li>标识：即对象在内存中地址的引用</li>
<li>行为：即可对数据类型进行的操作</li>
</ul>
<p>数据类型的实现的唯一职责就是维护一个对象的身份，这样用例代码在使用数据类型时便只需要遵守描述对象行为的API即可，无需关心对象状态的表示方法</p>
<h4 id="对象的创建">对象的创建</h4>
<p>每种数据类型中的值都存储于一个对象中，使用<code>new</code>关键字即可实例化对象，即对象的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Counter</span> <span class="variable">heads</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="string">&quot;Header&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当我们使用<code>new</code>进行实例化时，系统会：</p>
<ul>
<li>为对象分配内存空间</li>
<li>调用构造函数</li>
<li>返回对象的引用</li>
</ul>
<p>我们可以用同一个类创建无数个对象</p>
<h4 id="对象赋值">对象赋值</h4>
<p>当我们对引用类型的变量进行赋值操作时，我们实际是创建了一个别名，复制了一遍内存地址</p>
<p>这只是一种浅拷贝，在使用时我们应注意这点</p>
<h4 id="对象总结">对象总结</h4>
<p>运用数据抽象的思想编写代码的方式被称为<code>面向对象编程</code>，这是一种极其重要的编程思想</p>
<p>一个数据类型的实现所支持的操作有：</p>
<ul>
<li>创建对象：使用<code>new</code>触发构造函数并创建对象，初始化对象中的值并返回对其的引用</li>
<li>操作对象中的值：使用和对象关联的变量调用实例方法来对对象中的值进行操作</li>
<li>操作多个对象：创建对象的数组，像原始数据类型的值一样将他们传递给方法或是从方法中返回，只是变量关联的是对象的引用而非对象本身</li>
</ul>
<hr>
<h3 id="抽象数据类型的实现">抽象数据类型的实现</h3>
<h4 id="Counter类"><code>Counter</code>类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">// final 类似C#中的const</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">(String id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Increment</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Tally</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> count + <span class="string">&quot; &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试用例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">heads</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="string">&quot;Heads&quot;</span>);</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">tails</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="string">&quot;Tails&quot;</span>);</span><br><span class="line"></span><br><span class="line">        heads.Increment();</span><br><span class="line">        heads.Increment();</span><br><span class="line">        tails.Increment();</span><br><span class="line"></span><br><span class="line">        StdOut.println(heads + <span class="string">&quot; &quot;</span> + tails);</span><br><span class="line">        StdOut.println(heads.Tally() + tails.Tally());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="VisualAccumulator类"><code>VisualAccumulator</code>类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisualAccumulator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> total;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VisualAccumulator</span><span class="params">(<span class="type">int</span> trials, <span class="type">double</span> max)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StdDraw.setXscale(<span class="number">0</span>, trials);</span><br><span class="line">        StdDraw.setYscale(<span class="number">0</span>, max);</span><br><span class="line">        StdDraw.setPenRadius(<span class="number">.005</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AddDataValue</span><span class="params">(<span class="type">double</span> value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        total += value;</span><br><span class="line">        StdDraw.setPenColor(StdDraw.DARK_GRAY);</span><br><span class="line">        StdDraw.point(n, value);</span><br><span class="line">        StdDraw.setPenColor(StdDraw.RED);</span><br><span class="line">        StdDraw.point(n, total / n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Mean</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> total / n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mean (&quot;</span> + n + <span class="string">&quot; values): &quot;</span> + String.format(<span class="string">&quot;%7.5f&quot;</span>, Mean());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">VisualAccumulator</span> <span class="variable">visualAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VisualAccumulator</span>(T, <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; T; i++)</span><br><span class="line">            visualAccumulator.AddDataValue(StdRandom.uniformDouble());</span><br><span class="line">        StdOut.println(visualAccumulator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="数据类型的设计">数据类型的设计</h3>
<blockquote>
<p><strong>抽象数据类型是一种向用例隐藏内部表示的数据类型</strong></p>
</blockquote>
<h4 id="封装">封装</h4>
<p>面向对象编程的特征之一就是使用数据类型的实现封装数据，以简化实现和隔离用例开发</p>
<p>封装实现了模块化编程，它允许我们：</p>
<ul>
<li>独立开发用例和实现的代码</li>
<li>切换至改进的实现而不会影响用例的代码</li>
<li>支持尚未编写的程序</li>
</ul>
<p>封装同时也隔离了数据类型的操作，这使得我们可以：</p>
<ul>
<li>限制潜在的错误</li>
<li>在实现中添加一致性检查等调试工具</li>
<li>确保用例代码更明晰</li>
</ul>
<p>封装是实现高拓展性的关键，模块化编程成功的关键在于保持模块之间的独立性</p>
<h4 id="设计API">设计API</h4>
<p>设计API是构建现代软件最重要也是最有挑战的一项任务</p>
<p>它没有标准答案，需要经验、思考和反复的修改</p>
<blockquote>
<p><strong>这句格言或许有帮助：只为用例提供它们所需要的，仅此而已</strong></p>
</blockquote>
<h4 id="算法与抽象数据类型">算法与抽象数据类型</h4>
<p>数据抽象天生适合算法研究，其可以让我们：</p>
<ul>
<li>准确定义算法能为用例提供什么</li>
<li>隔离算法的实现和用例的代码</li>
<li>实现多层抽象，用已知算法实现其他算法</li>
</ul>
<h4 id="等价性">等价性</h4>
<p>当我们进行引用类型的等价性测试时，如<code>a == b</code>，我们比较的是其的引用，即比较是标识</p>
<p>而如果我们想进行状态的比较，可以实现<code>Object</code>类中的<code>equals</code>方法</p>
<p>Java约定<code>equals()</code>必须是一种等价性关系，它必须具有：</p>
<ul>
<li>自反性：<code>x.equals(x)</code>为<code>true</code></li>
<li>对称性：当<code>x.equals(y)</code>为<code>true</code>时，<code>y.equals(x)</code>也应为<code>true</code></li>
<li>传递性：当<code>x.equals(y)</code>，<code>y.equals(z)</code>都为<code>true</code>时，<code>x.equals(z)</code>为<code>true</code></li>
<li>一致性：当对象不变时，反复调用<code>x.equals(y)</code>的结果应相同</li>
<li>非空性：<code>x.equals(null)</code>应始终为<code>false</code></li>
</ul>
<h4 id="不可变性">不可变性</h4>
<p>我们可以通过<code>final</code>将某一变量标记为不可变，这意味着其在第一次赋值之后，值便无法改变了</p>
<p>但需要注意的是，对于引用类型，<code>final</code>只能保证引用的不变，即变量永远指向初始指定的内存，但无法保证内存中的内容不变</p>
<h4 id="异常与断言">异常与断言</h4>
<ul>
<li>异常：一般用于处理不受我们控制的不可预见的错误</li>
<li>断言：验证我们在代码中的一些假设</li>
</ul>
<p>断言是一个布尔表达式，当我们运行到断言处时，如果表达式为<code>false</code>，程序会直接抛出异常</p>
<p>我们可以在测试中使用断言来验证我们的想法，并且帮助我们更好地debug，保证代码永远不会被系统错误终止或进入死循环；但我们不应该在实际程序中使用他们，其在实际运行中可能会被禁用</p>
<blockquote>
<p><strong>契约式设计：数据类型的设计者需要说明前提条件（用例在调用某个方法前必须满足的条件）、后置条件（实现在方法返回时必须达到的要求）和副作用（方法可能对对象状态产生的任何其他变更）</strong></p>
</blockquote>
<hr>
<h2 id="背包、队列和栈">背包、队列和栈</h2>
<p>在本章中，会讲述背包（Bag）、队列（Queue）和栈（Stack）三种数据类型</p>
<h3 id="API">API</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bag</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Bag();                <span class="comment">// 创建空背包</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T item)</span>;    <span class="comment">// 添加一个元素 </span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;    <span class="comment">// 背包是否为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;            <span class="comment">// 背包的元素数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Queue();                <span class="comment">// 创建空队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(T item)</span>;    <span class="comment">// 添加一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dequeue</span><span class="params">(T item)</span>;    <span class="comment">// 删除最早添加的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;        <span class="comment">// 队列是否为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;                <span class="comment">// 队列的元素数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Stack();            <span class="comment">// 创建空栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span>;    <span class="comment">// 添加一个元素</span></span><br><span class="line">    </span><br><span class="line">    T <span class="title function_">pop</span><span class="params">()</span>;            <span class="comment">// 删除最晚添加的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;    <span class="comment">// 栈是否为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;            <span class="comment">// 栈的元素数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型">泛型</h4>
<blockquote>
<p><strong>泛型，也叫做参数化类型，其可以被用来储存任意类型的数据</strong></p>
</blockquote>
<p>我们可以用任意数据类型来替换泛型中的<code>&lt;T&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="自动装箱">自动装箱</h4>
<p>类型参数必须被实例化为引用类型，因此Java有一种特殊机制来使泛型代码能够处理原始数据类型</p>
<p>Java中的中的原始数据类型都有着对应的引用类型，如<code>Boolean</code>、<code>Byte</code>、<code>Integer</code>分别对应<code>boolean</code>、<code>byte</code>、<code>int</code>，Java会自动对其进行类型转换</p>
<blockquote>
<p><strong>自动将一个原始数据类型转换为一个封装类型被称为自动装箱，反之则为自动拆箱</strong></p>
</blockquote>
<h4 id="背包">背包</h4>
<blockquote>
<p><strong>背包是一种不支持从中删除指定元素的集合数据类型，它的目的就是帮助用例收集元素，并迭代遍历所有收集到的元素</strong></p>
</blockquote>
<p>在背包中，迭代的顺序是不确定的；我们当然可以使用栈或队列或其他数据结构来完成这一项工作，但使用背包可以说明元素的处理顺序并不重要</p>
<p>下面是一个基于背包的计算标准差与平均值的程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bag&lt;Double&gt; numbers = <span class="keyword">new</span> <span class="title class_">Bag</span>&lt;Double&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (! StdIn.isEmpty())</span><br><span class="line">            numbers.add(StdIn.readDouble());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> numbers.size();</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> x : numbers)</span><br><span class="line">            sum += x;</span><br><span class="line">        <span class="type">double</span> <span class="variable">mean</span> <span class="operator">=</span> sum / N;</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> x : numbers)</span><br><span class="line">            sum += (x - mean) * (x - mean);</span><br><span class="line">        <span class="type">double</span> <span class="variable">std</span> <span class="operator">=</span> Math.sqrt(sum / (N - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        StdOut.printf(<span class="string">&quot;Mean: %.2f\n&quot;</span>, mean);</span><br><span class="line">        StdOut.printf(<span class="string">&quot;Std dev: %.2f\n&quot;</span>, std);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"><span class="comment">// 101</span></span><br><span class="line"><span class="comment">// 98</span></span><br><span class="line"><span class="comment">// 65</span></span><br><span class="line"><span class="comment">// ^D</span></span><br><span class="line"><span class="comment">// Mean: 91.00</span></span><br><span class="line"><span class="comment">// Std dev: 17.38</span></span><br></pre></td></tr></table></figure>
<h4 id="先进先出队列">先进先出队列</h4>
<blockquote>
<p><strong>队列是一种基于先进先出（FIFO）策略的集合类型</strong></p>
</blockquote>
<p><em>这在C++/C#或一些其他语言中都非常常见，不再赘述</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<p>在使用<code>foreach</code>进行遍历时，元素会以加入顺序被处理</p>
<h4 id="下压栈">下压栈</h4>
<blockquote>
<p><strong>栈是一种基于后进先出（LIFO）策略的集合类型</strong></p>
</blockquote>
<p><em>这在C++/C#或一些其他语言中都非常常见，不再赘述</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;;</span><br></pre></td></tr></table></figure>
<p>在使用<code>foreach</code>进行遍历时，元素被处理的顺序与加入顺序相反</p>
<h4 id="算术表达式求值">算术表达式求值</h4>
<p>对于字符串形式的算术表达式的求值，我们可以通过<code>E.W.Dijkstra</code>发明的双栈运算算法进行</p>
<p>表达式由括号、运算符和操作数组成，我们根据以下四种情况从左到右逐个将这些实体入栈处理：</p>
<ul>
<li>将操作数压入操作数栈</li>
<li>将运算符压入运算符栈</li>
<li>忽略左括号</li>
<li>在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符与操作数的运算结果压入操作数栈</li>
</ul>
<p>操作数栈上最后剩下的值即为表达式的值，下面是Java中的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evaluate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Dijkstra双栈算术表达式求值算法</span></span><br><span class="line">        Stack&lt;String&gt; operators = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Double&gt; values = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (! StdIn.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取字符</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> StdIn.readString();</span><br><span class="line">            <span class="comment">// 左括号则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;(&quot;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 是运算符则压入操作符栈</span></span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;+&quot;</span>) || s.equals(<span class="string">&quot;-&quot;</span>) || s.equals(<span class="string">&quot;*&quot;</span>) || s.equals(<span class="string">&quot;/&quot;</span>) || s.equals(<span class="string">&quot;sqrt&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                operators.push(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是右括号则出栈</span></span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;)&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">operator</span> <span class="operator">=</span> operators.pop();</span><br><span class="line">                <span class="type">Double</span> <span class="variable">value</span> <span class="operator">=</span> values.pop();</span><br><span class="line">                <span class="keyword">if</span> (operator.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                    values.push(values.pop() + value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                    values.push(values.pop() - value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;*&quot;</span>))</span><br><span class="line">                    values.push(values.pop() * value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">                    values.push(values.pop() / value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;sqrt&quot;</span>))</span><br><span class="line">                    values.push(Math.sqrt(value));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上述都不是则压入数值栈</span></span><br><span class="line">            values.push(Double.parseDouble(s));</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(values.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">//( ( 1 + sqrt ( 5.0 ) ) / 2.0 )</span></span><br><span class="line"><span class="comment">//^D</span></span><br><span class="line"><span class="comment">//1.618033988749895</span></span><br></pre></td></tr></table></figure>
<p>这段代码实际上是一个极其简单的“解释器”</p>
<hr>
<h3 id="集合类数据类型的实现">集合类数据类型的实现</h3>
<p>接下来就该来自己实现数据结构了！</p>
<h4 id="定容栈">定容栈</h4>
<p>我们将会从最简单的固定容量的字符串栈的实现开始，它要求用例指定一个容量且不支持迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedCapacityStackOfStrings</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FixedCapacityStackOfStrings</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123; s = <span class="keyword">new</span> <span class="title class_">String</span>[capacity]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(String item)</span></span><br><span class="line">    &#123; s[N++] = item; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> s[--N]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是最简单的数据结构，但也是一切的基础</p>
<h4 id="泛型-2">泛型</h4>
<p>定容栈的第一个缺点是其只能处理<code>String</code>一种类型的数据，而泛型可以解决这一问题</p>
<p>需要注意的是，因为一些历史遗留问题，Java不能直接创建泛型数组，但我们可以通过类型转换来实现<code>T[] s = (T[]) new Object[capacity];</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedCapacityStack</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FixedCapacityStack</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123; s = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span></span><br><span class="line">    &#123; s[N++] = item; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> s[--N]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将所有<code>Sting</code>改为<code>T</code>即可</p>
<h4 id="动态调整数组的大小">动态调整数组的大小</h4>
<p>在Java中，数组一旦创建，其大小便无法改变了；但我们可以通过动态创建更大的数组并将原来的数组复制过来来实现数组大小的动态变化</p>
<p>通过以下函数便可以实现动态调整数组的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> new_capacity)</span></span><br><span class="line">&#123;</span><br><span class="line">    T[] temp = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[new_capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        temp[i] = array[i];</span><br><span class="line">    array = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后更改<code>push()</code>与<code>pop()</code>，在要溢出时扩容，利用率太低时减容，即可实现内存大小的动态调整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResizingArrayStack</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResizingArrayStack</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123; array = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= array.length)</span><br><span class="line">            resize(<span class="number">2</span> * N);</span><br><span class="line">        array[N++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> array[--N];</span><br><span class="line">        array[N] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N &lt;= array.length / <span class="number">4</span>)</span><br><span class="line">            resize(N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> new_capacity)</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[] temp = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[new_capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            temp[i] = array[i];</span><br><span class="line">        array = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代">迭代</h4>
<p>在Java中，实现迭代只需要让对应类继承<code>Iterable&lt;T&gt;</code>接口，并实现对应方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; </span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接口中，可以看到我们需要实现一个返回值为<code>Iterator&lt;T&gt;</code>的<code>iterator()</code>方法即可</p>
<p>而<code>Iterator&lt;T&gt;</code>即为迭代器，迭代器中需要实现的方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们声明一个内部类继承<code>Iterator&lt;T&gt;</code>，并实现其中的方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ReverseArrayIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> i &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">return</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>迭代器的实现对于数据类型的封装是十分重要的，其可以让外部完全不关系内部实现，使用迭代器即可完成对内部元素的遍历</strong></p>
</blockquote>
<h4 id="最终实现">最终实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResizingArrayStack</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResizingArrayStack</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123; array = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= array.length)</span><br><span class="line">            resize(<span class="number">2</span> * N);</span><br><span class="line">        array[N++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> array[--N];</span><br><span class="line">        array[N] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N &lt;= array.length / <span class="number">4</span>)</span><br><span class="line">            resize(N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> new_capacity)</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[] temp = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[new_capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            temp[i] = array[i];</span><br><span class="line">        array = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReverseArrayIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ReverseArrayIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">        &#123; <span class="keyword">return</span> i &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ResizingArrayStack&lt;T&gt;</code>已经是一个颇具雏形的数据类型了，但在具体实现上，其还有着一定的问题</p>
<p>在进行<code>push()</code>与<code>pop()</code>操作时，数组的大小会被调整，这种调整的规模是呈指数上升的，这对内存与性能都并不友好，而使用链表可以解决这一缺陷，并以一种完全不同的方式组织数据</p>
<hr>
<h3 id="链表">链表</h3>
<blockquote>
<p><strong>链表是一种递归数据结构，它或为空，或为含有泛型元素的结点和指向另一个结点的引用</strong></p>
</blockquote>
<p><em>链表的基础概念较为简单，且笔者之前已经学过很多遍，此处不再赘述</em></p>
<ul>
<li>链表可以处理任意数据类型的数据</li>
<li>链表所需的空间总是和集合的大小成正比</li>
<li>链表操作所需时间总是和集合大小无关</li>
</ul>
<p>在上一章我们通过数组实现了可动态调整大小可迭代的下压数组</p>
<p>而使用链表来实现它们一样可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinklistStack</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        T value;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> head == <span class="literal">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        newNode.value = value;</span><br><span class="line">        newNode.next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> head.value;</span><br><span class="line">        head = head.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinklistIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LinklistIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">        &#123; <span class="keyword">return</span> current.next != <span class="literal">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> current.value;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>在结构化存储数据集时，链表是数组的一种重要的替代方法</strong></p>
</blockquote>
<hr>
<h3 id="总结">总结</h3>
<p>在研究一个新的应用领域时，我们应按照以下步骤识别目标并使用数据抽象解决问题：</p>
<ul>
<li>定义API</li>
<li>根据特定的应用场景开发用例代码</li>
<li>描述一种数据结构（一组值的表示），并在API所对应的抽象数据类型的实现中根据它定义类的实例变量</li>
<li>描述算法（实现一组操作的方法），并根据它实现类中的实例方法</li>
<li>分析算法的性能特点</li>
</ul>
<hr>
<h2 id="算法分析">算法分析</h2>
<blockquote>
<ul>
<li><strong>我的程序会运行多长时间</strong></li>
<li><strong>我的程序会耗费多少内存</strong></li>
</ul>
<p><strong>这是我们在编写代码时会不可避免地遇到的两大问题，而为这些基础问题给出答案实际上并不困难</strong></p>
</blockquote>
<h3 id="数学模型">数学模型</h3>
<p>根据Knuth的理论，尽管有着许多复杂因素影响着程序的效率，但原则上我们总可以构建出一个数学模型来描述任意程序的运行时间</p>
<p>一个程序的运行时间主要和两点有关：</p>
<ul>
<li>执行每条语句的耗时</li>
<li>执行每条语句的频率</li>
</ul>
<p>前者取决于计算机硬件和操作系统，后者取决于程序本身和输入，而我们最需要关注的便是后者</p>
<h4 id="近似">近似</h4>
<p>对于语句频率的分析往往会使我们得到一个复杂冗长的表达式，如对于下面这段程序而言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; N; k++)</span><br><span class="line">            sum++;</span><br></pre></td></tr></table></figure>
<p>得到的语句频率表达式为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>6</mn><mo>=</mo><msup><mi>N</mi><mn>3</mn></msup><mi mathvariant="normal">/</mi><mn>6</mn><mo>−</mo><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">N(N-1)(N-2)/6=N^3/6-N^2/2+N/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">/6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/3</span></span></span></span></p>
<p>这并不直观，但我们可以发现，当N比较大时，首项之后的其他项都相对较小</p>
<p>如对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">N=1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo>≈</mo><mn>499667</mn></mrow><annotation encoding="application/x-tex">-N^2/2+N/3\approx499667</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">499667</span></span></span></span>，这相对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup><mi mathvariant="normal">/</mi><mn>6</mn><mo>≈</mo><mn>166666667</mn></mrow><annotation encoding="application/x-tex">N^3/6\approx166666667</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">/6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">166666667</span></span></span></span>来说小了非常多，以至于可以省略</p>
<p>所以我们可以舍去除首项外的其他项来大大简化我们的表达式，从而得到一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">N^3/6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">/6</span></span></span></span></p>
<p>而实际上我们还可以进一步的简化，在首项的基础上舍去常数量，我们即可得到算法的<code>增长数量级</code>，如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">N^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></p>
<blockquote>
<p><strong>增长数量级（大O表示法）是一个非常重要的概念，其可以非常简单直观地表示一个算法的抽象效率，且与算法的具体实现无关</strong></p>
</blockquote>
<h4 id="成本模型">成本模型</h4>
<p>上述的增长数量级非常简单直观，但如果我们想要一种更加系统性且可以量化的方法来对算法的性能进行精确的比较或预测，我们便可以使用成本模型</p>
<blockquote>
<p><strong>成本模型是一个用于评估算法性能的概念框架，其定义了哪些操作或资源应该被计算，以及是如何进行计算的</strong></p>
</blockquote>
<p>在算法分析中，成本模型用于：</p>
<ol>
<li><strong>确定算法效率</strong>：通过计算算法执行中某些操作的数量，可以评估算法的运行时间。例如，在排序算法中，可能会计算比较和交换的次数</li>
<li><strong>比较算法</strong>：成本模型允许我们在同一基础上比较不同算法的性能。通过分析不同算法在相同成本模型下的行为，我们可以确定哪种算法更有效</li>
<li><strong>预测性能</strong>：通过对算法在不同输入大小下的成本进行数学建模，我们可以预测算法在更大输入上的行为</li>
</ol>
<p>在选择成本模型时，通常会选择对于特定算法和问题域来说最具代表性和影响力的操作。例如，在分析快速排序算法时，比较和交换可能是成本模型中最重要的操作，而在分析图算法时，可能会更关注边和顶点的遍历次数</p>
<h4 id="总结-2">总结</h4>
<p>对于大多数程序，得到其运行时间的数学模型所需步骤如下：</p>
<ul>
<li>确定输入模型，定义问题的规模</li>
<li>识别内循环</li>
<li>根据内循环中的操作确定成本模型</li>
<li>对于给定输入，判断这些操作的执行频率</li>
</ul>
<hr>
<h3 id="倍率实验">倍率实验</h3>
<p>倍率实验是一种估计运行时间的增长数量级的简单方法，我们通过倍率实验可以越过程序本身直接测试并预测出算法的运行效率</p>
<p>通过下面的方法我们便可以对一段程序进行倍率实验：</p>
<ul>
<li>使用一个输入生成器生成各规模的输入</li>
<li>不断提高输入规模并重新运行程序</li>
<li>直到运行时间与上一次的运行时间比值趋近于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>由此便可以得到倍率实验的结果，而被测程序的增长数量级便近似为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">N^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span></p>
<p>而，之所以运行时间的比值会趋近于一个常数是因为<code>倍率定理</code></p>
<blockquote>
<p><strong>倍率定理：</strong></p>
<p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>∽</mo><mi>a</mi><msup><mi>N</mi><mi>b</mi></msup><mi>lg</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">T(N) \backsim aN^b \lg N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">∽</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mn>2</mn><mi>N</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>∽</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">T(2N)/T(N) \backsim 2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">∽</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<hr>
<h3 id="处理对于输入的依赖">处理对于输入的依赖</h3>
<p>我们通常采用大O表示法，即增长数量级来描述算法的效率，但需要注意的是，随着输入内容及规模的改变，算法的效率很可能会发生非常大的变化，这时我们便需要进行更为细致的分析</p>
<h4 id="输入模型">输入模型</h4>
<p>一种方法是更加小心细致地选择输入模型，如让输入模型足够适应现实情况</p>
<p>这种方法往往会面临以下两个缺点：</p>
<ol>
<li>输入模型可能是不切实际的</li>
<li>对输入的分析可能极端困难，所需的数学技巧远非一般的学生或程序员可以掌握</li>
</ol>
<h4 id="对最坏情况下的性能保证">对最坏情况下的性能保证</h4>
<p>我们需要从极度悲观的视角下来估算算法的信念</p>
<p>虽然我们是程序的设计者，但程序的输入确是来自于各个不同的用户（其中或许包含着恶意），我们需要确保即使程序接收到了异常规模的数据也不会直接崩溃，这是为性能做的最后一层保险</p>
<h4 id="随机化算法">随机化算法</h4>
<p>为性能提供保证的一种重要方法是引入随机性</p>
<p>如，大名鼎鼎的快速排序算法在最坏最坏的情况下性能会达到平方级别，但在输入完全随机的情况下，其在概率下的性能可以达到线性对数，要让其达到平方级的概率微乎其微</p>
<p>虽然概率不为0，但快速排序达到平方级的概率可能比电脑出问题的概率还低</p>
<p>因此，随机情况下的概率保证，在实际情况中也可以作为最坏情况下的性能保证</p>
<h4 id="操作序列">操作序列</h4>
<p>有些情况下，更改一次计时中某些操作的顺序也会改变程序的效率</p>
<p>如对于一个下压栈来说，一次性压入N个对象再将它们全部弹出所需的时间，和将这些操作混合进行所需的时间可能完全不同</p>
<p>我们需要将这些情况也考虑进去</p>
<h4 id="均摊分析">均摊分析</h4>
<p>提供性能保证的另一种方法是通过记录所有操作的总成本并除以操作总数来将成本均摊掉</p>
<p>这种方法可以用于分析一些每次调用的成本可能不同的方法，如之前实现的可动态调整大小的栈</p>
<hr>
<h3 id="内存">内存</h3>
<p>Java是基于JVM运行的，得益于此，其拥有自动内存管理的能力，但也正因此，其过高的内存占用常常被诟病，而JVM对于内存管理的实现也是高度依赖于硬件的，不同的操作系统与硬件会带来截然不同的内存分配策略与大小</p>
<p>但幸运的是，我们只是一个程序编写者<s>臭写代码的</s>，我们不必关心不同系统的JVM对于内存的具体实现，基本上只需要专注于基础数据类型与对象即可</p>
<p>每个基础数据类型就像内存世界中的原子，一切对象都基于他们而展开，而他们所占用的内存空间往往是固定的</p>
<h4 id="对象-2">对象</h4>
<p>而对于一个对象而言，我们只需要将所有实例变量所用的内存与对象本身的开销（一般为16字节）相加即可</p>
<p>如，一个<code>Integer</code>对象会使用24字节，其中包含16字节的对象开销，4字节<code>int</code>值以及4个填充字节</p>
<h4 id="链表-2">链表</h4>
<p>链表属于嵌套的非静态类，其中需要额外8个字节用于指向外部类的引用</p>
<p>对于下面的<code>Node</code>类而言，一共需要40字节的开销，其中包含16字节的对象开销，指向<code>Item</code>和<code>Node</code>的引用各8字节，另外加上8字节的额外开销</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组">数组</h4>
<p>Java中数组被实现为对象，它们一般都会因为记录长度而需要额外的内存</p>
<p>一个原始数据类型的数组一般需要24字节的头信息，其中包含16字节的对象开销，4字节用于保存长度以及4个填充字节</p>
<p>头信息再加上保存值所需的内存即为总内存开销</p>
<p>总的来说，与对象的计算方法类似</p>
<h4 id="字符串对象">字符串对象</h4>
<p>String的标准实现中含有4个实例变量：</p>
<ul>
<li>一个指向字符数组的引用：8字节</li>
<li>一个描述字符数组偏移量的int值：4字节</li>
<li>一个计数器int值：4字节</li>
<li>一个散列int值：4字节</li>
</ul>
<p>故String对象将会额外使用40字节：16字节对象开销、3个int变量各4字节、数组引用的8字节、4个填充字节</p>
<h4 id="字符串的值和子字符串">字符串的值和子字符串</h4>
<p>一个长度为N的String对象一般需要使用40字节加上（24+2N）字节</p>
<p>但考虑到字符串经常会和子字符串打交道，但字符串值的复制会产生很大的开销，所以Java会希望尽量避免在创建字符串时进行字符串的复制</p>
<p>所以当我们调用<code>substring()</code>时，我们虽然仍然会创建一个新对象，但其中数组引用可以指向旧数组，只需改变偏移量与长度即可</p>
<p>因此，一个子字符串所需的额外内存是一个常数，构建一个子字符串所需的时间也是常数</p>
<hr>
<h3 id="展望">展望</h3>
<p>良好的性能是非常重要的，效率极低的程序几乎和不正确的程序一样无用，因此关注程序的运行开销是重要的</p>
<p>但在编程领域中，有两个常见错误时常发生</p>
<ul>
<li>其一是过于关注的程序的性能</li>
</ul>
<p>我们应先明白，我们的首要任务是写出清晰而明确的代码，而非花费大量时间却只让程序快了0.1秒</p>
<p>特别是在计算机硬件如此发达的今天，对于一个运行只需要一瞬的程序而言，即使你让他快了10倍也是无关紧要的</p>
<p>而快速排序的发明者Hoare也曾说过：”<strong>不成熟的优化是所有罪恶之源。</strong>“</p>
<ul>
<li>其二是完全忽略了程序的性能</li>
</ul>
<p>较快的算法往往比暴力求解复杂许多，这也导致了一部分人不愿意应付它们，但实际上，有时候几行代码的优化便可以带来成倍的性能提升</p>
<p>同时，当我们面临大规模问题时，寻找更好的算法是我们的唯一解</p>
<hr>
<h2 id="案例研究：union-find算法">案例研究：union-find算法</h2>
<p>下面让我们从一个实际案例入手，开始我们真正意义上的算法学习吧！</p>
<h3 id="问题描述：动态连通性的判定">问题描述：动态连通性的判定</h3>
<p>如下图所示</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202310071311415.png" alt="img"></p>
<p>假设我们输入了一组整数对，即上图中的<code>(4, 3) (3, 8)</code>等等，每对整数代表这两个points/sites是连通的。那么随着数据的不断输入，整个图的连通性也会发生变化，从上图中可以很清晰的发现这一点。同时，对于已经处于连通状态的points/sites，直接忽略，比如上图中的<code>(8, 9)</code></p>
<hr>
<h3 id="动态连通性的应用">动态连通性的应用</h3>
<ul>
<li>网络连接判断</li>
</ul>
<p>如果每个pair中的两个整数分别代表一个网络节点，那么该pair就是用来表示这两个节点是需要连通的。那么为所有的pairs建立了动态连通图后，就能够尽可能少的减少布线的需要，因为已经连通的两个节点会被直接忽略掉</p>
<ul>
<li>变量名等价性</li>
</ul>
<p>某些编程环境允许声明两个等价的变量名（指向同一个对象的多个引用），在一系列别名被声明后，系统需要能够判别两个给定的变量名是否等价</p>
<ul>
<li>数学集合</li>
</ul>
<p>在更高的抽象层次上，可以将输入的所有整数看做属于不同的数学集合，在处理一个整数对pq时，我们是在判断它们是否属于相同的集合，如果不是，我们会将p所属的集合和q所属的集合归并到一个集合中</p>
<hr>
<h3 id="实现">实现</h3>
<h4 id="API与框架">API与框架</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123; <span class="keyword">return</span> find(p) == find(q); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">// todo</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> <span class="comment">// todo</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(N);</span><br><span class="line">        <span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(p, q))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">            StdOut.println(p + <span class="string">&quot; &quot;</span> + q);</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(uf.getCount() + <span class="string">&quot;components&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>int id[]</code>：标识符数组，索引为触点值</p>
</li>
<li>
<p><code>void union(int p, int q)</code>：如果两个触点在不同分量中，<code>union()</code>会将两个分量归并</p>
</li>
<li>
<p><code>int find(int k)</code>：返回给定触点所在分量的标识符</p>
</li>
<li>
<p><code>boolean connected(int p, int q)</code>：判断两个触点是否处于同一个分量中</p>
</li>
<li>
<p><code>int getCount()</code>：返回所有连通分量的数量</p>
</li>
</ul>
<h4 id="quick-find算法"><code>quick-find</code>算法</h4>
<p>我们可以引入“标识值”概念来表示某一分量，即同一分量的标示值都相同</p>
<p>直接将<code>id[p]</code>作为<code>p</code>触点的标识值，那么若<code>id[p]==id[q]</code>，则p和q是连通的</p>
<p>如此一来我们只需要保证将同一分量的触点的标识符都统一即可</p>
<ul>
<li><code>int find(int k)</code>：返回<code>id[k]</code>的值即可</li>
<li><code>void union(int p, int q)</code>：先判断q、p是否连通，如果是则直接返回，如果不是那么遍历<code>id</code>，将<code>id</code>中所有标识值等于<code>id[p]</code>的改为<code>id[q]</code>即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span> &#123; <span class="keyword">return</span> id[k]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pID</span> <span class="operator">=</span> id[p];</span><br><span class="line">    <span class="type">int</span> <span class="variable">qID</span> <span class="operator">=</span> id[q];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pID == qID)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (id[i] == pID) id[i] = qID;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>分析：在<code>quick-find</code>中，<code>find()</code>操作非常快，但是<code>union()</code>每次都需要遍历整个数组，当问题规模较大时效率较低，其时间复杂度约为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></strong></p>
</blockquote>
<h4 id="quick-union算法"><code>quick-union</code>算法</h4>
<p>在<code>quick-find</code>中，同一分量中所有元素都拥有同一标识值</p>
<p>而实际上我们并不需要使得分量中的标识值都相同，也能表示一个分量</p>
<p>我们可以使用“单向链接”，即指向的方式来连通两个触点，一个触点的标识值为另一个与之连通的触点，若p与q是连通的，那么<code>id[p] = q</code>，即<code>p</code>指向<code>q</code></p>
<p>因为分量是由单向链接的一个个触点构成，所以总会存在一个<code>k = id[k]</code>的根触点，其类似链表的头，而我们进行链接时也是对根触点进行操作</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202310071807652.png" alt="img"></p>
<ul>
<li><code>int find(int k)</code>：找到并返回根触点</li>
<li><code>void union(int p, int q)</code>：找到需要归并的两个分量的根触点，将其中的一个指向至另一个即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (k != id[k])</span><br><span class="line">        k = id[k];</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    id[pRoot] = qRoot;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>分析：对于<code>quick-union</code>算法的成本分析较为困难，其效率会随着输入的改变发生很大的变化，在最好的情况下其时间复杂度可以达到线性级别，而最坏情况下其也会到达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的复杂度，但总的来说，<code>quick-union</code>虽然不能保证其在每种情况下都比<code>quick-find</code>要快，但其仍然是对<code>quick-find</code>算法的改良</strong></p>
</blockquote>
<h4 id="加权quick-union算法">加权<code>quick-union</code>算法</h4>
<p><code>quick-union</code>中基于“单向链接”的触点关系的组织方式是类似数据结构中的“树”的方式，而影响<code>quick-union</code>效率的一个很重要的因素便是树的深度过深，导致使用<code>find()</code>寻找根节点时，需要经历很长遍历；这一情况的产生很大程度上是由于在链接两颗树时顺序的随意，导致较深的树被链接到了较浅的树的根节点上，使得树变得越来越深，而我们若能记录每棵树的深度，并以此有顺序地进行分量的链接，<code>quick-union</code>算法的效率便可以得到大幅提升，这便是加权<code>quick-union</code>算法</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202310072332226.png" alt="img"></p>
<p>加权<code>quick-union</code>算法需要一个额外的数组来记录各个分量的深度，下面是加权<code>quick-union</code>算法的基本实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeightedQuickUnionFind</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightedQuickUnionFind</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">            size[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123; <span class="keyword">return</span> find(p) == find(q); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k != id[k])</span><br><span class="line">            k = id[k];</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size[pRoot] &gt; size[qRoot])</span><br><span class="line">        &#123; </span><br><span class="line">            id[qRoot] = pRoot; </span><br><span class="line">            size[pRoot] += size[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; </span><br><span class="line">            id[pRoot] = qRoot; </span><br><span class="line">            size[qRoot] += size[pRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">        <span class="type">WeightedQuickUnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeightedQuickUnionFind</span>(N);</span><br><span class="line">        <span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(p, q))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">            StdOut.println(p + <span class="string">&quot; &quot;</span> + q);</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(uf.getCount() + <span class="string">&quot;components&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>分析：加权<code>quick-union</code>算法的时间复杂度可以达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lg</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\lg N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，其是三种算法中唯一可以解决大规模实际问题的算法</strong></p>
</blockquote>
<p><strong>为什么使用分量的大小而非高度作为比较值？</strong></p>
<ul>
<li>因为union-find中树的构成方式，其形成的数的高度永远不会大于大小的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，所以并不会造成问题，其带来的性能变化微乎其微</li>
<li>union-find中树的大小更好追踪，特别是使用了路径压缩方法后，树的根节点与高度会发生变化，高度很难准确追踪</li>
</ul>
<h4 id="最优算法：路径压缩优化">最优算法：路径压缩优化</h4>
<p>最好的算法总是大家所趋之若鹜的，而加权<code>quick-union</code>算法虽已经很优秀，但仍然还有优化空间</p>
<p>路径压缩方法便是很容易实现的高效优化思路，其优化思路非常简单，既然我们希望树的深度尽量小，那么让元素尽量链接在根节点上就行了，只需要为<code>find()</code>添加一个循环，将在路径上遇到的所有节点都直接链接到根节点，那么我们就能得到一个近乎完全扁平的树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> k;</span><br><span class="line">    <span class="comment">// 找到根节点</span></span><br><span class="line">    <span class="keyword">while</span> (root != id[root])</span><br><span class="line">        root = id[root];</span><br><span class="line">    <span class="comment">// 将中间所有的节点链接至根节点</span></span><br><span class="line">    <span class="keyword">while</span> (k != root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> id[k];</span><br><span class="line">        id[k] = root;</span><br><span class="line">        k = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法简单有效，其可以产生近乎于理想情况下的树</p>
<p>而加上路径压缩方法后，实际情况下已经很难再对加权<code>quick-union</code>算法进行改进了</p>
<blockquote>
<p><strong>路径压缩的quick-union算法是解决动态连通性问题的最佳算法，其均摊效率可以接近与常数级</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Algorithm</category>
        <category>《Algorithms, 4th Edition》</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Note</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【The Cherno-C++】学习笔记一（1-33）</title>
    <url>/posts/1001/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304182344099.jpg" alt="cherno"></p>
<blockquote>
<p><strong>B站up神经元猫翻译版：<a href="https://www.bilibili.com/video/BV1uy4y167h2">https://www.bilibili.com/video/BV1uy4y167h2</a></strong></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>C++因为其优异的性能，是游戏开发中最为常用的语言之一，目前的Unity与Unreal两大商用引擎的内核都是采用C++进行编写，作为一个有志于成为游戏开发者的人，这种语言怎么能不学一学呢？</p>
<p>本文基于油管著名博主，曾任职于EA的The Cherno的C++系列视频，The Cherno作为寒霜引擎的核心开发人员之一，对C++有着非常独到而深刻的理解</p>
<p>这些笔记记录了我通过The Cherno的系列视频学习C++的一些知识点与理解，希望对你有帮助😉</p>
<blockquote>
<p><strong>第一章（1-33）：<a href="https://hmxs.games/posts/1001/">https://hmxs.games/posts/1001/</a></strong></p>
<p>第二章（34-66）：<a href="https://hmxs.games/posts/1002/">https://hmxs.games/posts/1002/</a></p>
<p>第三章（67-99）：<a href="https://hmxs.games/posts/1003/">https://hmxs.games/posts/1003/</a></p>
</blockquote>
<hr>
<h2 id="C-是如何运行的（5-7）">C++是如何运行的（5-7）</h2>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304190000568.webp" alt="img"></p>
<blockquote>
<p>C++运行的过程实际便是将”.cpp文本文件“转换为”可运行的.exe文件/库文件“</p>
</blockquote>
<ul>
<li><strong>预处理</strong>：修改源文本（删除初始，处理宏定义/头文件等）</li>
</ul>
<p>#为预处理符号，其后可以跟着<code>include</code>、<code>define</code>、<code>if</code>等</p>
<p>#include的作用仅为把对应代码<strong>复制</strong>过来（典中典之大括号），<code>cout</code>/<code>cin</code>即来源于<code>iostream</code></p>
<ul>
<li><strong>编译</strong>：将每个翻译单元转换为<code>.obj</code>目标代码（<code>.obj</code>为VS中，不同编译器生成的文件可能不同）</li>
</ul>
<p><code>.cpp</code>-&gt;翻译单元-&gt;<code>.obj</code></p>
<p>一个cpp文件可以代表一个翻译单元，也可以由多个cpp代表一个翻译单元，这可以进行自定义</p>
<p>一个翻译单元会被编译为一个obj文件</p>
<ul>
<li><strong>链接</strong>：找到入口函数（当需要生成.exe文件时），链接不同obj文件</li>
</ul>
<p>每个可执行文件都需要一个入口（<em>一般是main函数，也可以自定义</em>），链接器便可以找到程序入口</p>
<p>同时，在一个项目中，我们可能会有多个翻译单元生成多个obj文件，如果没有连接器，它们之间便无法进行交互</p>
<p>当函数a声明在A翻译单元，但实现在B翻译单元中时，链接器便可以通过唯一的函数签名链接它们</p>
<p>（个人理解：一个函数的“名字”实际包含了其返回值+函数名+参数，其中任何一个不一样都是不一样的函数）</p>
<p><strong>编译与链接</strong>是两个截然不同的阶段，当我们的程序出现问题是，发现问题出现在什么阶段是重要的</p>
<hr>
<h2 id="变量（8）">变量（8）</h2>
<p><strong>变量</strong>：变量允许我们命名我们存储在内存中的数据</p>
<p>在C++中我们有一些基本的数据类型，如<code>int</code>、<code>float</code>、<code>char</code>等</p>
<p>每个变量都有其固定用途，但实际上，我们并不一定要按其规定的用途使用它们：</p>
<blockquote>
<p><strong>不同变量类型之间的唯一区别，就是其所占的内存大小！</strong></p>
</blockquote>
<p>在计算机看来，所谓变量无非就是一些内存空间，里面都是一些数字而已</p>
<p>而变量类型其实是程序员对于变量用途的假设，其影响着计算机的输出逻辑</p>
<p>如数字65，其对<code>char</code>类型的变量代表字符A，而对<code>int</code>类型的变量代表整数65，他们在内存中并没有什么不同，不同的是我们对其的假设，不同的是其最后呈现给我们的方式</p>
<p><em><code>sizeof</code>关键字可以用于查询不同变量类型占的内存大小</em></p>
<hr>
<h2 id="函数（9）">函数（9）</h2>
<p>函数是我们编写的代码块，被设计用来执行特定任务</p>
<p>C++类中的代码块被称为方法，函数指的是类之外的代码块</p>
<p>函数的用处：避免代码的重复编写，便于程序的管理</p>
<p><em>但是需要注意的是，无意义地添加过多函数只会让程序变得凌乱，让代码难以管理</em></p>
<p>函数的全部特征：</p>
<ul>
<li>有函数头和函数体</li>
<li>可以接受参数</li>
<li>可以有返回值</li>
<li>需要有函数定义</li>
</ul>
<hr>
<h2 id="头文件（10）">头文件（10）</h2>
<p>C++的函数通常由两部分组成-<strong>声明与定义</strong></p>
<ul>
<li>声明意味着告诉编译器有这样一个函数存在，我们便可以在此翻译单元中调用该函数，每个翻译单元同一函数只能声明一次</li>
<li>定义则为函数的具体代码，程序中的每个函数只能被定义一次</li>
</ul>
<p>而当我们需要跨文件调用函数时，因为函数不能有二义性，我们便只能在需要调用函数的地方声明其存在</p>
<p>而<strong>头文件便是函数声明的集合</strong>，当我们需要调用某一函数，但其实现在别的地方时，我们便可以引入包含了该函数声明的头文件来声明其存在</p>
<p>这样一来我们便不需要在每次使用函数时都声明一遍了</p>
<p><em>需要注意的是，<code>.h</code>头文件与<code>.cpp</code>源文件实际上并没有本质区别，理论上我们同样可以在头文件中定义函数，但约定俗成的，我们不会这么做</em></p>
<p><strong>#pragma one</strong>：这一预处理语句代表着在同一翻译单元内，这一头文件只会被复制一次</p>
<p><strong>&lt; &gt;与“ ”</strong>：通常尖括号代表引入内部文件（<code>iostream</code>），而引号代表引入外部文件（如自己定义的头文件）</p>
<p><em>实际上，“”几乎可以引入任何文件，但我们通常使用&lt; &gt;来引入系统内部文件</em></p>
<p><em><code>iostream</code>作为C++标准库没有后缀名，这令人疑惑，实际上这是设计者为了和C语言的标准库<code>stdlib.h</code>进行区分，没有特别的意义</em></p>
<hr>
<h2 id="如何进行代码调试（11）">如何进行代码调试（11）</h2>
<p><strong>调试的方法</strong>：设置断点与读取内存</p>
<p><strong>调试（Debug）的意义</strong>：从代码中清除错误（看上去像是一句废话🤣），调试允许我们逐行逐句运行代码，并且实时检查内存中的数据</p>
<p><strong>断点</strong>：程序会在运行到断点行时暂停（断点行不会被运行）</p>
<p>在调试界面中，IDE会给我们提供许多的逐行逐句运行代码的方法，如VS提供的step into/over/out，实际应用中灵活使用即可</p>
<p>一个程序是由内存构成的，我们程序中的一切都储存在内存中，通过设定断点，我们可以暂停程序，在特定的时间检查特定的代码行中的内存情况</p>
<hr>
<h2 id="条件与分支（12）">条件与分支（12）</h2>
<p><code>if</code>语句包含一个condition和其statement，其代表的便是如果condition为真则执行statement</p>
<p>在汇编中，<code>if</code>语句实际上是一个<code>goto</code>，即如果condition为真，则跳转到某一部分的内存开始运行</p>
<p><strong>反编译Debug</strong>：当我们进行断点调试时，我们可以右击正在运行的行，点击“转到反汇编”，便可以看到我们的代码的汇编形式了（但是通过这种方式查错会是个nightmare，而且我也不会汇编，所以仅作了解啦🤐）</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305081957440.png" alt="image-20230508195728282" style="zoom: 33%;" />
<p>另外需要注意的是，<code>else if</code>其实并不是C++的关键字，实际上这只是将一个<code>if</code>包含在了<code>else</code>中，并且写在了一行，有点像一个语法糖🤣</p>
<hr>
<h2 id="关于VS的设置（13）">关于VS的设置（13）</h2>
<p><strong>如何用VS创建一个优雅的C++项目</strong></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305082014626.png" alt="image-20230508201433600" style="zoom:50%;" />
<p>我们在解决方案管理器中看到的这些文件夹其实都是虚文件夹，是被称为“filter筛选器”的东西，其对文件在磁盘中的组织没有任何影响，这只是一种标示，实际上你把文件放哪都行，对文件的实际位置没有任何影响</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305082017726.png" alt="image-20230508201724681" style="zoom:50%;" />
<p>我们可以通过点击“显示所有文件”来查看我们真正的项目文件夹</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305082049460.png" alt="image-20230508204920418" style="zoom:50%;" />
<p>通过设置属性管理项目文件夹</p>
<hr>
<h2 id="循环与控制流语句（14，15）">循环与控制流语句（14，15）</h2>
<p>循环的语法不再赘述</p>
<p>需要注意的是，<code>for</code>与<code>while</code>循环本质上其实并无区别，他们完全可以被用来做一样的事情</p>
<p>何时使用<code>for</code>，何时使用<code>while</code>更像一种习惯或风格，而不是规则</p>
<p>一般情况下，如果你有一个已经存在的确定的条件，如游戏中的loop，使用<code>while</code>更方便，这更接近与一种对状态的监控，因为条件不变，我们不需要在每次循环之后改变这个条件</p>
<p>而当我们需要处理一个状态会不断迭代的循环，如遍历一个确定长度的数组时，用<code>for</code>更方便</p>
<p>控制流语句：</p>
<ul>
<li><code>continue</code>-进入循环的下一个迭代，如果没有下一个迭代了，则直接跳出循环</li>
<li><code>break</code>-跳出循环，也会在switch中被用于跳出switch</li>
<li><code>return</code>-跳出当前函数，根据函数返回值类型返回对应值</li>
</ul>
<hr>
<h2 id="指针（16）">指针（16）</h2>
<p>指针是C++中最重要的概念之一，但实际上，它并没有我们想的那么复杂</p>
<p>要讨论指针，便应该先明白何为内存。内存，是计算机编程中最重要的东西，一切程序在运行时都储存在内存中，电脑通过访问这些内存来读取执行指令，同样的，变量也储存在内存中，当我们声明一个变量，其便会在内存中为其开辟一片内存空间。如果我们形象的去理解内存，内存便像一个无限长的纸带，纸带上有很多格子，每个格子包含一个地址与8个二进制位也就是1字节的数据。而指针便是一个储存了指定格子地址的变量。</p>
<blockquote>
<p><strong>指针是一个整数、一个储存内存地址的数字，指针就像其他变量一样，但其不是保存着某一变量的值本身，而是一个变量的内存地址，而内存地址同样是一个值，是一个整数</strong></p>
<p><strong>类型是无意义的！类型只是为了让我们处理数据更方便的一种虚构，一种抽象，所有类型的指针都是保存内存地址的整数</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 使用NULL/nullptr效果相同，NULL是0的宏定义，nullptr是C++11中的关键字代表空指针</span></span><br></pre></td></tr></table></figure>
<p>上述代码创造了一个空指针，这是我们可以创造的最简单的指针</p>
<p>**指针的大小：**也就是这个整数有多大，取决于很多东西，可能是16位/32位/64位的整数</p>
<p>**指针的逆向引用：**在指针前添加一个“*”代表对指针内容的逆向引用（<code>dereference</code>），这意味访问指针所指向的内存，如此我们便可以对指针指向的内存中的值进行读写</p>
<p>类型是我们告诉编译器的，我们对数据类型的设想，这样编译器就知道应该分配多大的内存空间了，但需要注意的是，是“我们告诉编译器的”，编译器自己并不知道某一数据的实际意义，以及我们说的到底对不对，**而指针中只有代表着内存地址的数字，而不包含数据，**这意味着一旦我们出错，程序便会出现问题</p>
<p><strong>Don’t over think it!</strong></p>
<hr>
<h2 id="引用（17）">引用（17）</h2>
<blockquote>
<p><strong>根本上，引用只是指针的伪装，只是在指针上的语法糖，使它们更易阅读和理解</strong></p>
</blockquote>
<p>引用（<code>references</code>）就像变量的别名或快捷方式，它不像指针一样作为一个新的变量存在与内存之中，其并没有真正的储存空间，其只是一个变量的引用（<code>reference</code>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line"><span class="comment">// 主要注意的是&amp;符号和前面的变量类型是一体的，而不是取地址</span></span><br></pre></td></tr></table></figure>
<p>上述代码创造了一个变量<code>a</code>的引用<code>ref</code></p>
<p><code>ref</code>实际上并不存在，其不是一个真正的变量，它只存在于我们的源代码中，编译运行时，编译器只会为<code>a</code>开辟内存空间</p>
<p>那么引用到底有什么用呢？</p>
<p><strong>下面是一个简单的例子:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Add</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们创造一个<code>Add</code>函数希望实现将传入值递增的效果，但实际上，这段代码没有任何意义，我们实际上是复制了变量<code>a</code>的值给了<code>value</code>，然后使<code>value</code>递增，这并不会实际影响<code>a</code>的值</p>
<p>而如果我们可以通过传入指针来解决这个问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>* value)</span></span>&#123;</span><br><span class="line">    (*value)++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Add</span>(&amp;a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改动后，我们将变量<code>a</code>的地址传入了<code>Add</code>函数，后通过指针的逆向引用改变了变量<code>a</code>的值，这可以实现我们想要的效果</p>
<p>但这会让代码添加很多繁杂的修饰，降低代码的可读性，而引用可以更方便的解决这一问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>&amp; value)</span></span>&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Add</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要将传入<code>Add</code>函数的参数改为int&amp;引用类型，使<code>a</code>作为引用传入即可，十分方便优雅</p>
<p>对于引用来说，没什么是引用能做而指针做不了的，其是指针的封装、语法糖，可以让代码变得更加简洁明了</p>
<p>但使用引用也有几个限制：</p>
<ul>
<li>声明引用必须立刻赋值，无法单独声明</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp; ref; <span class="comment">// 这是错误的语法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>引用赋值后引用对象无法改变；当我们需要改变对象时，我们可以使用指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br><span class="line"><span class="comment">// 这样写的结果是 a = 10 , b = 10</span></span><br><span class="line"><span class="comment">// ref仍然是a的引用</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="类（18）">类（18）</h2>
<p><strong>面向对象编程</strong>：一种编写代码的模式</p>
<p>Java/C#是面向对象的语言，而C由于没有类/对象的概念所以无法采用面向对象的模式，而C++并没有限定我们写代码的方式，我们可以像C一样面向过程的编程，同样也可以运用C++新添加的类等特性来使用面向对象的模式组织我们的代码</p>
<p>而“类（<code>class</code>）”是面向对象编程中最重要的特性之一，简单的说</p>
<blockquote>
<p><strong>类是一种将数据与功能组合在一起的一种类型</strong></p>
</blockquote>
<p>以下是一个<code>class</code>的实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> speed_;</span><br><span class="line">    <span class="type">int</span> posX_, posY_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        posX_ += x * speed;</span><br><span class="line">        posY_ += y * speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> health_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Player player = <span class="keyword">new</span> <span class="built_in">Player</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中我们创建了一个<code>Player</code>类，并在<code>main</code>函数中将其进行了实例化</p>
<p><code>Player</code>类中包含3个公共变量，1个公共方法（在类中的函数被称为方法），1个私有变量</p>
<p><code>player</code>是类型为<code>Player</code>的变量，称为“<strong>对象</strong>”，创建类对象的过程被称为<strong>实例化</strong></p>
<p><strong>类的本质是一种数据与方法的组织方式，一种语法糖，可以让我们的程序更加的简洁明了，其并不是万能的</strong></p>
<hr>
<h2 id="类与结构体的区别（19）">类与结构体的区别（19）</h2>
<blockquote>
<p><strong>几乎没区别</strong></p>
</blockquote>
<p>在技术上，类与结构体的唯一区别便是类中的变量与方法默认可见度为<code>private</code>，结构体则为<code>public</code></p>
<p>C++中<code>struct</code>得以存续的原因很大程度上源于对C的兼容性考虑，因为C中没有类</p>
<p>而在具体使用中，如何使用<code>struct</code>与<code>class</code>完全取决于每个人编程习惯与风格</p>
<hr>
<h2 id="如何写一个C-类（20）">如何写一个C++类（20）</h2>
<p>在接下来的几章中，我们将开始编写C++的类，将一个基础版本的类逐渐升级到更高版本的类，体会其中的过程与区别，这会让我们明白什么是”Good Code“</p>
<p>而我们将要编写的类是<strong>Log类</strong></p>
<p>Log类的功能是将信息输出到控制台，这听起来十分简单，但实际上这对我们的调试与开发非常重要，同时，其可复杂可简单，是一个非常好的例子</p>
<p>**需求分析：**我们将要实现的初级Log类包含<code>error</code>、<code>warning</code>、<code>message</code>三个层级，Log类可以通过这些层级对输出的东西进行控制</p>
<p>让我们开始写代码吧！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelMessage = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _logLevel = LogLevelMessage; <span class="comment">// 当前log等级</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span> <span class="comment">// 设置log等级</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _logLevel = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> <span class="comment">// 输出Error等级的信息</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_logLevel &gt;= LogLevelError)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Warning</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> <span class="comment">// 输出Warning等级的信息</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_logLevel &gt;= LogLevelWarning)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[WARNING]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Message</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> <span class="comment">// 输出Message等级的信息</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_logLevel &gt;= LogLevelMessage)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[MESSAGE]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log log;</span><br><span class="line">    log.<span class="built_in">SetLevel</span>(log.LogLevelWarning);</span><br><span class="line">    log.<span class="built_in">Error</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Warning</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Message</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码实现了我们的基本需求，但是实际上这并不能被称为什么“Good Code”，it just simple code.</p>
<p>之后我们会对Log类进行迭代，使其变得优雅易用</p>
<hr>
<h2 id="static静态（21，22，23）">static静态（21，22，23）</h2>
<p>取决于上下文，C++中的<code>static</code>关键字有多个意思：</p>
<ul>
<li><strong>当static在类/结构体外时：</strong><code>static</code>用于限定作用域，被<code>static</code>修饰的变量/函数只会在当前翻译单元的内部链接</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 翻译单元一</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻译单元二</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a; <span class="comment">// extern代表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，翻译单元二中的<code>extern</code>代表外部链接，其会为a变量在其他翻译单元中寻找链接，我们希望它能找到翻译单元一中的<code>a</code>，将其链接过来</p>
<p>但如果我们编译上述代码，我们会得到报错，因为翻译单元一中的<code>a</code>被<code>static</code>修饰了，这意味着其对链接器来说是不可见的，类似于类中的<code>private</code></p>
<ul>
<li><strong>当static在类/结构体内时：</strong><code>static</code>意味这共享实例内存，静态变量在你创建的所有类的实例中都只有一个实例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity::x = <span class="number">10</span>;</span><br><span class="line">    Entity::y = <span class="number">20</span>;</span><br><span class="line">    Entity::<span class="built_in">Print</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们可以发现我们并没有对结构体<code>Entity</code>进行实例化，但是我们仍然可以访问其中的静态变量<code>x</code>、<code>y</code>，静态方法<code>Print</code></p>
<p>在结构体与类中的静态近似于静态全局变量，但将其放在类中可以更好的帮我们组织代码，满天乱飞的全局变量将是非常灾难性的</p>
<p>需要注意的是，静态成员函数无法访问非静态成员变量，因为静态方法没有类实例，非静态方法都依赖于一个类实例而存在，静态方法的组织方法类似于在外部编写函数，当静态方法访问非静态成员变量时，其无法得知它们到底是什么，依赖于哪个实例存在，亦或者其根本没有实例</p>
<ul>
<li>**当static在局部作用域时：**被<code>static</code>修饰的变量声明周期会和程序一样长，不会被删除，但作用域仍然为当前局部</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们多次调用上述函数时，若变量<code>i</code>没有被<code>static</code>修饰，那么我们输出的将一直是1，但现在，<code>i</code>变量会不断递增</p>
<p>这与将i声明在函数外的效果相似，但区别是只有在<code>Add</code>函数的局部作用域中i才可以被访问</p>
<p>局部作用域中的<code>static</code>有时可以很大程度上帮我们优化代码，以下为其在单例实现中的应用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* _instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::_instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton::<span class="built_in">Instance</span>().<span class="built_in">Hello</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是单例的一种实现，但实际上，运用局部作用域的<code>static</code>可以实现一样的效果但大幅优化我们的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton _instance</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton::<span class="built_in">Instance</span>().<span class="built_in">Hello</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="枚举（24）">枚举（24）</h2>
<p>枚举<code>enum</code>是一个数值集合，是一种给值命名的方式，当我们想用整数来标示某些状态或数值时，我们便可以采用枚举来让其有更好的可读性</p>
<p>同时枚举也可以限定类型，让枚举类型的变量只能是枚举类型，但其背后代表的仍然只是一个整数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    Idle,</span><br><span class="line">    Attack,</span><br><span class="line">    Chase</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上是一个简单的枚举，我们也可以为枚举指定数值，数值可以是任意整数，如果我们不指定则默认从0开始递增</p>
<p>而在我们之前的Log类中，枚举便可以用来表示Log级别，以下是运用了枚举的Log类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Level</span></span><br><span class="line">    &#123;</span><br><span class="line">        LevelError,</span><br><span class="line">        LevelWarning,</span><br><span class="line">        LevelMessage</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Level _logLevel = LevelMessage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(Level level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _logLevel = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_logLevel &gt;= LevelError)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR]:&quot;</span> &lt;&lt; info &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Warning</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_logLevel &gt;= LevelWarning)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[WARNING]:&quot;</span> &lt;&lt; info &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Message</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_logLevel &gt;= LevelMessage)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[MESSAGE]:&quot;</span> &lt;&lt; info &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="构造函数（25）">构造函数（25）</h2>
<blockquote>
<p><strong>构造函数是一种特殊类型的方法，他在每次实例化对象时运行</strong></p>
</blockquote>
<p>在构造对象时，初始化对象中的变量是非常常见的需求，我们可以通过编写函数，在每次需要初始化时手动调用一遍该函数来实现这一需求，但这意味着我们需要在每次构造一个新对象时都调用一遍初始化函数，这非常的麻烦，所以**构造函数（constructor）**诞生了，每次你构建对象时构造函数都会被自动地调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()&#123; &#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数就像其他方法一样被定义，特殊的是其没有返回值，并且函数名需要与类/结构体名相同；如果我们没有定义构造函数，系统便会为我们自动生成默认的函数体为空的构造函数，即什么也不做</p>
<p><em>在Java与一些其他语言中，一些类型的变量如<code>float</code>、<code>int</code>会自动地被初始化为0，但是C++中并不是，我们需要手动地初始化所有的变量</em></p>
<p>需要注意的是，构造函数只有在实例化对象时才会被调用，调用类中的静态变量/函数不会实例化对象，所以也不会触发构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()&#123; &#125; <span class="comment">// 构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity::<span class="built_in">Hello</span>(); <span class="comment">// 此时Entity类的构造函数并不会被触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，我们也可以通过让构造函数私有化或使用<code>delete</code>方法删除构造函数的方式，使得类无法被实例化，这在我们只希望用户以静态方法的形式使用类时非常有用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Entity1</span>()&#123; &#125; <span class="comment">// 私有构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity1</span>() = <span class="keyword">delete</span>; <span class="comment">// 私有构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity1 e1;</span><br><span class="line">    Entity2 e2;</span><br><span class="line">    <span class="comment">// 上述两行都无法通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="析构函数（26）">析构函数（26）</h2>
<p><em>析构函数（Destructor）是构造函数的邪恶孪生兄弟（乐）</em></p>
<blockquote>
<p><strong>构造函数（Constructor）在实例化对象时运行，而析构函数（Destructor）则在销毁对象时运行</strong></p>
</blockquote>
<p>而同样的，在功能上，构造函数通常用来初始化变量，声明内存空间，而析构函数则常常用来卸载或销毁变量，释放内存空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~ <span class="built_in">Entity</span>()&#123; &#125; <span class="comment">// 析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数与构造函数在声明与定义时的唯一区别，就是放在析构函数前需要多加一个波浪号<code>~</code></p>
<hr>
<h2 id="继承（27）">继承（27）</h2>
<p>面向对象编程（OOP）是一个庞大的编程范式，而类之间的继承是其的一个基本方面，它是我们可以实际利用的最强大的特性之一</p>
<blockquote>
<p><strong>继承允许我们创建一个存在相互关联的类的层级结构，即我们可以基于一个公共基类创建子类</strong></p>
</blockquote>
<p>继承强大的主要原因是它可以帮助我们避免代码的重复，我们可以将相同的需要重复编写的代码放在一个公共基类中，这样其子类就都拥有了基类中的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* Name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.<span class="built_in">Move</span>(<span class="number">5</span>f,<span class="number">4</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>Player</code>类继承了<code>Entity</code>类，这意味着<code>Player</code>类拥有了<code>Entity</code>类中的所有代码</p>
<p>同时，继承可以引出OOP的另一个重要概念-<strong>“多态”</strong></p>
<p>多态即一个类型可以拥有多个类型，在上述例子中，<code>player</code>既是<code>Player</code>类也是<code>Entity</code>类，我们可以在任意需要<code>Entity</code>类的地方用<code>player</code>来进行，因为<code>player</code>拥有<code>Entity</code>类中的一切代码</p>
<hr>
<h2 id="虚函数（28）">虚函数（28）</h2>
<blockquote>
<p><strong>虚函数允许我们在子类中重写方法</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    std::cout &lt;&lt; e-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>();</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    Entity* e2 = p;</span><br><span class="line">    std::cout &lt;&lt; e2-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>Player</code>类继承于<code>Entity</code>类，它们中都有一个<code>GetName()</code>方法会输出一些东西，这看起来非常和谐，最后也确实输出了“Entity”与“Player”</p>
<p>但若我们引入OOP中的多态思想，那么问题便会出现，如果我们创建一个<code>Entity*</code>类型的指针<code>e2</code>指向<code>p</code>，再调用<code>e2</code>的<code>GetName()</code>方法，我们便会发现其只能输出“Entity”，但实际上该指针实际指向的是<code>Player</code>类型，这与我们的预期不符</p>
<p>问题的核心便是多态虽然为类带来了多类型，但是编译器只会依据声明的类型调用方法，但实际上我们传入的参数的类型不一定会是我们声明的类型，也有可能是其子类，这时<strong>虚函数</strong>就应该出场了</p>
<p>虚函数引入了一种叫做动态联编（Dynamic Dispatch）的东西，它通过虚函数表（v表）来实现编译，v表是一个包含了基类中的所有虚函数的映射表，这样我们在其运行时，便可以将虚函数映射到正确的覆写函数（override）上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，只需在对应方法前添加关键字<code>virtual</code>与<code>override</code>便可实现方法的覆写，现在<code>e2</code>可以正常输出“Player”了</p>
<p><em>其实<code>override</code>并不必须，但是为了可读性，咱们最好还是加上</em></p>
<p>虚方法会产生一定程度的额外内存与性能开销，但是实际上影响很小，who cares？用就完事了🤣</p>
<hr>
<h2 id="纯虚函数-接口（29）">纯虚函数/接口（29）</h2>
<p>纯虚函数是一种特殊类型的虚函数，其本质上与Java/C#中的抽象方法或接口相同</p>
<blockquote>
<p><strong>纯虚函数允许我们在基类中定义一个没有实现的函数，然后强制子类实现该函数</strong></p>
</blockquote>
<p>在OOP中，创建一个类，只由未实现的方法构成，然后强制子类实现它们，是非常常见的需求，我们常常称其为<strong>接口</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将一个虚方法的函数体删除，并使其等于0，便形成了一个纯虚函数，若其没有被某一子类实现，则该子类与其都无法进行实例化</p>
<p>接口（<code>interface</code>）通常作为对“类存在某一方法”的检查与保证而存在，C#中有专门的<code>interface</code>关键字，但C++中没有，C++的接口只是一个都是纯虚函数的类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">PrintName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;<span class="built_in">PrintName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如在上面的代码中，<code>Printable</code>类作为一个接口存在，其保证了其所有子类都一定实现了<code>PrintName()</code>方法，同时多态的特性使得其所有子类同时也是<code>Printable</code>类，这样<code>Print()</code>函数的参数中，将指向<code>Printable</code>类的指针传入即可，无需关心传入的具体类型，只需传入的类继承了<code>Printable</code></p>
<hr>
<h2 id="可见性（30）">可见性（30）</h2>
<blockquote>
<p><strong>可见性是一个属于OOP的概念，它指的是类的某些成员或方法实际上能被谁调用（类似于访问权限）</strong></p>
</blockquote>
<p><em>需要注意的是，可见性是对程序实际运行完全没有影响的东西，不影响性能与内存，它是纯粹存在在语言中的东西，只是为了帮你更好地组织代码</em></p>
<p><strong>C++中有且只有三个可见性修饰符：</strong></p>
<ul>
<li><code>public</code>：都可见</li>
<li><code>protected</code>：继承体系中都可见</li>
<li><code>private</code>：只有在类内与其友元（<code>friend</code>）可见</li>
</ul>
<p><strong>为啥不让一切<code>public</code>呢？</strong></p>
<p>为了让代码更加容易维护、容易理解，不管阅读代码还是拓展代码</p>
<p>代码是个错综复杂的东西，而可见性是一种”警告标示“，当一个方法/字段被标记为<code>private</code>时，这意味着这段代码的作者不希望其被外界调用，这告诉了别人“这不是你该碰的东西”，同时，也代表着修改这个可能带来意料之外的灾难</p>
<p>如一个UI类，你想修改一个UI的位置，直接访问这个类中的私有的<code>posX</code>，<code>posY</code>很可能并不会带来预期的结果，虽然内存中xy的值变了，但是显示器需要刷新，或许一些其他的东西需要修改，这一切你都无从得知</p>
<hr>
<h2 id="数组（31）">数组（31）</h2>
<blockquote>
<p><strong>数组是元素的集合，一般是一堆相同类型的变量</strong></p>
</blockquote>
<p>数组的定义非常简单，<code>类型 数组名[大小]</code>即可，如<code>int example[5]</code>定义了一个可以容纳5个整形变量的数组</p>
<p><em>当我们试图访问<code>example[-1]</code>/<code>example[5]</code>这样超出数组范围的内存时，在Debug模式中，程序会崩溃，但在Release模式中，你可能不会得到报错信息，这意味着你写入了不属于数组的内存，让一些不改被改变的内存改变了，这会导致非常难以Debug的后果，我们需要做好边界安全检查，尽量防止这种情况出现</em></p>
<p>关于数组最重要的一点是，其<strong>连续地储存数据</strong>，这意味着其将元素放到了一排进行储存，在内存上它们是连续地，如果我们有一个大小为5的整形数组，其便会连续地占据20个字节的内存，每个整形变量直接有这固定的内存偏移</p>
<p>关于<strong>数组的创建</strong>，存在着两种方法对数组进行创建，它们分别会将数组创建在<code>栈</code>或者<code>堆</code>中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> example[<span class="number">5</span>]; <span class="comment">// 栈中</span></span><br><span class="line">    <span class="type">int</span>* example2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 堆中</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建在栈中的变量在作用域结束时，其内存会被自动地释放</p>
<p>创建在堆中的则不同，需要我们通过<code>delete</code>关键字手动地对其内存进行释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] example2；<span class="comment">// 释放栈中的内存</span></span><br></pre></td></tr></table></figure>
<p>在C++11的库中，存在着内置的数组数据结构<code>std::array</code>,它有着许多优点，如边界检查、记录数组大小</p>
<p>而在原始的数组中，动态地取得数组的大小是一件非常困难、危险而不可靠的事，并不存在类似<code>size</code>的直接返回数组大小的字段或方法，要做到这件事，我们需要用到<code>sizeof(example) / sizeof(int)</code>的方法，但是我们经常采用指针来表示数组，如果传入的是指针而不是实际的数组那么我们将可能不会得到预期的结果；对于原始数组来说，我们通常需要手动维护一个<code>static</code>的常量来标示其大小</p>
<p>而对于<code>std::array</code>来说事情便会变得简单许多：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; example;</span><br><span class="line">    std::cout &lt;&lt; example.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>size()</code>方法我们可以轻松地获得数组大小，这的确会带来一些额外的开销，但也会让你的代码更加安全，anyway，who cares?🤣</p>
<hr>
<h2 id="字符串（32）">字符串（32）</h2>
<blockquote>
<p><strong>字符串本质上是一个连着一个的一连串字符，对于我们来说，这是一种能够表示和处理文本的方法</strong></p>
</blockquote>
<p>字符，即为<code>char</code>数据类型，而字符串实际上是字符数组，数组是元素的集合，故而字符串便是字符的集合，一组字符组成了字符串文本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;Hmxs&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这是C语言风格定义字符串的方式，C++中存在<code>string</code>库让一切变得简单，但是从源头了解它们如何工作仍然很重要</p>
<p>实际上在声明中，我们并不一定要加上<code>const</code>关键字，但人们通常这样做的原因是，不想改变字符串的值，因为字符串从整体是不可变的，这是一个固定分配的内存块*（在VS中，单独更改其中的某个字符是可行的，如果你希望这样做，就不能加上<code>const</code>，但通常我们不应该这样改变字符串，这可能导致未定义行为的错误，在一些编译器如Clang中，这种做法是被禁止的）*，如果你需要一个更大的字符串，你需要执行一个全新的分配并删除旧有的字符串</p>
<p><strong>在字符串数组的末尾都存在一个<code>\0</code>的空终止字符，其用来标示字符串的结束</strong>，因为字符串实际上是一个<code>char*</code>类型的指针，编译器并不能知道它有多大，需要一个特定字符作为标示，而当我们手动声明字符串数组时，如<code>char name[5]</code>我们需要手动的在其最后添加<code>‘\0’</code>或<code>0</code>作为空终止字符，否则字符串数组无法成立，并且在我们调用它时，其会不断向后寻址，知到遇到空终止字符，这将导致很多问题</p>
<p><strong>C++中的字符串：</strong></p>
<p>在上面的叙述中，我们已经了解了字符串到底是如何工作的了，是时候make things easier了</p>
<p>C++中的模板库<code>std::string</code>实际上只是一个<code>char</code>数组，其有着许多方法来帮助我们更方便地操作这个数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string name = <span class="string">&quot;Hmxs&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>直接使用<code>std::string</code>便可以声明一个字符串变量，string有一个构造函数，它接受<code>char*</code>或<code>const char*</code>参数</p>
<p>在<code>std::string</code>中存在着许多方便的方法，如重载过的<code>+=</code>运算符可以帮助我们快速链接两个字符串，而<code>size()</code>可以返回字符串长度，<code>find()</code>在字符串中进行查询，下面是一些用例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string name = std::<span class="built_in">string</span>(<span class="string">&quot;Hmxs&quot;</span>) + <span class="string">&quot;Hello&quot;</span>;<span class="comment">// 链接字符串法1</span></span><br><span class="line">    name += <span class="string">&quot;Hi!&quot;</span>; <span class="comment">// 链接字符串法2</span></span><br><span class="line">    <span class="type">bool</span> contains = name.<span class="built_in">find</span>(<span class="string">&quot;xs&quot;</span>) != std::string::npos; <span class="comment">// 查找匹配</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们传递std::string类型的变量作为参数时，我们通常不会直接传递它们，因为直接传递类对象实际上是一个复制的过程，而复制字符串意味着你需要在堆上重新分配一片内存空间并且进行字符串的复制，这个过程效率很低，故而我们通过采用被<code>const</code>修饰的引用来进行传递，<code>const</code>意味着不可变，我们承诺不会在这其中对字符串进行修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(<span class="type">const</span> std::string&amp; string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string name = <span class="string">&quot;Hmxs&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintString</span>(name);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="字符串字面量（33）">字符串字面量（33）</h2>
<blockquote>
<p><strong>字符字面量是在双引号之间的一串字符</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hmxs&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以像这样创建一个字符串字面量，而它最后会变成什么，取决于很多因素</p>
<p>在最基本的情况下，<code>&quot;Hmxs&quot;</code>会是一个const char数组，长度5，因为在字符串的最后需要存在空终止字符（若我们在字符串中间添加’\0’，会破坏字符串的构成）</p>
<p>在我们使用字符串字面量时，我们最好为我们的声明加上<code>const</code>，虽然VS的编译器允许我们使用<code>name[2] = ‘a’</code>这样的代码，但这往往是不可靠的，在release模式下，字符串字面量的内存会被储存在只读内存中，修改它们往往不会成功</p>
<p>C++还提供了许多额外的字符串类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">u8&quot;Hmxs&quot;</span>; <span class="comment">// 1字节</span></span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* name2 = <span class="string">L&quot;Hmxs&quot;</span>; <span class="comment">// 2字节 宽字符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char16_t</span>* name3 = <span class="string">u&quot;Hmxs&quot;</span>; <span class="comment">// 2字节</span></span><br><span class="line"><span class="type">const</span> <span class="type">char32_t</span>* name4 = <span class="string">U&quot;Hmxs&quot;</span>; <span class="comment">// 4字节</span></span><br></pre></td></tr></table></figure>
<p>关于字符串字面量的内存：字符串字面量<strong>永远</strong>保存在内存的只读区域内</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>C/C++</category>
        <category>TheCherno</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>【Algorithm4】读书笔记三：查找</title>
    <url>/posts/4003/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202409300327321.png" alt="algorithm4" style="zoom: 50%;" />
<blockquote>
<p><strong>官网：<a href="https://algs4.cs.princeton.edu/home/">https://algs4.cs.princeton.edu/home/</a></strong></p>
<p><strong>笔记目录：<a href="https://hmxs.games/posts/4000/">https://hmxs.games/posts/4000/</a></strong></p>
</blockquote>
<hr>
<h1>查找</h1>
<p>查找便是尽可能高效地在数据集合中定位特定元素的过程，而现代计算机和网络使我们能够得以访问到极其海量的信息，这时，查找便显得极为重要。本章将介绍一些经典查找算法。</p>
<p>符号表（字典）是对于查找的抽象数据结构实现，其最主要的目的就是将一个键（<code>key</code>）和一个值（<code>value</code>）联系起来，通过键我们便可以快速访问到值，而其实现有着多种方式，如二叉查找树、红黑树、散列表等，在本章中将着重介绍它们。</p>
<p><em>使用了C++对查找算法进行了重新实现，在<a href="https://github.com/hmxsqaq/Algorithm-Searching">这一Github仓库下</a>可以找到我的全部实现</em></p>
<h2 id="顺序查找符号表-Sequential-search-in-an-unordered-linked-list">顺序查找符号表 - Sequential search in an unordered linked list</h2>
<p>这是最简单的一种对于符号表的实现：我们可以使用链表来存储数据，在我们需要获取数据时，我们只需要从头一个个查找过去即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KEY, <span class="keyword">typename</span> VALUE&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SequentialSearchSymbolTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SequentialSearchSymbolTable</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (head_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Node* old = head_;</span><br><span class="line">            head_ = head_-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(KEY key, VALUE value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node* x = head_; x != <span class="literal">nullptr</span>; x = x-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;key == key) &#123;</span><br><span class="line">                x-&gt;value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head_ = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value, head_);</span><br><span class="line">        size_++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::optional&lt;VALUE&gt; <span class="title">get</span><span class="params">(KEY key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node* x = head_; x != <span class="literal">nullptr</span>; x = x-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> x-&gt;value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(KEY key)</span> </span>&#123;</span><br><span class="line">        Node* previous = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node* x = head_; x != <span class="literal">nullptr</span>; previous = x, x = x-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;key == key) &#123;</span><br><span class="line">                <span class="keyword">if</span> (previous != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    previous-&gt;next = x-&gt;next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    head_ = x-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> x;</span><br><span class="line">                size_--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(KEY key)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">get</span>(key).<span class="built_in">has_value</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head_ == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        KEY key;</span><br><span class="line">        VALUE value;</span><br><span class="line">        Node* next;</span><br><span class="line">        <span class="built_in">Node</span>(KEY key, VALUE value, Node* next) : <span class="built_in">key</span>(key), <span class="built_in">value</span>(value), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node* head_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">size_t</span> size_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上使用了C++简单地实现了一个顺序符号表，其使用了一个私有内部<code>Node</code>类来表示链表节点用于存储<code>KEY</code>与<code>VALUE</code>，<code>get</code>与<code>put</code>方法都会顺序地搜索链表查找给定值。</p>
<p>这种实现当然可以运行，但是其效率相对较低，其<code>get</code>与<code>put</code>方法都有着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>级别的时间复杂度，在面对大规模问题时会显得力不从心。</p>
<h2 id="二分查找符号表-Binary-search-in-an-ordered-array">二分查找符号表 - Binary search in an ordered array</h2>
<p>这种符号表的实现也较为简单，其通过一对平行数组，分别存储键与值，然后通过二分查找实现数据的插入与获取</p>
<p>通过使用二分查找替换遍历，这种实现可以将<code>get</code>方法的复杂度优化到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;Comparable KEY, <span class="keyword">typename</span> VALUE&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchSymbolTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(KEY key, VALUE value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">rank</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; keys_.<span class="built_in">size</span>() &amp;&amp; keys_[i] == key) &#123;</span><br><span class="line">            values_[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keys_.<span class="built_in">insert</span>(keys_.<span class="built_in">begin</span>() + i, key);</span><br><span class="line">        values_.<span class="built_in">insert</span>(values_.<span class="built_in">begin</span>() + i, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::optional&lt;VALUE&gt; <span class="title">get</span><span class="params">(KEY key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_empty</span>()) <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">rank</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; keys_.<span class="built_in">size</span>() &amp;&amp; keys_[i] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> values_[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(KEY key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">rank</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; keys_.<span class="built_in">size</span>() &amp;&amp; keys_[i] == key) &#123;</span><br><span class="line">            keys_.<span class="built_in">erase</span>(keys_.<span class="built_in">begin</span>() + i);</span><br><span class="line">            values_.<span class="built_in">erase</span>(values_.<span class="built_in">begin</span>() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns the number of keys in this symbol table strictly less than key.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(KEY key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = keys_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// prevent integer overflow</span></span><br><span class="line">            <span class="keyword">if</span> (key &lt; keys_[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; keys_[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::optional&lt;KEY&gt; <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_empty</span>()) <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">        <span class="keyword">return</span> keys_.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::optional&lt;KEY&gt; <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_empty</span>()) <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">        <span class="keyword">return</span> keys_.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::optional&lt;KEY&gt; <span class="title">select</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt;= keys_.<span class="built_in">size</span>()) <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">        <span class="keyword">return</span> keys_[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::optional&lt;KEY&gt; <span class="title">ceiling</span><span class="params">(KEY key)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">select</span>(<span class="built_in">rank</span>(key)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::optional&lt;KEY&gt; <span class="title">floor</span><span class="params">(KEY key)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">select</span>(<span class="built_in">rank</span>(key) - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(KEY key)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">get</span>(key).<span class="built_in">has_value</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> keys_.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> keys_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;KEY&gt; keys_;</span><br><span class="line">    std::vector&lt;VALUE&gt; values_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉查找树-Binary-Search-Tree">二叉查找树 - Binary Search Tree</h2>
<p>在上面的实现中，二叉查找树很好地优化了算法的速度，但因为要使用二分查找这种实现使用了数组存储数据，但这会让<code>put</code>方法的效率不够令人满意</p>
<p>或许我们需要链式地存储数据才能让插入操作变得快捷，那么应该如何在链式存储中使用二分查找解决问题呢？这就轮到<code>二叉查找树 - BST</code>出场了</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Algorithm</category>
        <category>《Algorithms, 4th Edition》</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Note</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏编程模式】读书笔记零：目录</title>
    <url>/posts/2000/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202305311339429.jpeg" alt="img"></p>
<blockquote>
<p><strong>《游戏编程模式》-Bob Nystrom</strong></p>
<p><strong>书籍汉化版网址：<a href="https://gpp.tkchu.me/">https://gpp.tkchu.me/</a></strong></p>
</blockquote>
<hr>
<p>《游戏编程模式》是一本介绍游戏开发中常用设计模式的书籍，它涵盖了许多常见的游戏编程问题，并提供了解决方案。这本书可以帮助游戏开发者更加高效地开发游戏，并提高代码的可重用性和可维护性</p>
<p><strong>以下是我学习《游戏编程模式》一书的读书笔记</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Introduction</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/2001/">《游戏编程模式》读书笔记 一</a></td>
<td style="text-align:center">序章：架构、性能与游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/2002/">《游戏编程模式》读书笔记 二</a></td>
<td style="text-align:center">重访设计模式：命令模式</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/2003/">《游戏编程模式》读书笔记 三</a></td>
<td style="text-align:center">重访设计模式：享元模式、观察者模式</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/2004/">《游戏编程模式》读书笔记 四</a></td>
<td style="text-align:center">重访设计模式：原型模式、单例模式</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/2005/">《游戏编程模式》读书笔记 五</a></td>
<td style="text-align:center">重访设计模式：状态模式</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/2006/">《游戏编程模式》读书笔记 六（更新中）</a></td>
<td style="text-align:center">序列模式</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Design Pattern</category>
        <category>《Game Programming Patterns》</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>《游戏编程模式》</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【The Cherno-C++】学习笔记二（34-66）</title>
    <url>/posts/1002/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306010145167.jpeg" alt="cherno"></p>
<blockquote>
<p><strong>B站up神经元猫翻译版：<a href="https://www.bilibili.com/video/BV1uy4y167h2">https://www.bilibili.com/video/BV1uy4y167h2</a></strong></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>C++因为其优异的性能，是游戏开发中最为常用的语言之一，目前的Unity与Unreal两大商用引擎的内核都是采用C++进行编写，作为一个有志于成为游戏开发者的人，这种语言怎么能不学一学呢？</p>
<p>本文基于油管著名博主，曾任职于EA的The Cherno的C++系列视频，The Cherno作为寒霜引擎的核心开发人员之一，对C++有着非常独到而深刻的理解</p>
<p>这些笔记记录了我通过The Cherno的系列视频学习C++的一些知识点与理解，希望对你有帮助😉</p>
<blockquote>
<p>第一章（1-33）：<a href="https://hmxs.games/posts/1001/">https://hmxs.games/posts/1001/</a></p>
<p><strong>第二章（34-66）：<a href="https://hmxs.games/posts/1002/">https://hmxs.games/posts/1002/</a></strong></p>
<p>第三章（67-99）：<a href="https://hmxs.games/posts/1003/">https://hmxs.games/posts/1003/</a></p>
</blockquote>
<hr>
<h2 id="const关键字（34）">const关键字（34）</h2>
<p><code>const</code>在改变生成的代码方面做不了什么，其有点类似类/结构体中的可见性</p>
<blockquote>
<p><strong><code>const</code>是一个可以让我们的代码变得更干净的机制，是对开发人员编写代码的强制特定的规则，被<code>const</code>修饰的东西被承诺不会被改变</strong>（但实际上，这个“承诺”是可以违背的，anyway，it just a promise.🤐）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// 这行代码会报错</span></span><br></pre></td></tr></table></figure>
<p>如上面的代码所示，被const修饰的变量的值无法被改变，如果我们希望定义一个在程序中永远不变的量，那么<code>const</code>便可以出场了</p>
<p><code>const</code>是一种声明变量的方式，而我们可以通过强制转换绕过<code>const</code>的限制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，我们让指针<code>a</code>指向了<code>const</code>的<code>MAX_AGE</code>,这样便绕过了<code>const</code>，但如果我们尝试通过逆向引用<code>a</code>来写入<code>MAX_AGE</code>便很可能导致程序崩溃，所以最好还是别这么干</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* b = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> c = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure>
<p>上面是三种声明<code>const</code>指针的方式，其中a与b效果完全一样，而c与ab的效果相反</p>
<p>在a与b中，修改ab本身是被允许的，而修改ab指向的内容是被禁止的，即<code>a = &amp;x</code>可行，而<code>*a = 2</code>不可行；而c的效果则与ab相反</p>
<p>当然我们也可以通过<code>const int* const a = new int;</code>来让<code>a</code>与``*a`的值都无法改变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> mutableX_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutableX_ = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> x_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintX</span><span class="params">(<span class="type">const</span> Entity&amp; entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是<code>const</code>的最后一种用法，在类中修饰方法（只能在类中这样用）</p>
<p>被<code>const</code>修饰的方法，只能对类中被<code>mutable</code>修饰的字段进行修改，如在上述<code>GetX()</code>方法中，若对<code>X</code>进行修改就会报错</p>
<p><strong>这种<code>const</code>有什么用呢？</strong></p>
<p>当我们以<code>const</code>传递类或类的引用时，只有类中的<code>const</code>方法才能被调用，因为<code>const</code>需要保证传入的引用的类无论如何都不会被更改，这种用法常常被用来修饰<code>getter</code>方法</p>
<p>在上面的代码中，如果<code>GetX()</code>方法没有被<code>const</code>修饰，那么在<code>PrintX()</code>中其便无法被调用</p>
<hr>
<h2 id="mutable关键字（35）">mutable关键字（35）</h2>
<p><code>mutable</code>关键字在C++中有着两种不同的用途</p>
<p>一是和<code>const</code>一起使用，在上一章的最后有提到，类中被<code>const</code>修饰的方法，只能对类中被<code>mutable</code>修饰的字段进行修改，这种情况往往发生在我们需要调试程序时（这是一种近似于违背承诺的行为，最好还是别大量使用，这会破坏<code>const</code>的意义）</p>
<p>二是用在<code>lambda</code>表达式中，<code>lambda</code>基本上就像一个一次性小函数，你可以写出来并赋值给一个变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span> </span><br><span class="line">&#123;</span><br><span class="line">    x++;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="comment">// x = 8</span></span><br></pre></td></tr></table></figure>
<p>在上面的<code>lambda</code>表达式中，如果我们想以值传递的形式传入<code>x</code>，并更改它，那么我们就必须加上<code>mutable</code>关键字</p>
<p>如果不使用<code>mutable</code>我们便需要创建一个局部变量来对<code>x</code>的值进行一次复制才能实现上面的效果</p>
<p><em>（当然其实这种用法非常非常少见，The Cherno说他其实完全没见过这么用的🤣）</em></p>
<hr>
<h2 id="成员初始化列表（36）">成员初始化列表（36）</h2>
<blockquote>
<p><strong>构造函数初始化列表是我们在构造函数中初始化类成员的一种方式</strong></p>
</blockquote>
<p>当我们编写类时，通常需要通过构造函数对类的成员进行初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        name_ = <span class="string">&quot;Default&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    &#123;</span><br><span class="line">        name_ = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们通常会这样来完成字段的初始化，而实际上C++还提供了另外一种语法来实现这件事</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">        : <span class="built_in">name_</span>(<span class="string">&quot;default&quot;</span>), <span class="built_in">age_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，<code>构造函数() : 字段1(初始值1), 字段2(初始值2)</code>通过这样的语法便可实现字段的初始化</p>
<p><em>需要注意的是，通过这种方法进行初始化时，初始化的顺序是由字段声明的顺序决定的，在上述代码中，即使我们写成<code>: age_(0), name_(&quot;default&quot;) </code>，运行时仍然会按照先<code>name_</code>再<code>age_</code>的顺序初始化，所以在编写初始化代码时，最好直接按照声明的顺序来</em></p>
<p><strong>为什么我们需要这玩意呢？</strong></p>
<ul>
<li>把琐碎繁杂的初始化写在一起，让代码更加整洁易读</li>
<li>在特定情况下，使用原先的初始化方式会造成性能/内存的浪费，如下面这个例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Create Example&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Create Example&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Example e_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        e_ = <span class="built_in">Example</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在<code>Entity</code>类中声明了<code>Example</code>类，并对其进行初始化，如果通过<code>e_ = Example(5)</code>的方式进行，那么<code>Example</code>的两个构造函数都会被运行，即<code>Create Example</code>与<code>Create Example5</code>都会被输出，其原因是在<code>Example e_</code>的创建中默认构造函数会先被调用，而使用初始化列表则不会有这个问题</p>
<p><strong>综上，我们应该在任何类的成员初始化场景用初始化列表来实现，我们没有理由不使用他们</strong></p>
<hr>
<h2 id="三元运算符（37）">三元运算符（37）</h2>
<blockquote>
<p><strong>三元运算符是if else语法的语法糖，可以方便地根据特定条件给变量赋值</strong></p>
<p><strong>语法：<code>变量名 = 条件判断 ? 为真时的值 : 为假时的值</code></strong></p>
</blockquote>
<p>三元运算符可以帮助我们清理我们的代码，增加代码的可读性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">y = x &gt; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面的两段代码的意思其实是完全相同的</p>
<p>同时，如果我们需要赋的值是引用类型，那么三元运算符还能些许加快运算的速度</p>
<p><strong>需要注意的是，虽然三元运算符可以嵌套，但大量嵌套的三元运算符可读性极差，和其初衷背道而驰，而且会很想让看你代码的人砍死你，所以最好还是别用</strong></p>
<hr>
<h2 id="对象的实例化（38）">对象的实例化（38）</h2>
<p>当我们编写完成了一个类之后，除非其是完全静态的，我们都需要对其进行实例化，而基本上，我们有两个实例化方法的选择：<strong>在栈上创建/在堆上创建</strong>，这两种方法的主要区别在于内存分配的位置</p>
<p>栈对象，拥有一个自动的生命周期，这由它们被声明的地方作用域决定，只要超出作用域，其内存便会被自动释放</p>
<p>而堆对象则不同，堆对象的内存需要我们进行手动释放</p>
<h3 id="栈对象">栈对象</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Entity e;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Entity e = <span class="built_in">Entity</span>();</span><br></pre></td></tr></table></figure>
<p>这样便可简单实例化一个类对象</p>
<p><em>与Jave/C#不同的是C++的<code>Entity e</code>并不单指声明，其效果等于<code>Entity e = Entity()</code>，会调用类的默认构造函数</em></p>
<p><strong>几乎所有时候，只要我们可以这样创建对象，我们都应该这样创建，这是C++中最快也是最易管控的实例化对象的方法</strong></p>
<h3 id="堆对象">堆对象</h3>
<p>当我们需要显式控制类的生命周期时 或 我们需要实例化的类很大/很多（栈的内存往往很小）时，我们便需要借助堆来实例化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br></pre></td></tr></table></figure>
<p>堆对象实例化的关键便是<code>new</code>关键字，当我们调用<code>new Entity</code>时，它在堆上为<code>Entity</code>类分配内存，并返回实例化的类在堆上被分配的内存地址</p>
<p><em>这与C#/Java中的语法相似，C#中的struct是在栈上的，而所有类都在堆上，而Java全在堆上</em></p>
<h3 id="尽量使用栈而不是堆">尽量使用栈而不是堆</h3>
<ul>
<li>
<p>性能问题：在堆上分配内存要比栈花费更长的时间</p>
</li>
<li>
<p>操作繁琐：堆需要手动释放内存（<code>delete</code>）</p>
</li>
</ul>
<hr>
<h2 id="new关键字（39）">new关键字（39）</h2>
<blockquote>
<p><strong><code>new</code>是一个操作符，主要作用是在堆上分配内存，其会根据你指定的类型在堆上找到对应大小的内存空间，并返回该空间的地址，对类来说，new还会调用构造函数</strong></p>
<p><strong>语法：<code>new 类型</code></strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">// C++风格</span></span><br><span class="line">Entity* e = (Entity*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Entity)); <span class="comment">// C风格</span></span><br></pre></td></tr></table></figure>
<p>上述两行代码的唯一区别便是<code>new</code>会调用构造函数，而<code>malloc</code>不会，大部分情况下<code>new</code>会调用<code>malloc</code>进行内存的分配</p>
<p><code>delete</code>关键字会释放堆中的内存，如果是类，其还会调用析构函数，其也是借用C中的<code>free</code>函数实现的，这点与<code>new</code>类似</p>
<p><strong><code>new</code>和<code>delete</code>总是应该成对出现，被<code>new</code>分配的内存只有在被<code>delete</code>释放后才能被再次使用</strong></p>
<hr>
<h2 id="隐式转换与explicit关键字（40）">隐式转换与explicit关键字（40）</h2>
<blockquote>
<p><strong>隐式代表不需要明确地告诉类要做什么，类似于自动，编译器会通过上下文自行推导构造函数</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(<span class="number">-1</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> age)</span><br><span class="line">        : <span class="built_in">name_</span>(<span class="string">&quot;Default&quot;</span>), <span class="built_in">age_</span>(age) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1 = <span class="string">&quot;Hmxs&quot;</span>; <span class="comment">// 隐式转换“Hmxs”-&gt;Entity(&quot;Hmxs&quot;)</span></span><br><span class="line">    Entity e2 = <span class="number">20</span>; <span class="comment">// 隐式转换20-&gt;Entity(20)</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当构造函数限定条件足够多时，如类的构造函数只接受一个字符串为参数，而你又正好让类等于了一个字符串，那么编译器会为你自行推导，生成构造函数</p>
<p>这很酷，可以简化代码，但清晰的代码才是最好的，还是少用吧</p>
<blockquote>
<p><strong><code>explicit</code>关键字则代表禁用该构造函数的隐式转换，如果你需要通过此构造函数进行类的实例化，那么你必须显式调用此构造函数</strong></p>
</blockquote>
<p><code>explicit</code>可以确保类型转换的安全，不会发生意外的隐式转换</p>
<hr>
<h2 id="运算符及其重载（41）">运算符及其重载（41）</h2>
<blockquote>
<p><strong>运算符是一种符号，通常代替一个函数来执行一些事情，如 <code>+ - * / += -&gt; &amp; &lt;&lt; new delete</code> 等</strong></p>
</blockquote>
<p>本质上运算符就是不用写函数名的函数，可以帮我们清理代码</p>
<p>而运算符重载的应用往往非常少，当我们需要运算符重载时，往往是类中一种特殊的类型需要处理或者类本身需要处理</p>
<p>如下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x + other.x, y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector2 <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x * other.x, y * other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们实现了一个<code>Vector2</code>结构体，并想要实现向量的加法与乘法，于是我们编写了<code>Add</code>与<code>Multipy</code>函数</p>
<p>但如果这样实现，最后在使用时很可能会变成这样<code>Vector2 result = pos1.Add(pos2.Multiply(pos3));</code>，虽然结果没问题但是可读性很差，使用起来也并不方便</p>
<p>这时使用运算符重载便可以清理我们的代码，让其变得更加直观</p>
<p><strong>我们只需更改函数名为<code>operate+/operate*</code>即可重载对应运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Vector2 <span class="keyword">operator</span>+(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x + other.x, y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector2 <span class="keyword">operator</span>*(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x * other.x, y * other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之后直接使用运算符即可<code>Vector2 result = pos1 + pos2 * pos3;</code>，代码一下子便清晰了许多</p>
<p><strong>下面是重载<code>&lt;&lt;</code>达成类输出的的一个例子：</strong></p>
<p>如果我们想输出一个上面的<code>Vector2</code>变量，直接<code>cout</code>将会报错<code>std::cout &lt;&lt; pos1 &lt;&lt; &quot;\n&quot;;</code>，而我们可以重载<code>&lt;&lt;</code>达成类似C#中<code>ToString()</code>的效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> Vector2&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>  stream &lt;&lt; other.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; other.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><code>cout</code>是C++中的流式输出方法，其实际是一个类型为<code>ostream</code>的流数据</em></p>
<p>重载过后便可以正常输出了<code>std::cout &lt;&lt; pos1 &lt;&lt; &quot;\n&quot;;</code></p>
<hr>
<h2 id="this关键字（42）">this关键字（42）</h2>
<blockquote>
<p><strong><code>this</code>是一个指向当前对象实例的指针，通过this可以访问类中的非静态字段方法</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面是一个<code>this</code>应用的例子，当我们传入的参数与类字段名相同时，<code>x = x</code>显然是有问题的,<code>this</code>可以帮助编译器进行区分</p>
<p>当然，<code>this</code>本身只是一个指针，一个指向当前对象本身的指针，我们可以在类中可以像使用其他指针一样使用它，比如<code>Entity* e = this</code></p>
<hr>
<h2 id="对象的生命周期（43）">对象的生命周期（43）</h2>
<p>作用域通常可以和一对大括号等价，而一旦超出作用域，作用域中的栈对象都会被释放</p>
<p><strong>下面是一个例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Create Entity&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroy Entity&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面这个简单的<code>Entity</code>类中，当其被创建时会输出&quot;Create Entity&quot;，而被释放时会输出&quot;Destroy Entity&quot;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Entity e;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的main函数中，<code>e</code>在栈中被创建，当运行到第5行时作用域结束，<code>e</code>被释放，&quot;Destroy Entity&quot;被输出</p>
<p>而如果我们通过堆来创建<code>e</code>时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有&quot;Create Entity&quot;会被输出</p>
<p><strong>下面是另外一个关于作用域的例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">CreateArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数尝试创建一个数组并返回其指针，但实际上这段代码是完全错误且无效的，<code>int array[50]</code>是以栈的方式创建数组，而在函数结束时，<code>array</code>的作用域便结束了，其内存会被释放</p>
<p><strong>作用域在限制我们的同时，也为我们提供了一些有用的特性，善用作用域可以帮我们实现很多功能</strong></p>
<p><strong>以下是一个利用作用域实现堆对象自动销毁的例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* ptr_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* ptr)</span><br><span class="line">        : <span class="built_in">ptr_</span>(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ScopedPtr</code>包裹了一个<code>Entity</code>类的指针，在栈中创建<code>ScopedPtr</code>对象，当其超出作用域被自动销毁时，其会自动调用析构函数，在析构函数中释放包裹着的<code>Entity</code>类，以此便实现了堆<code>Entity</code>对象的自动销毁</p>
<p>除此之外作用域与生命周期还有很多妙用，如自动计时的Timer类，会在之后进行介绍</p>
<hr>
<h2 id="智能指针（44）">智能指针（44）</h2>
<blockquote>
<p><strong>智能指针本质上是一个原始指针的包装</strong></p>
<p><strong>当你使用智能指针时，它会调用new为你分配内存，然后基于你使用的智能指针，这些内存会在某一时刻被自动释放</strong></p>
</blockquote>
<h3 id="unique-ptr"><code>unique_ptr</code></h3>
<p><code>unique_ptr</code>是作用域指针，当超出作用域时，它会被销毁然后调用delete；其不可复制，因为这会导致两个指针指向相同的内存，当其中一个将内存释放后，另一个便会指向已经被释放的内存，这会带来问题</p>
<p><em>要使用智能指针我们需要引入<code>memory</code>头文件</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity1</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity2 = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();</span><br></pre></td></tr></table></figure>
<p>以上是两种<code>unique_ptr</code>的使用方式，后者对异常处理更加友好</p>
<p><em>需要注意的是<code>unique_ptr</code>的构造函数是<code>explicit</code>的，需要显式调用</em></p>
<p>使用<code>unique_ptr</code>声明的<code>entity1</code>和<code>entity2</code>都会在作用域结束时被销毁</p>
<p><strong><code>unique_ptr</code>是最简单的智能指针，是有用且低开销的，缺点是其不能复制</strong></p>
<p><em><code>std::unique_ptr&lt;Entity&gt; entity3 = entity2;</code>&lt;-为了防止我们写出这种代码，尝试去复制<code>unique_ptr</code>，<code>unique_ptr</code>的复制构造函数和<code>=</code>操作符都被删除了，这样的代码会直接报错</em></p>
<h3 id="shared-ptr"><code>shared_ptr</code></h3>
<p><code>shared_ptr</code>是共享指针，在大部分编译器中，其通过引用计数实现了智能指针的共享，每当共享指针被复制时，其内部的引用计数便会加一，当共享指针被释放时，引用计数便会减一，当引用数量为0时，共享指针才会真正释放其指向的内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Entity&gt; <span class="title">entity1</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">std::shared_ptr&lt;Entity&gt; entity2 = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br></pre></td></tr></table></figure>
<p>我们仍有两种方式使用<code>shared_ptr</code>，但对于<code>shared_ptr</code>来说，后者明显更好</p>
<p><em>在<code>unique_ptr</code>中使用<code>make_unique</code>带来的优势仅仅是会抛出异常，但对于<code>shared_ptr</code>来说，因为其需要声明一块专用的控制块内存用于存储应用计数，通过<code>new</code>进行内存分配再传递给<code>shared_ptr</code>会带来两次内存分配，而使用<code>make_shared</code>则可以将两次内存分配组合在一起，获得更好的效率</em></p>
<h3 id="weak-ptr"><code>weak_ptr</code></h3>
<p><code>weak_ptr</code>通常和<code>shared_ptr</code>一起使用，<code>weak_ptr</code>可以被复制，但是同时不会增加引用计数，仅仅声明这个指针还活着</p>
<p>同时<code>weak_ptr</code>可以查询其指向的内存块是否被释放了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;Entity&gt; weak = entity2;</span><br></pre></td></tr></table></figure>
<h3 id="什么时候应该使用智能指针">什么时候应该使用智能指针</h3>
<p>根据实际情况而定，当你不需要手动管理内存时，智能指针会非常方便</p>
<p>在使用智能指针时，<code>unique_ptr</code>应该被优先考虑，因为其几乎没有开销，而当我们需要共享数据而<code>unique_ptr</code>无法实现时，<code>shared_ptr</code>就应该被使用了，即使其会带来一些额外的开销</p>
<hr>
<h2 id="复制构造函数（45）">复制构造函数（45）</h2>
<blockquote>
<p><strong>拷贝指的是复制数据/内存，让一份数据拥有多个副本</strong></p>
</blockquote>
<p>拷贝往往会耗费很多时间，但也会让我们得以实现很多功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = a;</span><br></pre></td></tr></table></figure>
<p>上面就是一个简单的值拷贝的过程，<code>a</code>和<code>b</code>是两个独立的变量</p>
<p>而当我们使用<code>new</code>来分配内存时，事情就会有些不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* a = new int(1);</span><br><span class="line">int* b = a;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们同样进行了一次拷贝，但是这次拷贝的是指针，这意味着我们创造了两个保存着相同地址的指针</p>
<p>但是无论如何，当你使用<code>=</code>，即赋值操作符时，你总是在拷贝值</p>
<p><em>除引用之外，因为引用仅仅是别名，我们无法重新分配引用，只能改变其指向，并不是拷贝</em></p>
<p><strong>下面会实现一个原始的字符串类，尝试让其具有可复制性：</strong></p>
<p><em>这个字符串类将只采用C++的原始特性进行编写，为了让其更有教学意义</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* buffer_;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">    &#123;</span><br><span class="line">        size_ = <span class="built_in">strlen</span>(string);</span><br><span class="line">        buffer_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer_, string, size_);</span><br><span class="line">        buffer_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; string.buffer_;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码实现了一个基本的<code>String</code>类，其会自动分配分配/销毁内存，并且重载了<code>&lt;&lt;</code>操作符，让其可以接受流输出</p>
<p>这看起来很完善，但当我们尝试拷贝一个<code>String</code>类时，如下面的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String string = <span class="string">&quot;Hmxs&quot;</span>;</span><br><span class="line">String copy = string;</span><br></pre></td></tr></table></figure>
<p>但当程序结束时，程序会崩溃，这是因为我们实际上进行的是一次浅拷贝，在<code>copy</code>实际拷贝的是<code>string</code>中的<code>char</code>类型指针，并没有重新进行堆内存的分配，所以当程序结束时，会运行两次<code>delete[] buffer_</code>去释放同一片内存，导致了程序的崩溃</p>
<p><strong>而如何使复制时进行深拷贝呢？</strong></p>
<p>我们可以创造一个新函数返回一个字符串，但这不够优雅，我们应该使用的方法是-<strong>拷贝构造函数</strong></p>
<blockquote>
<p><strong>拷贝构造函数是一个构造函数，当你在进行拷贝操作，将一个变量的值拷贝给另一个变量，也就是使用<code>=</code>，并且<code>=</code>左右两边变量类型相同时，会调用的构造函数</strong></p>
</blockquote>
<p>使用<code>类名(const 类名&amp; 变量名)&#123;&#125;</code>即可构建拷贝构造函数（如果不手动设定，C++会提供默认的拷贝构造函数）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    : <span class="built_in">size_</span>(other.size_)</span><br><span class="line">&#123;</span><br><span class="line">    buffer_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer_, other.buffer_, size_ + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来，程序便不会崩溃了</p>
<p>但是仍有一点我们需要注意，只要我们对<code>String</code>类型的变量进行值的传递，如传递给一个函数，其就会对自己进行一次深拷贝，这会非常影响效率，而我们可以通过引用的方式进行值的传递，如<code>Print(const String&amp; other)</code>,这样一来传递的便是变量本身，而非其复制了</p>
<p>在使用引用传值时，<strong>总是、总是、总是使用const引用传递对象</strong>，这会帮我们避免很多问题</p>
<hr>
<h2 id="箭头操作符（46）">-&gt;箭头操作符（46）</h2>
<blockquote>
<p><strong><code>x</code>是一个指针，拥有一个<code>print</code>方法，则<code>x-&gt;print()</code> = <code>(*x).print()</code></strong></p>
</blockquote>
<p>当我们想要通过指针访问类中的字段/方法时，我们往往需要先对指针做逆引用运算后，再使用<code>.</code>运算符访问其中的方法/字段，同时因为运算符优先级的问题，为了达到我们需要效果我们还需要加一个括号，最后的代码便需要写成<code>(*x).</code>，这写起来非常笨重；我们也可以通过在外面包一层引用来解决这个问题，但是这同样需要多写一行；此时箭头操作符便应运而生了，箭头操作符是上述操作的一个快捷方式而已</p>
<p>以上就是<code>-&gt;</code>箭头操作符的默认用法了，而作为一个操作符，我们同样可以重载它，<strong>以下是一个例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* obj_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* entity)</span><br><span class="line">        : <span class="built_in">obj_</span>(entity) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> obj_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们手动实现了一个Entity的智能指针类，此时我们便可以通过<code>ScopedPtr</code>来声明堆中的<code>Entity</code>类，但此时，通过<code>ScopedPtr</code>声明的类无法通过<code>-&gt;</code>操作符访问其中的方法，因为实际的类是<code>ScopedPtr</code>中的成员变量，此时我们便可以通过重载箭头操作符来达成我们想要的效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Entity* <span class="keyword">operator</span>-&gt; () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> obj_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载箭头操作符使其返回<code>ScopedPtr</code>中的成员变量即可</p>
<hr>
<h2 id="动态数组std-vector（47）">动态数组<code>std::vector</code>（47）</h2>
<blockquote>
<p><strong>动态数组是指不定长的数组，我们创建它时不需要给定固定的内存空间，其会在运行时进行空间的动态分配</strong></p>
</blockquote>
<p>C++STL中的动态数组被称为<code>vector</code>，但它实际上并不是数学意义上的“向量”，也不是C#中的Vector2/Vector3，其实际更像一个<code>ArrayList</code></p>
<p><em>至于它为什么起了个这么奇怪的名字，听说故事很复杂🤣</em></p>
<p><strong>下面是C++STL中<code>vector</code>的基本使用方法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> <span class="comment">// 任意数据类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; stream, <span class="type">const</span> Data&amp; data)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; data.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; data.y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; data.z;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// vector的创建</span></span><br><span class="line">    std::vector&lt;Data&gt; vectors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector元素的添加</span></span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素删除</span></span><br><span class="line">    vectors.<span class="built_in">erase</span>(vectors.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历方法一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vectors.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; vectors[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 遍历方法二</span></span><br><span class="line">    <span class="keyword">for</span> (Data&amp; date : vectors)</span><br><span class="line">        std::cout &lt;&lt; date &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，传递<code>vector</code>时务必使用引用进行传递，防止对整个<code>vector</code>进行复制</strong></p>
<hr>
<h2 id="std-vector使用优化（48）"><code>std::vector</code>使用优化（48）</h2>
<p>虽然C++为我们提供了STL，但是STL中的数据结构在设计过程中，其性能往往不是最优先考虑的要素，而C++的<code>vector</code>在每次需要扩充数组容量时，都会先分配一个新的更大的空间，将原先的数据复制到新空间中，再删除原先的空间，这听上去性能就很差，而如果我们没有正确地使用它，这种分配往往会经常发生。</p>
<p><strong>下面是一种更好地使用<code>vector</code>类的方式，让<code>vector</code>的效率更高：</strong></p>
<p>先来看一个反面教材</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> Data&amp; other)</span><br><span class="line">        : <span class="built_in">x</span>(other.x), <span class="built_in">y</span>(other.y), <span class="built_in">z</span>(other.z)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Data&gt; vectors;</span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line">    vectors.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>Data</code>类是一个普通的数据类，其在每次被复制时都会输出一个“<code>Copy</code>”，我们创建了一个<code>vector</code>变量，并通过<code>push_back</code>方法向其中添加了3个元素，这看起来一点毛病没有，但如果我们运行这段代码，我们会发现有6个<code>Copy</code>被输出了，这意味着在加入元素的过程中，<code>Data</code>被复制了6次，这太糟糕了</p>
<p>而造成这6次复制的原因有两个：类的实例化 与 <code>vector</code>的扩容</p>
<ul>
<li>
<p>类的实例化：在上述代码中，我们是在栈中实例化类的，而使用<code>push_back</code>方法会先在栈中给类分配内存，再将对象移动到<code>vector</code>变量处，这一过程便会进行一次类的复制；而解决方法也非常简单，<strong>将<code>push_back</code>替换为<code>emplace_back</code>即可</strong>，<code>emplace_back</code>会直接在<code>vector</code>变量的内存处构建类，省去了复制过程</p>
</li>
<li>
<p><code>vector</code>的扩容：C++的<code>vector</code>在每次需要扩充数组容量时，都会先分配一个新的更大的空间，将原先的数据复制到新空间中，再删除原先的空间；而<strong>我们可以通过<code>reserve</code>方法为vector设定初始的容量</strong>，这样在达到容量上限前都不会进行空间的复制</p>
</li>
</ul>
<p>通过上述两个方法优化代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Data&gt; vectors;</span><br><span class="line">    vectors.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">    vectors.<span class="built_in">emplace_back</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    vectors.<span class="built_in">emplace_back</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    vectors.<span class="built_in">emplace_back</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行，我们可以发现一个<code>Copy</code>都没有输出，说明一次复制行为都没有发生，这大大提高了效率；要知道在原先的代码下，复制次数会随元素添加次数的增加而呈指数级增加，这对性能的损耗将是可怕的</p>
<hr>
<h2 id="库的使用（49、50）">库的使用（49、50）</h2>
<p>在python、C#、Java等语言中，添加库是一项非常简单的任务，但是在C++中，似乎这里成了问题的重灾区，而实际上在C++中添加库并不困难</p>
<p><strong>以下将通过链接二进制文件的形式在C++中链接GLFW库：</strong></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260202572.png" alt="image-20230626020227432" style="zoom: 67%;" />
<p>下载解压GLFW预编译二进制文件后，我们便可以得到上述文件，它们主要由两部分组成：include文件与lib文件，它们分别对应头文件与具体的函数实现，而对于这两部分我们都需要进行加载</p>
<p><em>C++存在着两种库：静态库（.lib）与动态库（.dll），它们基本的区别是静态库会被编译进exe文件中，而动态库则是在运行时装载的，之后会有篇章专门介绍他们</em></p>
<p>下面是两种库引入方式的介绍：</p>
<h3 id="静态链接">静态链接</h3>
<p>将include文件夹与对应平台的lib文件夹复制到项目文件夹中，而在lib文件夹中我们可以看到三个文件</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260214664.png" alt="image-20230626021447618"></p>
<p>其中<code>glfw3.lib</code>为静态库，而<code>glfw3.dll</code>为动态库，<code>glfw3dll.lib</code>为动态库的导入库，其中包含了动态库中所有函数、符号的位置，以便我们进行使用（没有它我们也可以使用动态库，但是我们需要通过函数名来访问它）</p>
<p>要链接到库，我们首先需要将其头文件包含到项目中，我们可以在<code>属性/C++/常规/附加包含目录</code>将库文件夹包含在项目中，如下图所示</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260227665.png" alt="image-20230626022703597" style="zoom:67%;" />
<p>之后即可在代码中使用<code>#include &quot;GLFW/glfw3.h&quot;</code>引入头文件了，但到这里我们仅仅只是引入了头文件，并没有包含函数的实现，而这一步需要我们在链接器选项中进行操作</p>
<p>在<code>属性/链接器/常规/附加库目录</code>中添加库文件夹的地址</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260234490.png" alt="image-20230626023444430" style="zoom:67%;" />
<p>在<code>属性/链接器/输入/附加依赖项</code>中添加<code>glfw3.lib</code></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202306260235757.png" alt="image-20230626023557693" style="zoom:67%;" />
<p>即可完成库文件的包含，到此我们便可以在程序中调用库函数了</p>
<h3 id="动态链接">动态链接</h3>
<p>静态链接发生在编译时，而动态链接发生在运行时</p>
<p>在静态链接时，编译器和链接器会知道完全的库的代码，所以会允许更多的优化发生</p>
<p>而动态链接则只有在你运行exe文件时，库才会被加载，其实际上不是可执行文件的一部分</p>
<p>那么应该如何使用动态链接呢？</p>
<p>其实只需要<code>属性/链接器/输入/附加依赖项</code>中加入<code>glfw3dll.lib</code>即可</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202307180302256.png" alt="image-20230718020213161"></p>
<p>因为GLFW支持静态链接与动态链接都使用同一个头文件，所以我们的<code>include</code>也不需要更改</p>
<p>做完这一步之后，我们已经可以编译通过了，但是在运行时仍然会报错，这便是因为到此我们已经向编译器保证了<code>dll</code>库会存在，但实际上在运行时程序还是需要找到对应的<code>dll</code>文件的，而程序会默认在exe文件的根目录中寻找<code>dll</code>文件，所以我们只需将<code>dll</code>文件和<code>exe</code>文件放在一起便大功告成了，而我们同样可以手动指定程序对于<code>dll</code>文件的搜索范围。</p>
<hr>
<h2 id="处理多返回值（52）">处理多返回值（52）</h2>
<p>在C++的默认情况下，是无法返回多个类型的返回值的，但我们可以通过一些手段来实现这一点</p>
<p>下面是一些方法的总结：</p>
<ol>
<li><strong>使用引用/指针传入外部值后，在内部修改</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultipleReturnValue</span><span class="params">(std::string&amp; outValue1, <span class="type">int</span>&amp; outValue2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outValue<span class="number">1.</span><span class="built_in">append</span>(<span class="string">&quot; Hello&quot;</span>);</span><br><span class="line">    outValue2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string value1 = <span class="string">&quot;NiHao&quot;</span>;</span><br><span class="line">    <span class="type">int</span> value2 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">MultipleReturnValue</span>(value1, value2);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value1: &quot;</span> &lt;&lt; value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value2: &quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：效率最高；可以返回任意数量、任意类型的值</p>
<p><strong>缺点</strong>：看着比较乱，不够直观</p>
<ol start="2">
<li><strong>使用<code>std::array</code>/<code>std::vector</code></strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">MultipleReturnValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::vector&lt;std::string&gt;&#123; <span class="string">&quot;Hello1&quot;</span>,<span class="string">&quot;Hello2&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vector = <span class="built_in">MultipleReturnValue</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value1: &quot;</span> &lt;&lt; vector[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value2: &quot;</span> &lt;&lt; vector[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：好像没什么优点</p>
<p><strong>缺点</strong>：只能传递一种类型；得到返回值时无法显示变量名</p>
<ol start="3">
<li><strong>使用<code>std::tuple</code>/<code>std::pair</code></strong></li>
</ol>
<p><code>tuple</code>和<code>pair</code>都不关心其中的变量类型，其余与<code>array</code>和<code>vector</code>类似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">MultipleReturnValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> tuple = <span class="built_in">MultipleReturnValue</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value1: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tuple) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value2: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tuple) &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：与<code>array</code>和<code>vector</code>相比，可以传递多类型了</p>
<p><strong>缺点</strong>：得到返回值时无法显示变量名，且解包写法十分繁琐</p>
<ol start="4">
<li><strong>使用自建结构体传递返回值</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ReturnValues</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string Value1;</span><br><span class="line">    <span class="type">int</span> Value2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ReturnValues <span class="title">MultipleReturnValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> returns = <span class="built_in">MultipleReturnValue</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value1: &quot;</span> &lt;&lt; returns.Value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value2: &quot;</span> &lt;&lt; returns.Value2 &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：清晰明了，可读性高，写法简单；可传递任意类型、任意数量的变量；解包可以显示变量名</p>
<p><strong>缺点</strong>：与方法1相比效率稍差</p>
<blockquote>
<p><strong>总的来说，法1与法4较为实用</strong></p>
</blockquote>
<hr>
<h2 id="模板template（53）">模板<code>template</code>（53）</h2>
<p>C++的<code>template</code>有点类似其他语言中的泛型<code>Generic</code>，但实际上<code>template</code>比泛型要强大地多</p>
<p>模板有点像宏，它实际上可以帮你完成非常多的事情，而泛型往往受限与类型系统以及其他很多因素</p>
<blockquote>
<p><strong><code>template</code>允许你定义一个可以根据你想要的用途进行编译的模板，你可以编写一套规则，来让编译器帮你写代码</strong></p>
<p><strong>这有点像一种蓝图，你只需要制定规则，而实际的生产由编译器进行</strong></p>
</blockquote>
<p>当我们想要编写一系列函数，其大部分内容都相同，只是接受的参数不同时，我们便可以使用<code>template</code>，下面是一个例子：</p>
<p>我们想要编写一个<code>Print</code>函数，让其可以分别输出整数、浮点数、字符串，我们通常需要创建多个函数重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">float</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(std::string value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1.1f</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要增加更多类型我们就需要更加跟多重载，这可行，但是非常麻烦，而使用<code>template</code>可以大幅简化代码，就像下面这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1.1f</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><code>T</code>可以自定义，如<code>typename Hmxs</code>同样可以</em></p>
<blockquote>
<p><code>template</code>函数实际上并不真实存在，实际的函数会在被调用时被自动创建</p>
</blockquote>
<p>而在上面的代码中，在我们调用<code>Print</code>函数时，实际包含了一层隐式的类型推导，如在<code>Print(1)</code>中，编译器知道<code>1</code>是一个整数，所以其创建了一个<code>T</code>为<code>int</code>的<code>Print</code>函数</p>
<p>而实际上我们同样可以在调用模板函数时显式地指定类型，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Print</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>上面是一种<code>template</code>在函数中的简单应用，而<code>template</code>实际完全不局限与函数中</p>
<p>如我们想创建一个自定义的在栈中生成的<code>Array</code>类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T array_[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; m_array&#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; m_array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>如此强大！</code></strong></p>
<p>而这其实也只是<code>template</code>应用的冰山一角，大量使用<code>template</code>的编码方式被称为meta programming元编程</p>
<p>但实际上，任何事情都有两面性，<code>template</code>十分强大，但过分使用它会让你的代码的可读性降低，以至于你不得不为理解<code>template</code>而花费更多地时间</p>
<p>当一个基于<code>template</code>的系统变得过于深入与庞大时，将是非常疯狂的，没人会知道这玩意是怎么运行的</p>
<p>So, we should balance them well.</p>
<hr>
<h2 id="堆与栈内存的比较（54）">堆与栈内存的比较（54）</h2>
<p>栈（<code>stack</code>）内存和堆（<code>heap</code>）内存是ram中实际存在的两个区域</p>
<p>栈通常是一个预定义大小的内存区域，通常约为2兆字节左右；堆也是一个预定了默认值的区域，但堆内存可以生长，并随着应用程序的进行而改变</p>
<p>而最重要的是，这两个内存区域的实际位置（物理上），在我们的ram中是完全一致的</p>
<p><strong>为什么栈会比堆快？</strong></p>
<p>在栈上分配内存，其实只是一行cpu指令：将栈头指针移动一定的字节</p>
<p>而在堆上进行内存分配则复杂地多，cpu需要记录许多信息</p>
<hr>
<h2 id="宏Macro（55）">宏<code>Macro</code>（55）</h2>
<blockquote>
<p><strong>宏主要在预处理阶段发挥作用，我们可以通过宏将代码中的文本替换为其他东西，这基本上就像遍历我们的代码然后进行查找和替换，但实际上并没有那么简单粗暴</strong></p>
</blockquote>
<p>这听起来有点像之前说到的模板<code>template</code>，但宏发生作用的时间会比模板更早</p>
<p>下面是一个宏的使用例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT std::cin.get()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用<code>WAIT</code>替代了<code>std::cin.get()</code></p>
<p>这看上去更简洁了，<strong>但实际上这是非常错误的用法</strong>，用宏去替换原来理所应当的代码，只会让看代码的人觉得疑惑</p>
<p>而下面这种宏函数的用法则是合理的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(message) std::cout &lt;&lt; message &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>宏函数的优点</strong>：没有普通函数保存寄存器、参数传递和返回值传递的开销，展开后代码效率会更高</p>
<p>同时我们可以使用宏定义来区分<code>Debug</code>模式与<code>Release</code>模式的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG(message) std::cout &lt;&lt; message &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG(message)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="auto关键字（56）"><code>auto</code>关键字（56）</h2>
<blockquote>
<p><strong><code>auto</code>的作用非常简单，它可以为我们自动推导变量的类型，它在某些时候十分有效，但我们不应该滥用它</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">GetHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> hello = <span class="built_in">GetHello</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个<code>auto</code>的使用例，我们用其来接收函数的返回值</p>
<p>其一个好处便是，如果我们的函数返回值类型发生了变化，如果我们使用了auto，那么我们便不需要再改动接收处的变量类型了</p>
<p>但这也是一把双刃剑，这也意味着，如果我们接下来的代码中有用到原来的类型特性，那么便会带来更大的问题，这降低了可读性</p>
<p>这种用法见仁见智</p>
<p><code>auto</code>还有一种用法便是简化类型，当我们面对一个极其长的类型名时，我们便可以使用<code>auto</code>，这样反而会增加可读性，如下面这个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; name_vector;</span><br><span class="line">    name_vector.<span class="built_in">emplace_back</span>(<span class="string">&quot;Hmxs&quot;</span>);</span><br><span class="line">    name_vector.<span class="built_in">emplace_back</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;std::string&gt;::iterator iterator = name_vector.<span class="built_in">begin</span>(); iterator != name_vector.<span class="built_in">end</span>(); iterator++)</span><br><span class="line">        std::cout &lt;&lt; *iterator &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iterator = name_vector.<span class="built_in">begin</span>(); iterator != name_vector.<span class="built_in">end</span>(); iterator++)</span><br><span class="line">        std::cout &lt;&lt; *iterator &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="静态数组std-array（57）">静态数组<code>std::array</code>（57）</h2>
<blockquote>
<p><strong><code>std::array</code>是C++STL的一部分，其是专门用来处理静态数组的；所谓静态数组，便是定长数组，在你完全初始化array的初始化之后，其长度便无法改变了</strong></p>
</blockquote>
<p>在使用上，<code>array</code>几乎和C语言风格的数组别无二致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 10&gt; array;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这看上去理所当然，那么问题便出现了，我们应该使用它还是C语言的原生数组呢？</strong></p>
<blockquote>
<p><strong>结论是：我们应该尽量使用<code>std::array</code></strong></p>
</blockquote>
<p>首先，<code>std::array</code>是非常快的，其是储存在栈上的，几乎没有性能损耗</p>
<p>其次，因为<code>array</code>属于STL，其包含了许多内置函数，可以简化我们的代码，如用于排序的<code>sort</code></p>
<p>最后，使用<code>array</code>我们便不需要自己维护数组的大小了，<code>array.size()</code>函数可以返回数组大小，并且这个<code>size</code>属于模板，并不占用额外的内存</p>
<hr>
<h2 id="函数指针（58）">函数指针（58）</h2>
<blockquote>
<p><strong>函数指针，是将一个函数赋值给一个变量的方法；当我们直接传递函数名而不带括号时，我们便传递了一个函数指针</strong></p>
</blockquote>
<p>在一些情况下，函数指针的使用可以大幅简化代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span>(*function)() = Print;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们可以使用<code>返回值 (*变量名)()</code>创建一个函数指针，并通过函数指针调用函数</p>
<p>而这么写往往比较奇怪，所以我们一般会使用<code>auto</code>/<code>typedef</code>/<code>using</code>完成函数指针的声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PrintFunc)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">PrintFunc func1 = Print;</span><br><span class="line"><span class="keyword">auto</span> func2 = Print;</span><br></pre></td></tr></table></figure>
<p>下面是关于函数指针的一个实际用例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vector, <span class="type">void</span>(*func)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : vector)</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vector = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(vector, Print);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过函数指针将函数像变量一样在函数中传递，达成“回调”的效果</p>
<p>此外，<code>lambda</code>表达式也可以应用在函数指针中，<code>lambda</code>表达式将在下一章被详细介绍</p>
<hr>
<h2 id="lambda表达式（59）"><code>lambda</code>表达式（59）</h2>
<blockquote>
<p><strong><code>lambda</code>本质是我们定义的一种被称为匿名函数的方法</strong></p>
<p><strong>我们可以通过这种方法在不实际创建函数的情况下创建函数，就像一个快速的一次性函数</strong></p>
</blockquote>
<p><strong>我们什么时候可以使用<code>lambda</code>？</strong></p>
<p>只要你有一个函数指针，你便可以在C++中使用<code>lambda</code></p>
<p>当我们需要一个回调函数时，<em>即，我们想要指定一段代码，在未来的某一时刻被调用，但我们无法得知这一确切的时间时</em>，<code>lambda</code>是一个很好的方法用于编写回调函数</p>
<p>语法：<code>[捕获](参数) &#123;函数体&#125;</code></p>
<p>C++中的<code>lambda</code>表达式由三部分组成：</p>
<ul>
<li>捕获为<code>lambda</code>对于外部变量的态度，<code>[=]</code>为以值捕获所有外部变量，<code>[&amp;]</code>为以引用捕获所有外部变量，或者也可以直接传入需要捕获的变量</li>
<li>参数与正常函数的参数列表类似，如<code>(int value)</code></li>
<li>函数体也与正常函数类似，是函数的主体代码</li>
</ul>
<hr>
<h2 id="为什么不应该使用using-namespace-std（60）">为什么不应该使用<code>using namespace std</code>（60）</h2>
<p>当我们需要调用C++标准库中的内容时，我们总是需要加上前缀<code>std::</code>，很多人会觉得这很麻烦</p>
<p>而在某一作用域或全局加上<code>using namespace std</code>，我们便可以直接调用标准库的内容</p>
<p>这在一定程度上让代码变得简洁，但实际上，这并不是什么好习惯，以下是不使用<code>using namespace std</code>的几个原因</p>
<ul>
<li>让代码变得更易混淆，当我们不使用<code>using namespace std</code>时，我们可以通过函数前的<code>std::</code>清晰地看出这个函数是标准库中的，而使用<code>using namespace std</code>，会让代码的可读性降低，变得更易混淆</li>
<li>当遇到不用命名空间中的同名函数时，<code>using namespace</code>可能会导致歧义甚至编译错误</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> orange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string temp = str;</span><br><span class="line">        std::<span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        std::cout &lt;&lt; temp &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> orange;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，命名空间<code>apple</code>与<code>orange</code>中存在同名函数<code>print</code>，而此时因为隐式转换优先级的问题，我们实际调用的<code>print</code>将是<code>orange</code>中的，这种问题在实际遇到时很难发现，甚至不会有报错，但你会得到错误的结果，而不使用<code>using namespace</code>便可以很大程度上解决该问题</p>
<blockquote>
<p>并且，需要强调的是：<strong>永远不要在头文件中使用<code>using namespace</code>，天知道什么会被包含进来</strong></p>
</blockquote>
<p>在作用域很小时，或包含自己的库时，<code>using namespace</code>是可接受的，但是对于<code>std</code>这类库，最好永远避免使用<code>using namespace</code></p>
<hr>
<h2 id="命名空间（61）">命名空间（61）</h2>
<blockquote>
<p><strong>命名空间存在的主要原因，是为了避免命名冲突</strong></p>
</blockquote>
<p>C与C++语言中，名字完全相同的两个符号是不允许同时存在的，如我们无法拥有两个类型都为<code>int</code>，名字都为<code>a</code>的变量</p>
<p>在C语言中，我们通常通过在名字前增加前缀来防止命名冲突，如对于<code>print</code>函数而言，便可以写为<code>apple_print</code>与<code>orange_print</code>来区分不同的变量</p>
<p>而在C++中，我们便可以更加便捷地通过命名空间来实现这一点，就像下面这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> orange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而我们可以使用<code>::</code>来访问某一命名空间，如<code>apple::print()</code></p>
<p><em>类、结构体、枚举等本身也是一种命名空间，所以同理，我们也可以使用<code>::</code>来访问其中的字段与函数</em></p>
<p>而<code>using namespace</code>便是在某一作用域内引入某一命名空间的全部内容</p>
<p>同时<code>using</code>也有其他灵活的用法，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> a = apple;</span><br><span class="line"><span class="keyword">using</span> apple::print;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>需要强调的是，引用命名空间时，应该将其限定在尽量小的作用域内</strong></p>
<p><strong>命名空间的作用是避免命名冲突，而如果我们总是在顶层文件引入命名空间，那我们为什么还需要命名空间呢？</strong></p>
</blockquote>
<hr>
<h2 id="多线程（62）">多线程（62）</h2>
<blockquote>
<p><strong>在之前的学习过程中，我们的所有代码都是单线程的，即计算机实际上只顺序运行了一段命令</strong></p>
<p><strong>而线程系统可以让我们同时运行某几段代码，这往往在性能优化或一些其他方面非常有用</strong></p>
</blockquote>
<p>在C++11的STL中，存在<code>thread</code>库，使用该库我们便可以便捷地开启线程</p>
<ul>
<li>线程开启：创建<code>std::thread</code>类型的变量即为开启一个线程，其构造函数接受一个函数指针作为参数，传入的函数会在另外一个线程中被执行</li>
<li>线程关闭：使用<code>join()</code>函数可以让主线程的等待该子线程完成，然后主线程再继续执行。这样，子线程便可以安全的访问主线程中的资源，子线程结束后由主线程负责回收子线程资源</li>
</ul>
<p><strong>应用实例：</strong></p>
<p>一个程序的输入检测系统可以采用多线程的方式来实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> is_finish = <span class="literal">false</span>; <span class="comment">// 使用静态全局变量传递状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每隔一秒输出一个“Working”</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working......&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(DoWork)</span></span>;<span class="comment">// 创建并开启线程，此时DoWork开始运行</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();<span class="comment">// 主线程阻塞，与此同时DoWork函数会在另一个线程被不断运行</span></span><br><span class="line">    is_finish = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>();<span class="comment">// 等待子线程完全结束后再继续进行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finish!&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>线程的概念非常简单，但是其应用缺极其复杂</strong></p>
</blockquote>
<hr>
<h2 id="计时（63）">计时（63）</h2>
<p><strong>我们应该如何在C++中计算完成某个操作或执行某个代码所需要的时间呢？</strong></p>
<p>这是个非常广泛的问题，计时的应用往往无处不在，不论是需要在特定时间运行的代码，还是进行性能测试时</p>
<p>我们实际上有着多种方法计算程序运行的实际时间，如操作底层系统库；而在C++中，官方的<code>chrono</code>库可以为我们这点</p>
<blockquote>
<p><code>chrono</code>库API参考：<a href="https://en.cppreference.com/w/cpp/chrono">https://en.cppreference.com/w/cpp/chrono</a></p>
</blockquote>
<p><strong>以下是使用<code>chrono</code>进行高精度计时的一个范例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="type">float</span>&gt; duration = end_time - start_time;</span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>std::chrono::high_resolution_clock::now()</code>可以获得当前的精确时间，使两个时间相减即可得到时间间隔</p>
<p>但这看起来挺复制的，而如果我们想要为很多个函数计时，不停地复制这些代码会变得非常麻烦，下面是一种更加聪明的计时方法-<strong>利用C++对象的生存周期自动计时</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;</span><br><span class="line">    std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        duration = end - start;</span><br><span class="line">        <span class="keyword">auto</span> ms = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration);</span><br><span class="line">        std::cout &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Timer timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过创建<code>Timer</code>结构体，我们可以利用构造与析构函数将计时过程自动化，如果我们需要计时，我们便只需要在某一函数的开始创建一个<code>Timer</code>变量即可</p>
<hr>
<h2 id="多维数组（64）">多维数组（64）</h2>
<blockquote>
<p><strong>多维数组实际上代表着数组的嵌套</strong></p>
<p><strong>二维数组就是数组的数组，而三维数组就是数组的数组的数组</strong></p>
</blockquote>
<p><strong>多维数组的创建</strong></p>
<p>在我们创建多维数组时，我们可以将其看做是数组的嵌套</p>
<p>上层数组每个元素都代表着一个指向一个下层数组的指针，就像下面这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultidimensionalArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>** array2d = <span class="keyword">new</span> <span class="type">int</span>* [<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        array2d[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>*** array3d = <span class="keyword">new</span> <span class="type">int</span>** [<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        array3d[i] = <span class="keyword">new</span> <span class="type">int</span>* [<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array3d[i][j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们仅仅像<code>int** array2d = new int* [50];</code>这样完成声明后，我们的工作还远没有结束，到此我们只是为50个指针分配了内存空间，而并没有为这50个指针指向的50数组分配内存，所以我们还需要遍历地进行内存分配</p>
<p>而同理，在删除时，我们也需要遍历地进行删除</p>
<blockquote>
<p><strong>需要注意的是，多维数组中多层嵌套寻址的设计对内存并不友好，因为其储存的不连续性，这会带来更多的cache miss，实际应用上会比单纯地一维数组慢很多</strong></p>
<p><strong>而实际上，一维数组其实可以在很多时候替代多维数组的作用，通过<code>[x+y*i]</code>的方式</strong></p>
</blockquote>
<hr>
<h2 id="排序（65）">排序（65）</h2>
<blockquote>
<p><strong>对于如何处理数据的排序问题，我们可以通过多种方法来实现，包括自己实现冒泡、选择排序等算法</strong></p>
<p><strong>而当我们面对使用了C++STL，如<code>std::vector</code>，进行组织的数据时，我们实际上没必要自己写一个算法，我们可以使用C++库来帮我们排序</strong></p>
</blockquote>
<p>C++提供的排序函数为<code>std::sort</code>，它可以为任何类型的迭代器进行排序</p>
<p>我们需要为其提供一个迭代器的开始与结束，并选择性地提供比较函数，如果不提供，其将自动尝试根据类型排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>这样<code>values</code>便会降序排序</p>
<p>而不仅如此，我们可以通过函数的使用大幅定制化我们的排序算法</p>
<hr>
<h2 id="类型双关（66）">类型双关（66）</h2>
<blockquote>
<p><strong>类型双关被用来在C++中绕过类型系统的检测</strong></p>
</blockquote>
<p>C++虽然是一门强类型语言，但因为其可以直接访问内存，其类型系统便显得不那么具有强制性，如在Java或C#中想要绕过类型系统便较为麻烦</p>
<p>这是一种原始的、底层的访问，对于这种操作的允许也是让C++拥有如此优秀的性能的原因</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">double</span> b = a;</span><br></pre></td></tr></table></figure>
<p>显然的，我们可以在C++中进行上述代码的使用，但是这并不意味着类型双关，这其中其实蕴含了一次隐式的类型转换</p>
<p>如果我们去查看<code>a</code>与<code>b</code>在内存中的表现形式，会发现其实二者是截然不同的</p>
<p>而类型双关则可以让我们在保持内存不变的情况下转换类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">double</span> b = *(<span class="type">double</span>*)&amp;a;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们先取了<code>a</code>的地址即<code>&amp;a</code>，而后将<code>a</code>的<code>int</code>类型地址强制转换为了<code>double</code>类型的地址，再将其解引用，就得到了<code>b</code>，此时<code>a</code>与<code>b</code>在内存中的表现完全一直，且类型不同</p>
<p>但，这实际上是很糟糕的用法，<code>int</code>类型与<code>double</code>类型的内存大小不一样，这十分不安全，在一些情况下甚至可能引发崩溃</p>
<p>下面是一个更加实际的应用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e = &#123; <span class="number">5</span>,<span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* position = (<span class="type">int</span>*)&amp;e;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; position[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; position[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过类型双关处理<code>Entity</code>，我们便可以不通过<code>e</code>，直接以类似数组的形式访问其中的数据</p>
<blockquote>
<p><strong>总而言之，类型双关允许我们以不同的形式解释同一块内存，正确地使用它可以帮助代码提高效率</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Notes</category>
        <category>C/C++</category>
        <category>TheCherno</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>【The Cherno-C++】学习笔记三（67-90）</title>
    <url>/posts/1003/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202308050329536.jpeg" alt="cherno"></p>
<blockquote>
<p><strong>B站up神经元猫翻译版：<a href="https://www.bilibili.com/video/BV1uy4y167h2">https://www.bilibili.com/video/BV1uy4y167h2</a></strong></p>
</blockquote>
<h2 id="前言">前言</h2>
<p>C++因为其优异的性能，是游戏开发中最为常用的语言之一，目前的Unity与Unreal两大商用引擎的内核都是采用C++进行编写，作为一个有志于成为游戏开发者的人，这种语言怎么能不学一学呢？</p>
<p>本文基于油管著名博主，曾任职于EA的The Cherno的C++系列视频，The Cherno作为寒霜引擎的核心开发人员之一，对C++有着非常独到而深刻的理解</p>
<p>这些笔记记录了我通过The Cherno的系列视频学习C++的一些知识点与理解，希望对你有帮助😉</p>
<blockquote>
<p>第一章（1-33）：<a href="https://hmxs.games/posts/1001/">https://hmxs.games/posts/1001/</a></p>
<p>第二章（34-66）：<a href="https://hmxs.games/posts/1002/">https://hmxs.games/posts/1002/</a></p>
<p><strong>第三章（67-99）：<a href="https://hmxs.games/posts/1003/">https://hmxs.games/posts/1003/</a></strong></p>
</blockquote>
<hr>
<h2 id="联合体（67）">联合体（67）</h2>
<blockquote>
<p><strong>联合体在使用上有点类似类或结构体，但区别是，同一时间一个联合体内只能有一个成员，即联合体的中的所有成员都共用一片内存空间</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面这个联合体中，如果你改变<code>a</code>的值，b也同样会被改变</p>
<p><strong>在类型双关中的应用：</strong></p>
<p><code>union</code>可以被用来方便地实现上一章讲到的类型双关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">union</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> a;</span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Union u;</span><br><span class="line">    u.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; u.a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; u.b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中对<code>a</code>和<code>b</code>的赋值和访问会因为联合体的特性自动地实现类型双关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y, z, w;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            Vector2 a, b;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，我们可以通过4个<code>int</code>或2个<code>Vector2</code>变量来表示<code>Vector4</code>，并且数据是互通的，这也是联合体的妙用</p>
<hr>
<h2 id="虚析构函数（68）">虚析构函数（68）</h2>
<blockquote>
<p><strong>顾名思义，虚析构函数便是虚函数和析构函数的结合体，但其在一些情况下非常重要</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--------------------\n&quot;</span>;</span><br><span class="line">    Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> derived;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--------------------\n&quot;</span>;</span><br><span class="line">    Base* test = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> test;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Base Constructor</span></span><br><span class="line"><span class="comment">// Base Destructor</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">// Base Constructor</span></span><br><span class="line"><span class="comment">// Derived Constructor</span></span><br><span class="line"><span class="comment">// Derived Destructor</span></span><br><span class="line"><span class="comment">// Base Destructor</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">// Base Constructor</span></span><br><span class="line"><span class="comment">// Derived Constructor</span></span><br><span class="line"><span class="comment">// Base Destructor</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，我们可以发现，在创建与销毁子类时，父类的构造与析构函数会在最开始与最后被调用</p>
<p>但当我们通过父类的指针访问一个子类对象时，所有构造函数都被正确调用了，但缺只有父类的析构函数被调用了，子类的析构函数没有被调用，这可能会导致内存泄露</p>
<p>而我们可以通过虚析构函数来解决这一问题，与普通虚函数不同的是，虚析构函数所做的并不是“替换”，而是“加上”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span>  ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们只需要为基类的析构函数加上<code>virtual</code>即可</p>
<blockquote>
<p><strong>如果用基类指针来引用派生类对象，那么基类的析构函数必须是 virtual 的，否则 C++ 只会调用基类的析构函数，不会调用派生类的析构函数。</strong></p>
</blockquote>
<hr>
<h2 id="类型转换（69）">类型转换（69）</h2>
<blockquote>
<p><strong>C++作为一种强类型语言，其类型的存在是强制性的，我们不能突兀地直接转变某一对象的类型，我们必须进行显式或隐式的类型转换，而在C++中我们可以使用C风格或C++风格的语法进行类型转换</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式类型转换</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C风格显式转换</span></span><br><span class="line"><span class="type">double</span> c = (<span class="type">double</span>)a;</span><br></pre></td></tr></table></figure>
<p>上面是隐式与C风格的显示类型转换，其语法非常简单直观</p>
<p>而在C++中，我们也可以使用内置的一系列<code>cast</code>函数来实现类型转换，一共有4种主要的<code>cast</code>函数：<code>static_cast</code>、<code>reinterpret_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code></p>
<p><em>需要注意的是，<code>cast</code>函数可以实现的功能使用C语言风格的类型转换也一样可以，它们并没有实现什么新功能，只是添加了一些语法糖到你的代码中</em></p>
<p>C++设置这么多<code>cast</code>的目的：除了一些编译时的额外特性，还可以帮助我们在代码库中快速地找到我们在什么地方使用了类型转换，而C语言风格的类型转换则非常难以定位，并且在我们尝试进行类型转换时，也可以帮助我们避免一些意外错误，比如类型不兼容</p>
<p>下面是一个关于<code>dynamic_cast</code>的实例：</p>
<p><code>dynamic_cast</code>在类型转换时会进行编译时检查，如果转换不成功，其会将对象赋值为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived1</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Derived1</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived2</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Derived2</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Derived1与Derived2都派生自Base</span></span><br><span class="line">    Derived1* derived1 = <span class="keyword">new</span> <span class="built_in">Derived1</span>();</span><br><span class="line"></span><br><span class="line">    Base* base = (Base*)derived1;</span><br><span class="line"></span><br><span class="line">    Derived2* derived2 = <span class="built_in">dynamic_cast</span>&lt;Derived2*&gt;(base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!derived2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;derived2 is null&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>dynamic_cast</code>自动进行类型转换时的安全检查</p>
<hr>
<h2 id="条件与操作断点（70）">条件与操作断点（70）</h2>
<blockquote>
<p><strong>条件与操作断点可以被应用与更加复杂的调试场景</strong></p>
<p><strong>条件断点可以让断点只在特定条件下触发</strong></p>
<p><strong>操作断点则允许我们在碰到断点时采取某种动作，如打印一些东西到控制台</strong></p>
</blockquote>
<p>条件与操作断点的优势在于其可以在不用更改任何代码的情况下，在运行时进行debug，这对我们的开发效率有很大的提升</p>
<p>右击断点的小红点，点击条件/操作，即可调出条件与操作断点界面，如下图所示：</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202308290140516.png" alt="image-20230829014033456"></p>
<blockquote>
<p><strong>这是一个简单而十分强大地功能，特别是在我们需要调试一些较为大型的程序时</strong></p>
<p><strong>但同时，需要注意的是，附加调试程序是十分耗费性能的</strong></p>
</blockquote>
<hr>
<h2 id="安全问题与如何授权（71）">安全问题与如何授权（71）</h2>
<p>C++中的安全问题一直争议不休，有人说我们应该拥抱智能指针，抛弃原始指针，而也有人说，智能指针有着严重的开销问题，是男人就用原始指针！</p>
<p>而Cherno对此的态度是：没有绝对的标准答案</p>
<p>对于生产环境而言，我们绝对应该使用智能指针，这会大大降低我们出错的概率，也会提高协作的效率</p>
<p>对于学习和了解而言，使用原始指针可以帮助我们更好地理解指针的工作原理，因为智能指针实际上也只是原始指针的一层封装</p>
<p>当然，如果你需要定制的话，也可以使用自己写的智能指针</p>
<hr>
<h2 id="预编译头文件（72）">预编译头文件（72）</h2>
<blockquote>
<p><strong>预编译头文件实际上是让你抓取一堆头文件，并将它们转换为“编译器格式”，使得我们不比一遍又一遍地读取这些头文件</strong></p>
</blockquote>
<p>在实际地代码编写中，我们往往会<code>include</code>一些头文件，而每当我们对程序进行修改时，这些头文件都需要被从头开始重新编译，这会大大拖慢编译的速度</p>
<p>而预编译头文件可以预先将这些头文件编译为二进制形式储存，加快之后编译的速度</p>
<blockquote>
<p><strong>但需要注意的是，不要讲会经常变更的东西放入预编译头文件中，这会适得其反，是本末倒置的行为</strong></p>
</blockquote>
<p><strong>那么我们应该如何创建一个预编译头文件呢？</strong></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309010210722.png" alt="image-20230901021028633" style="zoom: 67%;" />
<p>如图所示，我们要预编译上述<code>pch.h</code>头文件</p>
<p>在VS中，我们需要创建一个空<code>.cpp</code>文件，其中只包含需要预编译的头文件，如下图所示</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309010212359.png" alt="image-20230901021226327" style="zoom: 67%;" />
<p>之后我们便可以右键刚刚创建的<code>.cpp</code>文件，点击<code>属性-&gt;C/C++-&gt;预编译头</code>，将预编译头选项设置为<code>创建</code></p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309010214392.png" alt="image-20230901021457327" style="zoom: 50%;" />
<p>最后我们将项目设置中的同样位置的预编译头选项改为<code>使用</code>，并将<code>预编译头文件</code>改为对应头文件名即可</p>
<blockquote>
<p><strong>除非你的项目极其小，否则都应该使用预编译头文件，这会大大加快你的编译速度</strong></p>
</blockquote>
<hr>
<h2 id="dynamic-cast（73）"><code>dynamic_cast</code>（73）</h2>
<blockquote>
<p><strong><code>dynamic_cast</code>是在69章类型转换中提到过的一种C++风格的类型转换函数</strong></p>
<p><strong>其专门用于沿继承层级结构进行的强制类型转换，如果我们想把一个基类强转为派生类，或从派生类强转为基类，那么便可以使用<code>dynamic_cast</code></strong></p>
</blockquote>
<p>如，我们有一个<code>Entity</code>基类，<code>Player</code>与<code>Enemy</code>类都派生自<code>Entity</code>，我们想将一个<code>Entity</code>实例强转为<code>Player</code>，但这一实例也有可能是<code>Enemy</code>，如果这时我们尝试去对<code>Player</code>独有的数据进行访问和更改，就很可能会引发问题，而使用<code>dynamic_cast</code>进行这种类型的强转时，如果发生了上述情况，<code>dynamic_cast</code>会中断转换并直接返回<code>Null</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Player* player = <span class="keyword">new</span> <span class="built_in">Player</span>();</span><br><span class="line"></span><br><span class="line">    Entity* enemy = <span class="keyword">new</span> <span class="built_in">Enemy</span>();</span><br><span class="line">    Entity* player2 = player;</span><br><span class="line"></span><br><span class="line">    Player* player_x = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(enemy); <span class="comment">// NULL</span></span><br><span class="line">    Player* player_y = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(player2); <span class="comment">// Success</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dynamic-cast的运行机制"><code>dynamic_cast</code>的运行机制</h3>
<p><code>dynamic_cast</code>实现运行时类型检查是因为其储存了运行时类型信息（RTTI:Runtime Type Information）,其储存了我们的所有类型的运行时类型信息，这显而易见地会增加开销，但它可以让你实现类似动态类型转换的事情，在使用时需要进行取舍</p>
<hr>
<h2 id="基准测试（74）">基准测试（74）</h2>
<blockquote>
<p><strong>基准测试往往被用于测量一段特定代码的性能，测试方法多种多样，如之前写过的作用域计时便可以用于基准测试</strong></p>
</blockquote>
<p><strong>作用域计时器：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">        : <span class="built_in">name_</span>(name), <span class="built_in">stopped_</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        start_time_point_ = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stopped_)</span><br><span class="line">            <span class="built_in">Stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        end_time_point_ = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> start = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(start_time_point_).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> end = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(end_time_point_).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; (end - start) &lt;&lt; <span class="string">&quot;us(&quot;</span> &lt;&lt; (end - start) * <span class="number">0.001</span> &lt;&lt; <span class="string">&quot;ms)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        stopped_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name_;</span><br><span class="line">    <span class="type">bool</span> stopped_;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start_time_point_, end_time_point_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只需要在对应作用域创建一个<code>Timer</code>实例即可实现自动计时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>但需要注意的是，我们需要确保我们进行基准测试的代码应和实际运行情况相同</strong></p>
<p><strong>如，在VS中在Debug和Release模式下运行代码会有很大不同，在Release模式下编译器会自动地对代码进行优化</strong></p>
</blockquote>
<p><strong>下面是一个基准测试的实际应用：</strong></p>
<p>使用基准测试进行不同智能指针的性能测试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;make_shared:\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">2000</span>&gt; shared_ptr_array;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : shared_ptr_array)</span><br><span class="line">            i = std::<span class="built_in">make_shared</span>&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;new shared:\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">2000</span>&gt; shared_ptr_array;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : shared_ptr_array)</span><br><span class="line">            i = std::<span class="built_in">shared_ptr</span>&lt;Vector2&gt;(<span class="keyword">new</span> <span class="built_in">Vector2</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;make_unique:\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;std::unique_ptr&lt;Vector2&gt;, <span class="number">2000</span>&gt; unique_ptr_array;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : unique_ptr_array)</span><br><span class="line">            i = std::<span class="built_in">make_unique</span>&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="结构化绑定（75）">结构化绑定（75）</h2>
<blockquote>
<p><strong>结构化绑定是C++17引入的新机制，其可以帮助我们更好地处理多返回值</strong></p>
</blockquote>
<p>在之前的52章如何处理多返回值时，有讲到可以使用<code>std::tuple</code>/<code>std::pair</code>来进行处理，但这是一种不够清晰，且较为繁琐的传值方法，我们很少使用它们</p>
<p>但这种情况在结构化绑定的加入后得以改善</p>
<p>下面是一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">CreatePerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;徽墨行深&quot;</span>, <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上函数会返回一个元组，而当我们想要处理上述函数的返回值时，我们往往只能使用<code>get</code>函数或<code>tie</code>函数，如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用get提取元组中的数据</span></span><br><span class="line"><span class="keyword">auto</span> person = <span class="built_in">CreatePerson</span>();</span><br><span class="line">name = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person);</span><br><span class="line">age = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用tie提取元组中的数据</span></span><br><span class="line">std::<span class="built_in">tie</span>(name, age) = <span class="built_in">CreatePerson</span>();</span><br></pre></td></tr></table></figure>
<p>其中使用<code>tie</code>或许会更加简洁，但总的来说都并不方便，不如使用结构体进行处理</p>
<p>而结构化绑定大幅降低了代码的复杂度，我们不再需要<code>tie</code>和<code>get</code>，如下所示即可完成数据的提取</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> [name, age] = <span class="built_in">CreatePerson</span>();</span><br></pre></td></tr></table></figure>
<p>简洁而高效，如果我们只需要处理少数几次某一多类型返回值，那么使用结构化绑定会成为我们的最优选</p>
<blockquote>
<p><strong>但需要注意的是，此特性只在C++17或更高版本中有效，在使用前需要确认好正在使用的版本</strong></p>
</blockquote>
<hr>
<h2 id="如何处理Optional数据（76）">如何处理Optional数据（76）</h2>
<blockquote>
<p><strong><code>std::optional</code>是C++17引入的新类，用于处理那些可能存在，也可能不存在的数据，或者是一种我们不确定的类型（有点类似C#中的<code>？</code>）</strong></p>
</blockquote>
<p><strong>下面是一个使用例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">ReadFileAsString</span><span class="params">(<span class="type">const</span> std::string&amp; file_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file_stream</span><span class="params">(file_path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file_stream)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string result;</span><br><span class="line">        <span class="comment">// read file</span></span><br><span class="line">        file_stream.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面这个读取文件的函数而言，在之前的C++中，要判断“文件是否被成功读取到了”是较为麻烦的</p>
<p>一个实现方法是从外部传入一个<code>bool</code>值引用，再在函数内部进行改变，但是这样显然不是很优雅</p>
<p>而<code>std::optional</code>可以较为方便地解决这一问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">ReadFileAsString</span><span class="params">(<span class="type">const</span> std::string&amp; file_path)</span></span></span><br></pre></td></tr></table></figure>
<p>我们只需将返回值加上<code>optional</code>，之后即可在外部进行判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::optional&lt;std::string&gt; data = <span class="built_in">ReadFileAsString</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (data.<span class="built_in">has_value</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// read successful</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// read failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时我们也可以方便地提起其中的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string string_data;</span><br><span class="line">string_data = data.<span class="built_in">value</span>();</span><br><span class="line">string_data = *data;</span><br></pre></td></tr></table></figure>
<p>而<code>value_or()</code>函数可以自动为被判定为空的<code>optional</code>值设定默认值，如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string_data = data.<span class="built_in">value_or</span>(<span class="string">&quot;File Did Not Exist&quot;</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="单一变量存放多类型数据（77）">单一变量存放多类型数据（77）</h2>
<blockquote>
<p><strong><code>std::variant</code>是C++17中引入的新类，它可以让我们在创建变量时不用处理变量的确切数据类型</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::variant&lt;std::string, <span class="type">int</span>&gt; data;</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">data = <span class="string">&quot;Hmxs&quot;</span>;</span><br><span class="line">data = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 提取</span></span><br><span class="line">std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(data);</span><br><span class="line"><span class="keyword">auto</span>* value = std::<span class="built_in">get_if</span>&lt;std::string&gt;(&amp;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用例1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* value = std::<span class="built_in">get_if</span>&lt;std::string&gt;(&amp;data);)</span><br><span class="line">&#123;</span><br><span class="line">    std::string* v = value;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用例2</span></span><br><span class="line"><span class="keyword">enum</span> ErrorCode</span><br><span class="line">&#123;</span><br><span class="line">    kNone,</span><br><span class="line">    kNotFound</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::variant&lt;std::string, ErrorCode&gt; <span class="title">ReadFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::variant</code>与<code>union</code>可以起到的作用有些类似，他们各有优劣</p>
<p><code>union</code>的内存大小由其中最大的类型决定，而<code>std::variant</code>则比较类似<code>class</code>，其内存大小等于你声明的所有类型的内存总和，从这一角度上看，<code>union</code>的空间性能更好</p>
<p>但与之相对的<code>std::variant</code>拥有更好的安全性，其是类型安全的</p>
<hr>
<h2 id="如何储存任意类型的数据（78）">如何储存任意类型的数据（78）</h2>
<blockquote>
<p><strong><code>std::any</code>是C++17中引入的新类，它可以储存任意类型的数据</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::any data;</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">data = <span class="number">2</span>;</span><br><span class="line">data = <span class="string">&quot;Hmxs&quot;</span>;</span><br><span class="line"><span class="comment">// 提取</span></span><br><span class="line"><span class="comment">// 如果当前data数据类型与any_cast想要转换的不一致，则会抛出异常</span></span><br><span class="line">std::<span class="built_in">any_cast</span>&lt;std::string&gt;(data);</span><br></pre></td></tr></table></figure>
<p>正如<code>any</code>的名字一样，<code>std::any</code>可以存储所有类型，这看起来便于编写，会比上一章讲到的<code>std::variant</code>方便很多，但这并不一定是优点,<code>any</code>的任意属性会给我们带来很多意料之外的麻烦</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::any data;</span><br><span class="line">data = <span class="string">&quot;Hmxs&quot;</span>;</span><br><span class="line">std::string value = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(data);</span><br></pre></td></tr></table></figure>
<p>如上面这段代码，看起来十分合理，但是实际上运行则会报错，因为字面量<code>&quot;Hmxs&quot;</code>的类型实际上是<code>const char[5]</code>，而我们将其看做了<code>std::string</code>，<code>any_cast</code>并不会帮我们进行隐式类型转换，但差不多的代码使用<code>std::variant</code>则完全不会有问题，因为其是类型安全的</p>
<p>而除此之外，<code>std::any</code>还存在一定程度的内存问题，当我们将<code>any</code>类型的变量赋值为内存较小的类型如<code>int</code>、<code>float</code>时，其运行机制与<code>variant</code>几乎一样，但当我们将其定义为较大的类型时，其会自动地进行动态内存分配，而对性能并不是什么好事</p>
<blockquote>
<p><strong>总而言之，就目前而言<code>any</code>几乎没有比较好的应用场景，而为了我们的C++程序能更好地跑起来，我们应该尽量避免使用它</strong></p>
</blockquote>
<hr>
<h2 id="如何让C-运行地更快（79）">如何让C++运行地更快（79）</h2>
<p>现代硬件往往是可以进行并行运算的，这意味着你可以在同一时间并行执行指令，使用多线程可以大幅提高程序运行的速度，但多线程带来的程序调度问题也是十分复杂的</p>
<blockquote>
<p><strong>在C++11中，<code>std::async</code>被引入帮助我们实现程序的多线程化</strong></p>
</blockquote>
<hr>
<h2 id="如何让字符串更快（80）">如何让字符串更快（80）</h2>
<blockquote>
<p><strong>C++的字符串实际上非常慢，而我们可以做一些事情让它们能被更快地处理</strong></p>
</blockquote>
<p><code>std::string</code>的主要问题之一，可能就是字符串格式化以及字符串操作，因为它们都需要进行内存分配</p>
<p>下面的代码通过重载<code>new</code>运算符的方式揭示了其会进行的内存分配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocating:&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;bytes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string name = <span class="string">&quot;hmxs&#x27;s Cpp&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintName</span>(name);</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; <span class="string">&quot;allocations\n&quot;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// allocating:16bytes</span></span><br><span class="line"><span class="comment">// hmxs&#x27;s Cpp</span></span><br><span class="line"><span class="comment">// 1allocations</span></span><br></pre></td></tr></table></figure>
<p>运行后我们可以看到<code>std::string</code>调用了<code>new</code>进行了1次内存分配</p>
<p>同时使用<code>substr()</code>这类对字符串进行操作的函数也会进行内存分配</p>
<p>而解决它们的方法便是C++17中引入的<code>std::string_view</code>或自己对字符串进行包装</p>
<blockquote>
<p><strong><code>std::string_view</code>是一个指向现有字符串内存的指针，其就像一个观察字符串的窗口，通过它我们便可以减少进行字符串操作时发生的内存分配</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string name = <span class="string">&quot;hmxs&quot;</span>;</span><br><span class="line"><span class="function">std::string_view <span class="title">sub_name1</span><span class="params">(name.c_str(), <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">std::string_view <span class="title">sub_name2</span><span class="params">(name.c_str() + <span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样一来内存分配便被减少了</p>
<p>而不使用<code>std::string</code>使用<code>const char*</code>则可以完全不需要内存分配</p>
<hr>
<h2 id="可视化基准测试（81）">可视化基准测试（81）</h2>
<p>在之前的第74章<code>基准测试</code>中，我们了解了使用<code>Timer</code>类与控制台进行输出的基准测试方法，如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Timer <span class="title">timer</span><span class="params">(<span class="string">&quot;Function1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Timer <span class="title">timer</span><span class="params">(<span class="string">&quot;Function2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello #&quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(i) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要在对应作用域内声明<code>Timer</code>变量即可</p>
<p>但这种方法有时比较麻烦，在大量控制台输出中寻找那个基准测试数据并不是什么很好的体验</p>
<p>这时候可视化就可以出场了，而我们将使用<code>Edge</code>/<code>Chrome</code>进行可视化基准测试</p>
<p>我们只需要在浏览器的地址栏输入<code>edge://tracing</code>（<code>Chrome</code>则为<code>chrome://tracing</code>）即可进入可视化页面</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309200023131.png" alt="image-20230920002356933" style="zoom: 33%;" />
<p>这个页面接受一个<code>.json</code>文件，而我们需要做的便是输出一个符合要求的<code>json</code>文件</p>
<p>使用流输出代码根据规定格式输出即可获得json文件，<code>cherno</code>为我们编写了流输出程序<a href="https://gist.github.com/TheCherno/31f135eea6ee729ab5f26a6908eb3a5e">https://gist.github.com/TheCherno/31f135eea6ee729ab5f26a6908eb3a5e</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">InstrumentationTimer <span class="title">timer</span><span class="params">(<span class="string">&quot;Function1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">InstrumentationTimer <span class="title">timer</span><span class="params">(<span class="string">&quot;Function2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello #&quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(i) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Instrumentor::<span class="built_in">Get</span>().<span class="built_in">BeginSession</span>(<span class="string">&quot;Profile&quot;</span>);</span><br><span class="line">    <span class="built_in">Function1</span>();</span><br><span class="line">    <span class="built_in">Function2</span>();</span><br><span class="line">    Instrumentor::<span class="built_in">Get</span>().<span class="built_in">EndSession</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此我们便得到了可以使用的<code>json</code>文件，将其拖入上述网站即可获得可视化结果</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309200114877.png" alt="image-20230920011456750" style="zoom:33%;" />
<hr>
<h2 id="单例模式（82）">单例模式（82）</h2>
<p>单例模式在C#与Java中会经常被提到，这是一种非常基础的设计模式，其保证了某一类只能被实例化一次，且可以被全局调用</p>
<p>而在C++中，因为C++的灵活性，其实我们并不需要使用类来组织一切，一个全局变量/函数就能实现单例的效果，那么单例在C++中的意义是什么呢？我们可以用更加灵活的眼光看待C++中的单例</p>
<blockquote>
<p><strong>C++中的单例只是一种组织一堆全局变量和静态函数的方式，可以起到类似命名空间的效果</strong></p>
</blockquote>
<h3 id="C-单例的基础实现">C++单例的基础实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::instance_;</span><br></pre></td></tr></table></figure>
<p>上述实现需要在外部声明<code>instance</code>，比较麻烦，而我们可以采用下面的写法简化代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>实际上我们使用命名空间可以达到差不多的效果（除了不能赋值以外），而使用类来对代码进行组织或许会更加有条理</strong></p>
</blockquote>
<hr>
<h2 id="小字符串优化（83）">小字符串优化（83）</h2>
<blockquote>
<p><strong>C++字符串的字符串的慢众所周知，因为其总是倾向于去进行堆内存的分配；但这并不绝对，当我们定义的字符串小于一定长度时，其便不会进行堆内存的分配了</strong></p>
</blockquote>
<p>在VS19中，这个值是15，即当我们定义的字符串小于等于15个字符时，其便不会进行内存分配了</p>
<hr>
<h2 id="跟踪内存分配的简单方法（84）">跟踪内存分配的简单方法（84）</h2>
<blockquote>
<p><strong>内存总是程序的重中之重，或许在当代计算机硬件的高速发展下，内存的使用已不再那么捉襟见肘，但对于内存使用仍是我们需要关注的</strong></p>
</blockquote>
<p>我们可以对全局的<code>new</code>与<code>delete</code>操作符进行重载+断点+检查内存堆栈的形式简单地检查每一处内存分配与释放的地方</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocating&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;bytes\n&quot;</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* memory, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;freeing&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;bytes\n&quot;</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202309210133729.png" alt="image-20230921013310633" style="zoom: 80%;" />
<p>更进一步，我们可以创建一个全局的内存记录器来记录所有分配的内存大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocationMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> total_allocated = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> total_freed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">CurrentUsage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> total_allocated - total_freed; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> AllocationMetrics allocation_metrics;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    allocation_metrics.total_allocated += size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* memory, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    allocation_metrics.total_freed += size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="左值与右值（85）">左值与右值（85）</h2>
<blockquote>
<p><strong>左值基本上是具有存储属性的对象，其具有地址和值，可以出现在<code>=</code>的左右两边</strong></p>
<p><strong>右值基本上是临时对象，如字面量与表达式，大部分情况下只能出现在<code>=</code>的右边，不能被赋值</strong></p>
<p><strong>左值引用，如<code>std::string&amp;</code>，只能接受左值，除非加上<code>const</code></strong></p>
<p><strong>右值引用，如<code>std::sting&amp;&amp;</code>，只能接受右值</strong></p>
</blockquote>
<p>左值右值的定义复杂，很难一言以蔽之，纠结于定义反而容易陷入误区，更好的做法是在例子中进行理解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值为int&amp;类型，是左值引用，所以只能返回左值，即必须是具有存储空间，不能是临时变量</span></span><br><span class="line"><span class="comment">// 接受的参数为string&amp;类型，是左值引用，所以接受的参数也必须是左值，直接Print(&quot;Hmxs&quot;)会报错</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Print</span><span class="params">(std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Hmxs&quot;</span>;</span><br><span class="line">    <span class="built_in">Print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string name1 = <span class="string">&quot;wzh&quot;</span>;</span><br><span class="line">std::string name2 = <span class="string">&quot;hmxs&quot;</span>;</span><br><span class="line">std::string name3 = name1 + name2;</span><br><span class="line"><span class="comment">// name1，name2，name3是左值</span></span><br><span class="line"><span class="comment">// &quot;wzh&quot;，&quot;hmxs&quot;，name1+name2是右值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为右值引用，只能传入右值，传入左值会报错，即Print(name)会报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(std::string&amp;&amp; name)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;wzh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>左值右值在进行优化与移动语义时很有用，其也一定程度反应了C++的运行机理</strong></p>
</blockquote>
<hr>
<h2 id="持续集成（86）">持续集成（86）</h2>
<blockquote>
<p><strong>持续集成（CI）通常指的是在开发期间持续集成代码的过程，其本质是构建自动化和测试</strong></p>
<p><strong>在多人协作开发的过程中，多名开发者在一起贡献代码的过程中有可能不会在所有平台进行测试，有些只在特定平台会出现的bug有可能就不会被发现，而要求所有开发者为所有平台进行测试成本过于巨大，而持续集成可以帮助我们自动化整个过程，确保代码在所有平台和所有配置下都可以编译</strong></p>
</blockquote>
<p>在这集中Cherno推荐了Jenkins来实现持续集成</p>
<p>目前这块内容对我来说并没有很大作用，所以这章先跳过</p>
<hr>
<h2 id="静态分析（87）">静态分析（87）</h2>
<blockquote>
<p><strong>静态分析（Static Analysis）是代码的检查分析器，多一双眼睛检查你的代码总没坏处</strong></p>
</blockquote>
<p>其中Cherno推荐了pvs studio，但其中有商业推广的要素</p>
<p>由于不想额外花钱所以这章也先跳过</p>
<p>静态分析工具多种多样，其中也不乏开源免费的工具</p>
<hr>
<h2 id="参数计算顺序（88）">参数计算顺序（88）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; (a + b) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Print</span>(value++, value++);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，最后会输出什么实际上是不确定的，即<code>未定义行为</code></p>
<blockquote>
<p><strong>C++并没有提供参数计算顺序的规范，所以计算顺序完全根据编译器的实现与C++的版本决定，甚至不同的运行模式也会影响输出的结果</strong></p>
<p><strong>我们应该尽量避免写出这样令人疑惑的代码</strong></p>
</blockquote>
<hr>
<h2 id="移动语义（89）">移动语义（89）</h2>
<blockquote>
<p><strong>在C++11之前，如果我们想把一个对象传递给一个函数，并且获得对象的所有权，我们除了拷贝别无选择，我们需要在当前堆栈帧中构造一个一次性对象，然后将它复制到我正在调用的函数中</strong></p>
<p><strong>这并不理想，如果我们的对象比较大，那么这一过程将变得很慢，而这时移动语义便出现了，其允许我们移动对象而不是复制它，以此来提高性能</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Created\n&quot;</span>);</span><br><span class="line">        size_ = <span class="built_in">strlen</span>(string);</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_];</span><br><span class="line">        <span class="built_in">memcpy</span>(data_, string, size_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Coped\n&quot;</span>);</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_];</span><br><span class="line">        <span class="built_in">memcpy</span>(data_, other.data_, size_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; size_; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, data_[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data_;</span><br><span class="line">    <span class="type">uint32_t</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">        : <span class="built_in">name_</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name_.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">entity</span><span class="params">(String(<span class="string">&quot;Hmxs&quot;</span>))</span></span>;</span><br><span class="line">    entity.<span class="built_in">PrintName</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Created</span></span><br><span class="line"><span class="comment">// Coped</span></span><br><span class="line"><span class="comment">// Hmxs</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，如果我们不使用移动语义，那么复制对象几乎无法避免</p>
<p>但我们必须复制对象在这一情景下其实理应是荒谬的，我们的需求为<code>将一个String对象放入Entity中</code>，但我们需要做的却是<code>先在外部创建一个String对象，再将其深拷贝到Entity的String中</code>，为啥我们不能直接将外部创建的<code>String</code>直接移动到<code>Entity</code>中呢？而使用移动语义，我们便得以做到这点</p>
<p>移动语义实质上便是将深拷贝变为浅拷贝，我们需要编写移动构造函数，通过右值引用将对象强行标记为右值，即临时对象，后通过<code>std::move</code>使我们在拷贝时调用移动构造函数，而非复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Created\n&quot;</span>);</span><br><span class="line">        size_ = <span class="built_in">strlen</span>(string);</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_];</span><br><span class="line">        <span class="built_in">memcpy</span>(data_, string, size_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Coped\n&quot;</span>);</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_];</span><br><span class="line">        <span class="built_in">memcpy</span>(data_, other.data_, size_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Moved\n&quot;</span>);</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理原先的对象</span></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Destroyed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span> data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; size_; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, data_[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data_;</span><br><span class="line">    <span class="type">uint32_t</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">        : <span class="built_in">name_</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(String&amp;&amp; name)</span><br><span class="line">        : <span class="built_in">name_</span>(std::<span class="built_in">move</span>(name)) <span class="comment">// 必须使用std::move，否则仍然会复制，因为右值引用在进入函数体后会变成左值，所以要触发移动语义必须让他变为右值引用</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name_.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">entity</span><span class="params">(String(<span class="string">&quot;Hmxs&quot;</span>))</span></span>;</span><br><span class="line">    entity.<span class="built_in">PrintName</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Created</span></span><br><span class="line"><span class="comment">// Moved</span></span><br><span class="line"><span class="comment">// Destroyed</span></span><br><span class="line"><span class="comment">// Hmxs</span></span><br></pre></td></tr></table></figure>
<p>通过上面的代码，我们便成功避免了多余的复制，其中<code>Entity entity(String(&quot;Hmxs&quot;));</code>具体的逻辑是：</p>
<ol>
<li>首先<code>String(&quot;Hmxs&quot;)</code>会创建一个临时的<code>String</code>对象，这一对象传入<code>entity</code>的构造函数中</li>
<li>因为传入的<code>String</code>对象是右值，所以会优先进入<code>Entity(String&amp;&amp; name)</code>这一参数为右值引用，并执行<code>name_(std::move(name))</code>的初始化过程</li>
</ol>
<p><em>作为右值引用被传入的<code>String</code>对象在进入函数后变为了左值，所以需要使用<code>std::move</code>将其强转为右值引用，才能进入<code>String</code>的移动构造函数</em></p>
<ol start="3">
<li>之后便进入了<code>String</code>的移动构造函数中，将<code>entity</code>中的<code>name_</code>指向临时的<code>String</code>对象，之后将临时的<code>String</code>对象置空，即完成了移动过程</li>
</ol>
<p><em>因为临时的<code>String</code>对象是右值，且被置空，在语句结束后会自动地进行释放</em></p>
<p>至此，我们便完成了一次成功的移动语义，cool</p>
<hr>
<h2 id="std-move与移动赋值操作符（90）"><code>std::move</code>与移动赋值操作符（90）</h2>
<blockquote>
<p><strong><code>std::move</code>内部的实现是一个<code>static_cast</code>，其会将传入对象的类型强转为对应类型的右值引用形式</strong></p>
<p><strong><code>std::move</code>是一个优雅的实现，如果我们想要传入右值引用参数，那么我们应该尽量使用它</strong></p>
</blockquote>
<p>在上一章中，我们通过编写<code>移动构造函数</code>实现了移动语义，而正如其名字中的<code>构造</code>所言，其是一种类型的构造函数，只有在对象构造时才会被调用</p>
<p>那么如果我们想要对一个已经存在的对象使用移动语义呢？我们应该使用<code>移动赋值操作符</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Moved\n&quot;</span>);</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理原先的对象</span></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值操作</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(String&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Assigned\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果尝试给自己移动向自己，应该直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动赋值操作会作用于一个已经存在的对象，我们应该先释放原先的对象</span></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理原先的对象</span></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Destroyed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span> data_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data_;</span><br><span class="line">    <span class="type">uint32_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们应该注意分辨<code>移动构造</code>与<code>移动赋值</code>，因为隐式转换的缘故，有时构造函数很容易和赋值相混淆</p>
<hr>
<h2 id="后记">后记</h2>
<p><code>【The Cherno C++】</code>系列暂时完结啦，后续的91-99因为都比较长且不是我现在需要的知识就先暂时搁置啦，后续再更新吧</p>
<p>一点点跟完了90章的内容，只能说受益匪浅</p>
<p>感谢<a href="https://www.youtube.com/@TheCherno">The Cherno</a>的精品教程，也感谢up主<a href="https://space.bilibili.com/364152971">神经元猫</a><u>的无偿翻译</u></p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>C/C++</category>
        <category>TheCherno</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏编程模式】读书笔记一：架构、性能与游戏</title>
    <url>/posts/2001/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303301905867.jpeg" alt="img"></p>
<blockquote>
<p><strong>《游戏编程模式》-Bob Nystrom</strong></p>
<p><strong>书籍汉化版网址：<a href="https://gpp.tkchu.me/">https://gpp.tkchu.me/</a></strong></p>
<p><strong>笔记目录：<a href="https://hmxs.games/posts/2000/">https://hmxs.games/posts/2000/</a></strong></p>
</blockquote>
<hr>
<h1>架构、性能与游戏</h1>
<p><strong>软件架构</strong>：架构是代码的构建模式、每个程序不论好坏都有其架构</p>
<p><strong>好的软件架构</strong>：架构是关于改动的—评价架构设计的好坏就是评价它应对改动有多么轻松</p>
<p><strong>处理代码改动</strong>：</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303301750097.png" alt="image-20230330175013047"></p>
<p><strong>解耦</strong>：最小化在编写代码前需要了解的信息，最小化更改一块代码时对其他部分的影响</p>
<p><strong>代价</strong>：抽象、模块化、设计模式和软件架构让程序的编写、拓展更有效率，让人可以行云流水的编写代码，但是需要注意的是，这也会带来更大的维护与管理成本，同时大幅提高代码的复杂度。**不要沉迷在代码中，而忘记了我们到底在写什么！**很多时候，You aren’t gonna need it！</p>
<ul>
<li>
<p>抽象和解耦让扩展代码更快更容易，但除非确信需要灵活性，否则不要在这上面浪费时间。</p>
</li>
<li>
<p>在整个开发周期中为性能考虑并做好设计，但是尽可能推迟那些底层的，基于假设的优化，那会锁死代码。</p>
</li>
<li>
<p>快速地探索游戏的设计空间，但不要跑得太快，在身后留下烂摊子。毕竟你总得回来打扫。</p>
</li>
<li>
<p>如果打算抛弃这段代码，就不要尝试将其写完美。摇滚明星将旅店房间弄得一团糟，因为他们知道明天就走人了。</p>
</li>
<li>
<p>但最重要的是，<strong>如果你想要做出让人享受的东西，那就享受做它的过程。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Design Pattern</category>
        <category>《Game Programming Patterns》</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>《游戏编程模式》</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【Algorithm4】读书笔记二：排序</title>
    <url>/posts/4002/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202310081712174.png" alt="algorithm4" style="zoom: 50%;" />
<blockquote>
<p><strong>官网：<a href="https://algs4.cs.princeton.edu/home/">https://algs4.cs.princeton.edu/home/</a></strong></p>
<p><strong>笔记目录：<a href="https://hmxs.games/posts/4000/">https://hmxs.games/posts/4000/</a></strong></p>
</blockquote>
<hr>
<h1>排序</h1>
<p>排序就是将一组对象按照某种逻辑顺序重新排列的过程，其在商业数据处理和现代科学计算方面都有着重要的地位，本章将聚焦于排序算法，介绍、研究并实现几种经典的排序算法。</p>
<p><em>使用了C++对排序算法进行了重新实现，在<a href="https://github.com/hmxsqaq/Algorithm-Sorting">这一Github仓库下</a>可以找到我的全部实现</em></p>
<h2 id="前言">前言</h2>
<h3 id="排序算法功能函数">排序算法功能函数</h3>
<p>下面是一些排序所需的基本方法的定义，通过这些函数我们可以进行一定程度的封装，使我们能够更好地追踪算法运行的过程，如一共进行了多少次的比较与多少次的交换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsSmaller</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsGreater</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEqual</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsSorted</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsSorted</span><span class="params">(<span class="type">const</span> std::list&lt;<span class="type">int</span>&gt; &amp;list)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVec</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVec</span><span class="params">(<span class="type">const</span> std::list&lt;<span class="type">int</span>&gt; &amp;list)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>IsSmaller/IsGreater/IsEqual</code>：比较两个数据的大小</li>
<li><code>Swap</code>：交换两个数据</li>
<li><code>PrintVec</code>：打印数组</li>
<li><code>IsSorted</code>：检查是否成功排序</li>
</ul>
<hr>
<h2 id="冒泡排序">冒泡排序</h2>
<blockquote>
<p><strong>冒泡排序（bubble sort）通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。</strong></p>
</blockquote>
<h3 id="实现">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsGreater</span>(vec[j], vec[j + <span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">Swap</span>(vec, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 <code>flag</code> 来监测这种情况，一旦出现就立即返回，对效率进行优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSortWithFlag</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsGreater</span>(vec[j], vec[j + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(vec, j, j + <span class="number">1</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特性">特性</h3>
<ul>
<li><strong>时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>、自适应排序</strong>：各轮“冒泡”遍历的数组长度依次为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mtext>、</mtext><mi>n</mi><mo>−</mo><mn>2</mn><mtext>、</mtext><mo>…</mo><mtext>、</mtext><mn>2</mn><mtext>、</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1、n−2、…、2、1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">、</span><span class="mord">2</span><span class="mord cjk_fallback">、</span><span class="mord">1</span></span></span></span>，总和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n−1)n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span>。在引入 <code>flag</code> 优化后，最佳时间复杂度可达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li><strong>空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>、原地排序</strong>：指针 i 和 j 使用常数大小的额外空间</li>
<li><strong>稳定排序</strong>：由于在“冒泡”中遇到相等元素不交换</li>
</ul>
<h2 id="选择排序">选择排序</h2>
<blockquote>
<p><strong>选择排序（selection sort）是最简单的排序算法之一，其核心思想是：不断选择最小/大的元素</strong></p>
</blockquote>
<p>我们会先找到数组中最小/大的元素，将其与数组的第一个元素交换位置；之后，在剩下的元素中找到最小/大的元素，将其与第二个元素交换位置；之后不断重复这一过程，直至最后一个元素</p>
<h3 id="实现-2">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; vec.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsSmaller</span>(vec[j], vec[min_index]))</span><br><span class="line">                min_index = j;</span><br><span class="line">        <span class="keyword">if</span> (min_index != i)</span><br><span class="line">            <span class="built_in">Swap</span>(vec, i, min_index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<blockquote>
<p><strong>对于长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的数组，选择排序需要大约<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span></span></span></span>此比较与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次比较，其时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>级别</strong></p>
</blockquote>
<p>其有两个鲜明的特点：</p>
<ul>
<li><strong>运行时间与输入无关</strong>：无论输入数组排序状态如何，是有序还是无序，对选择排序的运行效率都没有影响</li>
<li><strong>数据移动时最少的</strong>：选择排序的交换次数与数组大小是线性关系，其余任何算法都不具备这个特性（大部分都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>级别）</li>
</ul>
<h3 id="特性-2">特性</h3>
<ul>
<li><strong>时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>、非自适应排序</strong>：外循环共<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>轮，第一轮的未排序区间长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，最后一轮的未排序区间长度为2，即各轮外循环分别包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>、</mtext><mi>n</mi><mo>−</mo><mn>1</mn><mtext>、</mtext><mo>…</mo><mtext>、</mtext><mn>3</mn><mtext>、</mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">n、n−1、…、3、2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">、</span><span class="mord">3</span><span class="mord cjk_fallback">、</span><span class="mord">2</span></span></span></span>轮内循环，求和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(n−1)(n+2)2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">2</span></span></span></span></li>
<li><strong>空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>、原地排序</strong>：指针 i 和 j 使用常数大小的额外空间</li>
<li><strong>非稳定排序</strong>：元素有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变</li>
</ul>
<hr>
<h2 id="插入排序">插入排序</h2>
<blockquote>
<p><strong>插入排序的核心思想就如同在斗地主时整理手牌：将每张牌插入到已有的有序牌中的适当位置</strong></p>
</blockquote>
<p>在算法的实现中，由于要给元素腾出位置，我们需要将其余元素向右移动一位；与选择排序相同，索引左边的元素都是有序的，而当索引到达数组右端时，排序便完成了</p>
<h3 id="实现-3">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = vec[i], j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">IsSmaller</span>(num, vec[j - <span class="number">1</span>])) &#123;</span><br><span class="line">            vec[j] = vec[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[j] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析-2">分析</h3>
<blockquote>
<p><strong>对于长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的数组选择排序，其时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>级别</strong></p>
</blockquote>
<p>插入排序在部分情况下非常有效，其实际效率很大程度上取决于其需要进行插入的次数</p>
<p>如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。 下面是几种典型的部分有序的数组：</p>
<ul>
<li>数组中每个元素距离它的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
</ul>
<p>插入排序对这样的数组很有效，而选择排序则不然；事实上，当倒置数量很少时，插入排序很可能比其他任何算法都快</p>
<hr>
<h2 id="希尔排序">希尔排序</h2>
<blockquote>
<p><strong>希尔排序是一种基于插入排序的排序算法，其核心思想是：交换不相邻的元素以对数组的局部 进行排序，并最终用插入排序将局部有序的数组排序</strong></p>
</blockquote>
<p>在上面对于插入排序的分析中，我们了解到：当数组是部分有序的时，插入排序非常快；而希尔排序正是利用了这点，先使数组变得部分有序，再进行进一步的排序，以加快插入排序的速度</p>
<p>如下图所示，希尔排序会以h为步长将数组进行分割，假设数组为<code>[5, 7, 1, 4, 6, 9]</code>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">h=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，则数组会被分割为<code>[5, 4]</code>、<code>[7, 6]</code>、<code>[1, 9]</code>三组；首先对组内进行插入排序（一个更简单的方法是在子数组中将每个元素交换到比它大的元素之前去即可），便可以得到<code>[4, 5]</code>、<code>[6, 7]</code>、<code>[1, 9]</code>，这被称为<code>h有序数组</code>；之后我们便可以进一步缩小h，以得到更大的h有序数组，最后实现数组的排序</p>
<p>我们也可以从这一角度去思考：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>较大，在进行组内排序时便可以将元素移动到很远的地方，而插入排序只能一个个的进行元素移动，从而提高效率</p>
<p>在我们下面的实现中，使用了序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">(</mo><mn>3</mn><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1/2(3k-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/2</span><span class="mopen">(</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，即从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">N/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/3</span></span></span></span>开始递减至 1。我们把这个序列称为递增序列；下面的实现中实时计算了其递增序列，另一种方式是将递增序列存储在一个数组中</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401112336523.png" alt="image-20240111233622452"></p>
<h3 id="实现-4">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int</span> h = size / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> num = vec[i], j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= h &amp;&amp; <span class="built_in">IsSmaller</span>(num, vec[j - h])) &#123;</span><br><span class="line">                vec[j] = vec[j - h];</span><br><span class="line">                j -= h;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析-3">分析</h3>
<p>希尔排序比插入排序快了非常多</p>
<blockquote>
<p><strong>希尔排序更高效的原因是它权衡了子数组的规模和有序性</strong></p>
</blockquote>
<p>希尔排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序</p>
<p>而子数组部分有序的程度取决于递增序列的选择，但对于递增序列的选择是个复杂的问题：算法的性能不仅取决于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>，还取决于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>之间的数学性质，比如它们的公因子等；有很多论文研究了各种不同的递增序列，但都无法证明某个序 列是“最好的”；在我们的实现中，使用了非常简单易于计算的底层序列，但一些复杂的序列可以被证明其性能好于我们使用的序列，更加优秀的递增序列有待我 们去发现</p>
<p>透彻理解希尔排序的性能至今仍然是一项挑战；实际上，希尔排序是我们唯一无法准确描述其对于乱序的数组的性能特征的排序方法</p>
<hr>
<h2 id="归并排序">归并排序</h2>
<blockquote>
<p><strong>归并，即将两个有序数组合并成一个更大的有序数组；归并排序便是基于这一简单操作进行的</strong></p>
</blockquote>
<p>归并排序是一种基于分治思想的递归排序算法，要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来</p>
<p>归并排序的优点在于其能够保证，排序将任意长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的数组所需的时间与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>成正比；同时，其也存在所需的额外空间与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>成正比的缺点</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401122003737.png" alt="image-20240112200331668"></p>
<h3 id="归并的抽象实现">归并的抽象实现</h3>
<p>实现归并的一种直截了当的办法是将两个不同的有序数组归并到第三个数组中，创建一个适当大小的数组然后将两个输 入数组中的元素一个个从小到大放入这个数组中即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> mid, <span class="type">const</span> <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(length)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsSmaller</span>(vec[i], vec[j]))  temp[k++] = vec[i++];</span><br><span class="line">        <span class="keyword">else</span>                            temp[k++] = vec[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)    temp[k++] = vec[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)  temp[k++] = vec[j++];</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; length; ++k) &#123;</span><br><span class="line">        vec[k + left] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码演示了进行一次归并时进行的操作，需要创建一个临时数组作为辅助</p>
<p>上述代码可以完成一次归并，但是当我们想要用归并将一个大数组排序时，我们便需要进行多次归并，上述的方法会在每进行一次归并时都对原数组进行一次完整的复制，这会带来大量的内存消耗</p>
<p>与此相比，我们更需要一种“原地归并”的方法，使得我们不需要用一个额外的数组来存储数据，但实际上这是较为困难且复杂的；不管怎么说，上述方法仍然是有意义的，其帮助我们对归并操作进行了抽象化，我们可以在此基础上继续探索</p>
<h3 id="自顶向下的归并排序">自顶向下的归并排序</h3>
<p>基于归并的抽象实现，我们可以实现一种自顶向下的递归归并算法</p>
<p>这也是应用高效算法设计中分治思想的 最典型的一个例子</p>
<h4 id="实现-5">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortTopToBottom</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSortTopToBottom</span>(vec, left, mid);</span><br><span class="line">    <span class="built_in">MergeSortTopToBottom</span>(vec, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">Merge</span>(vec, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortTopToBottom</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">MergeSortTopToBottom</span>(vec, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析-4">分析</h4>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401122052338.png" alt="image-20240112205259265"></p>
<p>上图展示了自顶向下的归并排序算法的递归树</p>
<blockquote>
<p><strong>对于长度为 N 的任意数组，自顶向下的归并排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2}NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次比较；最多需要访问数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">6NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次</strong></p>
</blockquote>
<p>归并排序和之前的初级排序方法不可同日而语，它表明我们只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序；可以用归并排序处理数百万甚至更大规模的数组，这是插入排序或者选择排序做不到的</p>
<h3 id="改进-a-id-anchor-merge-insertion-a">改进<a id="anchor-merge_insertion"></a></h3>
<p>通过一些细致的思考我们还能够大幅度缩短归并排序的运行时间：</p>
<ul>
<li>对小规模子数组使用插入排序</li>
</ul>
<p>递归会使小规模问题中方法的调用过于频繁，而在前面对于插入排序的研究中，我们可以发现插入排序对于小数组可能比归并排序更快；在分割数组到足够小后，我们便可以采用插入排序，之后再进行归并，这可以提高算法的效率</p>
<ul>
<li>测试数组是否已经有序</li>
</ul>
<p>我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，我们就认为数组已经是有序 的并跳过 merge() 方法。这个改动不影响排序的递归调用，但是任意有序的子数组算法的运行时间 就变为线性的了</p>
<ul>
<li>不将元素复制到辅助数组</li>
</ul>
<p>我们可以节省将数组元素复制到用于归并的辅助数组所用的时间；这种方法需要一些技巧，我们要在递归调用的每个层次交换输入数组和辅助数组的角色；<code>merge</code>的过程类似对着一个源文本进行重新抄录，而此方法便是让两个数组轮流作为源文本</p>
<p><strong>以下代码对上述三个优化进行了实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeOptimized</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;source, std::vector&lt;<span class="type">int</span>&gt; &amp;destination, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> mid, <span class="type">const</span> <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsSmaller</span>(source[i], source[j]))    destination[k++] = source[i++];</span><br><span class="line">        <span class="keyword">else</span>                                    destination[k++] = source[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)    destination[k++] = source[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)  destination[k++] = source[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortOptimized</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;source, std::vector&lt;<span class="type">int</span>&gt; &amp;destination, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> kCUTOFF = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= kCUTOFF) &#123;  <span class="comment">// apply insertion sort for small subarrays</span></span><br><span class="line">        <span class="built_in">InsertionSort</span>(destination, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// *self-merge: avoid creating temp array when merging</span></span><br><span class="line">    <span class="built_in">MergeSortOptimized</span>(destination, source, left, mid);</span><br><span class="line">    <span class="built_in">MergeSortOptimized</span>(destination, source, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// test if array is sorted before merge</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsSmaller</span>(source[mid], source[mid + <span class="number">1</span>])) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>() + left, source.<span class="built_in">begin</span>() + right + <span class="number">1</span>, destination.<span class="built_in">begin</span>() + left);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MergeOptimized</span>(source, destination, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortOptimized</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">std::vector <span class="title">aux_vec</span><span class="params">(vec)</span></span>;</span><br><span class="line">    <span class="built_in">MergeSortOptimized</span>(aux_vec, vec, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自底向上的归并排序">自底向上的归并排序</h3>
<p>递归实现的归并排序是算法设计中分治思想的典型应用：我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题；尽管我们考虑的问题是归并两个大数组， 实际上我们归并的数组大多数都非常小</p>
<p>在自顶向下的归并排序中，我们会先从大数组入手，一步步将大数组分割为小数组；而我们实际上还可以直接从小数组入手，即把每个元素想象成一个大小为1的数组，然后两两归并、四四归并、八八归并…直到归并完成；这种归并排序的实现方法被称为自底向上的归并排序</p>
<h4 id="实现-6">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortBottomToTop</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> length = <span class="number">1</span>; length &lt; size; length *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>; left &lt; size - length; left += <span class="number">2</span> * length) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + length - <span class="number">1</span>;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> right = std::<span class="built_in">min</span>(left + <span class="number">2</span> * length - <span class="number">1</span>, size - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">Merge</span>(vec, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析-5">分析</h4>
<blockquote>
<p><strong>对于长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的任意数组，自底向上的归并排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2}NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次比较，最多访问数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">6NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次</strong></p>
</blockquote>
<p>这种实现方法的一个优势在于其比标准递归方法所需要的代码量要少很多</p>
<p>**当数组长度为2的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同；**其他时候，两种方法的比较和数组访问的次序会有所不同</p>
<p>自底向上的归并排序比较适合用链表组织的数据，其只需要重新组织链表链接就能将链表原地排序，而不需要创建任何新的链表结点</p>
<blockquote>
<p><strong>用自顶向下或是自底向上的方式实现任何分治类的算法都很自然</strong></p>
</blockquote>
<h3 id="排序算法的复杂度">排序算法的复杂度</h3>
<p>学习归并排序的一个重要原因是它是证明计算复杂性领域的一个重要结论的基础</p>
<p>对于基于比较的排序算法来说，其具有以下性质（<strong>此处，我们忽略了访问数组的开销</strong>）</p>
<blockquote>
<p><strong>没有任何基于比较的算法能够保证使用少于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mtext>～</mtext><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">lg(N!)～NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">!)</span><span class="mord cjk_fallback">～</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次比较将长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的数组排序</strong></p>
</blockquote>
<p><em>书中对于这一结论通过一个基于二叉树的数学模型给出了精彩的证明，这里不再赘述</em></p>
<p>这一性质告诉了我们在设计排序算法时能达到的上限与目标，如果没有这一结论，我们便可能会去尝试设计一个个在最坏情况下比较次数只有归并排序的一半的基于比较的算法；通过这一结论，我们便可以明确知道，这样的算法不存在</p>
<p>在上面对于归并排序的分析中，我们得到了归并排序在最坏情况下的比较次数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>这一结论，而在上面我们同样知道了没有任何排序算法能够用少于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mtext>～</mtext><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">lg(N!)～NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">!)</span><span class="mord cjk_fallback">～</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次比较将数组排序，这也就意味着：</p>
<blockquote>
<p><strong>归并排序是一种渐进最优的基于比较排序的算法</strong></p>
</blockquote>
<p><em>从严谨的角度来说，我们认为仅仅只需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>g</mi><mi>N</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">lgN!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">!</span></span></span></span>次比较的算法才是最优的排序算法，但在实际应用中，即使对于很大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，这种算法与归并排序之间的差异也并不明显</em></p>
<p>虽说我们已经盖棺定论地说归并排序已经是渐进最优了，但其仍然是有很多局限性的：</p>
<ul>
<li>归并排序的空间复杂度不是最优的</li>
<li>在实践中不一定会遇到最坏情况</li>
<li>除了比较，算法的其他操作（例如访问数组）也可能很重要</li>
<li>不进行比较也能将某些数据排序</li>
</ul>
<hr>
<h2 id="快速排序">快速排序</h2>
<p>终于来到大名鼎鼎的快速排序了，其可能是应用最为广泛的排序算法；快速排序实现简单、对输入的抵赖低同时在一般应用中比其他排序算法都要快得多，其在内存与效率上都非常优秀</p>
<ul>
<li>内存上，快速排序是原地排序，其只需要一个很小的辅助栈</li>
<li>效率上，快速排序将长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的数组排序所需的时间和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>成正比。</li>
</ul>
<h3 id="基本实现">基本实现</h3>
<p>快速排序同归并排序一样，也是一种基于分治思想的递归排序算法，它们都会将数组进行分割，并分别排序，不同的是它们在实现思路上是相反的，或者说互补的：</p>
<ul>
<li>归并排序会先对数组进行分割，然后将分割完成的数组分别排序，最后将已经有序的子数组进行归并从而实现对整个数组的排序；总的来说，归并排序是<strong>先递归再处理数组</strong></li>
<li>快速排序的思想则是其会依据数组元素的大小对数组进行分割，即“是当两个子数组都有序时整个数组也就自然有序了”；其是<strong>先处理数组再进行递归</strong>的</li>
</ul>
<p>形象的说，归并是在递归到底层之后向上返回的过程中完成对数组的排序；而快排则是当递归到底层后，排序就已经完成了</p>
<p>相对应的，归并排序中会通过递归调用<code>“归并（merge）”</code>来排序数组，而快速排序则是通过<code>“切分（partition）”</code></p>
<p>当我们对一个数组进行切分时，我们会从其中选定一个“切分元素”，之后通过元素交换实现：<strong>切分元素左边的元素都小于它，而其右边的元素都大于它</strong></p>
<p>通过递归地对数组进行切分，我们便可以完成对数组的排序，这便是快速排序的基本原理，下面便可以开始实现了</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202401142321251.png" alt="image-20240114232150071"></p>
<p>如上图所示，要实现快速排序的切分，一般的策略是先随意取一个元素作为切分元素，这里先取<code>a[lo]</code>，即最左边的元素；然后我们从数组的左端开始使用指针<code>i</code>向右扫描直到找到一个大于等于它的元素，再从数组的右端开始使用指针<code>j</code>向左扫描直到找到一个小于等于它的元素；这两个元素显然是没有排定的，因此我们交换它们的位置；如此继续，直到<code>i</code>与<code>j</code>相遇，再将切分元素交换到中间，我们就可以实现切分效果了</p>
<p>以下快速排序的基本实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> item = vec[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// stop even vec[i/j] == item, which may cause extra swap, but it can optimize elements&#x27; distribution</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">IsSmaller</span>(vec[++i], item)) <span class="keyword">if</span> (i == right) <span class="keyword">break</span>; <span class="comment">// prevent out-of-bounds</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">IsGreater</span>(vec[--j], item)) <span class="keyword">if</span> (j == left) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(vec, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Swap</span>(vec, left, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mid = <span class="built_in">Partition</span>(vec, left, right);</span><br><span class="line">    <span class="built_in">QuickSort</span>(vec, left, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(vec, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">QuickSort</span>(vec, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="避免糟糕的实现">避免糟糕的实现</h3>
<p>快速排序有着无数优点，但其非常“脆弱”，一些糟糕的实现会很容易导致糟糕的性能，让快速排序变成超慢排序🤣</p>
<p>以下是一些要点：</p>
<ul>
<li>原地切分</li>
</ul>
<p>我们可以轻易地像实现归并排序那样用一个辅助数组来实现切分，但其中因为开辟数组与数组复制所带来的的内存与效率损失会让我得不偿失</p>
<ul>
<li>数组越界问题</li>
</ul>
<p>在切分的内循环中，我们会依据切分元素扫描数组，而当切分元素是最小或最大的元素时，数组越界的问题便可能发生，在我们上面的实现中，我们通过<code>if (i == right) break</code>与<code>if (j == left) break</code>预防了这个问题</p>
<p>但实际上，上面实现中的<code>if (j == left) break</code>存在冗余，因为我们选择的切分元素是数组最左边的元素，而实际上<code>vec[j]</code>无论如何也不会小于<code>vec[left]</code>，所以这条语句实际上是可以删去的，在这一情况下，切分元素本身被作为了“哨兵”，防止了数组越界的产生</p>
<p>而实际上，我们也可以手动在数组最右端制造一个“哨兵”，如此一来<code>if (i == right) break</code>便也可以省去了；我们可以在开始排序前，将最大的元素放置在数组最右边，同时在递归左半部分的数组时，将上一轮的切分元素包含，即由<code>QuickSort(vec, left, mid - 1)</code>变为<code>QuickSort(vec, left, mid);</code>，因为上一轮的切分元素一定大于其左边的所有元素；这样在所有切分中，最右端的元素都是最大的，可以起到“哨兵”的作用了</p>
<ul>
<li>打乱数组，保持随机</li>
</ul>
<p>在排序开始前，我们可以对数组进行打乱，这一来是对算法效率测试的保证；二来，快速排序在面对一些特殊输入时会有极差的性能，如我们每次选取的切分元素都是最大/最小的元素，效率会来到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>级别，打乱数组可以避免这一点</p>
<ul>
<li>循环终止条件</li>
</ul>
<p>正确地检测指针是否越界需要一点技巧，并不像看上去那么容易；一个最常见的错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素</p>
<ul>
<li>处理切分元素值有重复的情况</li>
</ul>
<p>左侧扫描最好是在遇到大于等于切分元素值的元素时停下，右侧扫描则是遇到小于等于切分元素值的元素时停下；尽管这样可能会不必要地将一些等值的元素交换，但在某些典型应用中，它能够避免算法的运行时间变为平方级别；稍后我们会讨论另一种可以更好地处理含有大量重复值的数组的方法</p>
<ul>
<li>递归终止条件</li>
</ul>
<p>实现快速排序时一个常见的错误就是不能保证将切分元素放入正确的位置，从而导致程序在切分元素正好是子数组的最大或是最小元素时陷入了无限的递归循环之中</p>
<h3 id="分析-6">分析</h3>
<p>快速排序的效率如此之高的一个很重要的原因得益于其简洁高效的切分内循环，在快速排序的切分方法中环会用一个递增的索引将数组元素和一个定值比较，而希尔排序与归并排序则还需要在内循环中进行数据的移动</p>
<p>快速排序另一个速度优势在于它的比较次数很少</p>
<blockquote>
<p><strong>将长度为 N 的无重复数组排序，快速排序平均需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mn>2</mn><mi>N</mi><mi>l</mi><mi>n</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">~2NlnN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mspace nobreak"> </span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次比较（以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的交换）</strong></p>
</blockquote>
<p>总的来说，可以肯定的是对于大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的数组，快速排序的运行时间在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.39</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1.39NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1.39</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的某个常数因子的范围之内；归并排序也能做到这一点，但是快速排序一般会更快（尽管它的比较次数多<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>39</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">39\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">39%</span></span></span></span>），因为它移动数据的次数更少；这些保证都来自于数学概率</p>
<h3 id="改进">改进</h3>
<p>快速排序是由 C.A.R Hoare 在 1960 年发明的，几乎从 Hoare 第一次发表这个算法开始，人们就不断地提出各种改进方法；并不是所有的想法都可行，因为快速排序的平衡性已经非常好，改进所带来的提高可能会被意外的副作用所抵消；但其中一些，也是我们现在要介绍的，非常有效</p>
<h4 id="对小规模子数组使用插入排序">对小规模子数组使用插入排序</h4>
<p>同样的方法我们在之前介绍<a href="#anchor-merge_insertion">归并排序的改进方法</a>时已经用过，此处的思路也差不多</p>
<ul>
<li>对于小数组，快速排序比插入排序慢</li>
<li>因为递归，快速排序的<code>QuickSort()</code>方法在小数组中也会调用自己</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> kCUTOFF = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= kCUTOFF) &#123; <span class="comment">// apply insertion sort for small subarrays</span></span><br><span class="line">        <span class="built_in">InsertionSort</span>(vec, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mid = <span class="built_in">Partition3Sample</span>(vec, left, right);</span><br><span class="line">    <span class="built_in">QuickSort</span>(vec, left, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(vec, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切换阈值<code>kCUTOFF</code>的最佳值是和系统相关的，但是5～15之间的任意值在大多数情况下都能令人满意</p>
<h4 id="三取样切分">三取样切分</h4>
<p>快速排序的效率很大程度上取决于切分元素的选择，其最优情况便是切分元素正好等于数组元素的中位数，但要计算出这一数值便意味着我们需要在每次切分时都进行一次遍历，这是得不偿失的</p>
<p>在我们目前的实现中，我们通过打乱数组完全消除了输入的影响，使得切分元素的选取完全随机，这样可以在完全不计算中位数的情况下达到平均的效率</p>
<p>而取样切分则使用子数组的一小部分元素的中位数来切分数组，这可以让切分更优秀，虽然同样会付出计算中位数的代价，但这明显比遍历好多了，这种代价是可以接受的；人们发现将取样大小设为3并用大小居中的元素切分的效果最好</p>
<p>同时，取样切分可以带来的额外好处是，我们不需要进行特别的处理便可以将取样元素所谓哨兵使用，这样可以去除切分算法中的边界检查</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition3Sample</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sample item at left/mid/right</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsGreater</span>(vec[mid], vec[right])) <span class="built_in">Swap</span>(vec, right, mid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsGreater</span>(vec[mid], vec[left])) <span class="built_in">Swap</span>(vec, left, mid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsGreater</span>(vec[left], vec[right])) <span class="built_in">Swap</span>(vec, left, right);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> item = vec[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">IsSmaller</span>(vec[++i], item)) &#123;&#125; <span class="comment">// prevent out-of-bounds</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">IsGreater</span>(vec[--j], item)) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(vec, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Swap</span>(vec, left, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="熵最优排序-三向切分">熵最优排序 - 三向切分</h4>
<p>在排序算法的实际应用中，常常会遇到有着大量相同元素的输入源，如按生日、性别进行排序；在这些情况下，快速排序的效率仍然有着很大的进步空间；如，对于一个完全由相同元素构成的数组，快排仍会对其进行切分。</p>
<p>上述问题的一个解决方案便是三向切分，即将数组分为三部分：大于、等于、小于切分元素，而不是直接二分；当然这肯定会加大算法设计的难度，下面便是由<code>Dijkstra</code>提出的简洁实现，其通过引入一个额外指针划分出等于区。</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202409012349345.png" alt="image-20240901234931167" style="zoom:150%;" />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort3Way</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> less_then_i = left, i = left + <span class="number">1</span>, greater_than_i = right;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> item = vec[left];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= greater_than_i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsSmaller</span>(vec[i], item)) &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(vec, less_then_i++, i++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsGreater</span>(vec[i], item)) &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(vec, greater_than_i--, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">QuickSort3Way</span>(vec, left, less_then_i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort3Way</span>(vec, greater_than_i + <span class="number">1</span> , right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="优先队列（堆排序）">优先队列（堆排序）</h2>
<p>在排序算法的一些实际应用中，我们有时不一定要求数据的全局有序，如在安排应用程序处理的优先级时，我们只需要确保总是处理优先级最高的程序即可。而优先队列便是基于这一思想设计的抽象数据类型，一个优先队列往往会包含_删除最大元素_与_插入元素_两种基本操作。</p>
<h3 id="优先队列的初级实现">优先队列的初级实现</h3>
<p>我们可以使用之前的排序算法，如插入排序，快速地实现优先队列，在访问元素或插入元素时自动地对数组调用一次排序算法即可，这样的实现是一种对排序算法的封装，在速度与内存上的提升有限，这里不再赘述。</p>
<h3 id="基于二叉堆的优先队列">基于二叉堆的优先队列</h3>
<blockquote>
<p><strong><code>二叉堆</code>是一种完全二叉树，其每个节点都大于或等于它的两个子节点</strong></p>
</blockquote>
<p>使用二叉堆可以很好地实现优先队列的基本操作，基于二叉堆的性质，我们可以使用一个数组来实现二叉堆。其中，位置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>的父节点的两个子节点位置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，同时我们只需通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/2</span></span></span></span>便可以找到节点的父节点。</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202409292238212.png" alt="image-20240929223824022" style="zoom: 80%;" />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxPriorityQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxPriorityQueue</span>() &#123; pq_.<span class="built_in">push_back</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        pq_.<span class="built_in">push_back</span>(key);</span><br><span class="line">        <span class="built_in">Swim</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(pq_.<span class="built_in">size</span>()) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ExtractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pq_.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">        <span class="type">int</span> max = pq_[<span class="number">1</span>];</span><br><span class="line">        pq_[<span class="number">1</span>] = pq_.<span class="built_in">back</span>();</span><br><span class="line">        pq_.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">Sink</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">GetMax</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pq_.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pq_[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pq_.<span class="built_in">size</span>() &lt;= <span class="number">1</span>; &#125;</span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">size_t</span> <span class="title">GetSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pq_.<span class="built_in">size</span>() - <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; pq_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Swim</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; pq_[i / <span class="number">2</span>] &lt; pq_[i]) &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(pq_, i / <span class="number">2</span>, i);</span><br><span class="line">            i /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sink</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> child = <span class="number">2</span> * i;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; pq_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child &lt; pq_.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; pq_[child] &lt; pq_[child + <span class="number">1</span>]) child++;</span><br><span class="line">            <span class="keyword">if</span> (pq_[i] &gt;= pq_[child]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">Swap</span>(pq_, i, child);</span><br><span class="line">            i = child;</span><br><span class="line">            child = <span class="number">2</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上便是最大堆在<code>C++</code>中的基础实现。使用了<code>std::vector</code>作为存储数据的容器，其中我们跳过了数组的第0位，这是为了让父子节点的对应关系更加简洁。</p>
<p>在实现二叉堆时，两个操作至关重要：</p>
<ol>
<li><code>Swim</code>上浮：由下至上的堆有序化</li>
</ol>
<p>插入元素时，插入的元素可能大于其父节点，我们便需要将其“上浮”——如果元素大于父节点，我们便将其不断地与其父节点进行交换，直到遇到根节点或其小于父节点时。这一操作就像元素不断地向上游（交换）。</p>
<ol start="2">
<li><code>Sink</code>下沉：由上至下的堆有序化</li>
</ol>
<p>删除最大元素时，我们会从数组中选择一个元素填充到根节点中（在上面的实现中是最后的元素），这会导致父节点小于子节点，我们便需要将其“下沉”——如果元素小于子节点之一，我们便将其不断地与其子节点中较大的一个进行交换。这一操作就像元素不断地下沉。</p>
<h3 id="堆排序">堆排序</h3>
<p>我们可以将优先队列转化为一种排序算法——堆排序，其可以被分为两个阶段：</p>
<ol>
<li>堆的构造——将原始数据重新安排进堆中</li>
<li>下沉排序——从堆中逐个取出所有元素得到最终结果</li>
</ol>
<p>如下所示，堆排序的最简单实现方法便是直接构造一个新堆，将待排序数组的每个元素都插入中堆中，再一个个取出最大/最小元素即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    MaxPriorityQueue pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : vec) pq.<span class="built_in">Insert</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i : vec) i = pq.<span class="built_in">ExtractMax</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果像上面这样实现堆排序的话，因为我们新建了一个堆空间，这会带来<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>的空间复杂度，而实际上我们可以做到原地堆排序。</p>
<p>同时，如果我们直接使用<code>Insert</code>方法对堆进行构造，我们便需要调用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次<code>Swim</code>函数将元素一个个上浮，而实际上改用<code>Sink</code>函数完成堆的构造是更加聪明的做法。我们可以将数组视为一些小堆的集合，进而我们可以每个小堆的根节点调用<code>Sink</code>；而如果一个结点的两个子结点都已经是堆了，那么在该结点上调用<code>Sink</code>可以将它们变成一个大堆。如此一来便可以递归地构造堆。</p>
<p>这样做的优势是，对于堆底层的元素，因为它们没有子节点，我们便可以直接跳过它们，这可以让我们只调用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/2</span></span></span></span>次<code>Sink</code>，比原先的方法足足少了一半。</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202409300306001.png" alt="image-20240930030624815" style="zoom:67%;" />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SinkFrom0</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> root, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> child = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child &lt; end &amp;&amp; <span class="built_in">IsSmaller</span>(vec[child], vec[child + <span class="number">1</span>])) child++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsGreater</span>(vec[root], vec[child]) || <span class="built_in">IsEqual</span>(vec[root], vec[child])) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(vec, root, child);</span><br><span class="line">        root = child;</span><br><span class="line">        child = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSortInPlace</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">SinkFrom0</span>(vec, i, size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">Swap</span>(vec, <span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">SinkFrom0</span>(vec, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序在排序复杂性的研究中有着重要的地位，其是我们所知的唯一能够同时最优地利用空间和时间的方法——在最坏的情况下它也能保证使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>～</mtext><mn>2</mn><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">～2NlgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">～</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次比较和恒定的额外空间。当空间十分紧张的时候（例如在嵌入式系统或低成本的移动设备中）堆排序很流行，其只用几行就能实现（甚至机器码也是）较好的性能。</p>
<p>但现代系统的许多应用很少使用它，因为它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法，如快速排序、归并排序，甚至是希尔排序。</p>
<h2 id="总结与拾遗">总结与拾遗</h2>
<h3 id="排序算法的稳定性">排序算法的稳定性</h3>
<blockquote>
<p><strong>如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是<code>稳定的</code></strong></p>
</blockquote>
<p>虽然稳定性是个不错的性质，我们也有很多办法能够将任意排序算法变成稳定的，但一般只有在稳定性是必要的情况下稳定的排序算法才有优势，事实上没有任何实际应用中常见的方法不是用了大量额外的时间和空间才做到了这一点。</p>
<h3 id="排序算法的横评">排序算法的横评</h3>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202409300316418.png" alt=""></p>
<blockquote>
<p><strong>在大多数实际情况中，快速排序是最佳选择，其是最快的通用排序算法</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Algorithm</category>
        <category>《Algorithms, 4th Edition》</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Note</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏编程模式】读书笔记三：享元模式、观察者模式</title>
    <url>/posts/2003/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304032232057.jpeg" alt="img"></p>
<blockquote>
<p><strong>《游戏编程模式》-Bob Nystrom</strong></p>
<p><strong>书籍汉化版网址：<a href="https://gpp.tkchu.me/">https://gpp.tkchu.me/</a></strong></p>
<p><strong>笔记目录：<a href="https://hmxs.games/posts/2000/">https://hmxs.games/posts/2000/</a></strong></p>
</blockquote>
<hr>
<h1>享元模式</h1>
<h2 id="基本定义与概念">基本定义与概念</h2>
<p>享元模式(FlyweightPattern)是以效率为核心的设计模式，当我们有大量类似对象需要进行实例化时，如果直接一个一个类的进行创建，那其将占用大量的内存空间。而享元模式将其对象的数据分为两部分—共享部分(如材质、模型)与其他部分(如大小、坐标)分别储存，共享部分只声明一片固定空间，所有对象持有对该空间的引用，这样生成对象时便只需要关心其他部分的数据即可。</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304032355080.png" alt="一行树，每棵都有自己的网格、纹理、树叶，调节参数和位置朝向。" style="zoom: 67%;" />
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304032355211.png" alt="一行树，每个都有自己的参数和位置朝向，指向另一个有网格、纹理、树叶的树模型。" style="zoom:67%;" />
<h3 id="应用场景">应用场景</h3>
<ul>
<li>有大量相同相似对象需要实例化</li>
<li>这些对象存在数据可以共享</li>
</ul>
<h3 id="优点">优点</h3>
<ul>
<li>节省内存开销，提高效率</li>
<li>在大量创建实例时更方便管理</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>如果需要实例化的对象不够多，享元模式的引入反而会增加代码管理成本</li>
<li>创建对象的过程可能更加繁琐</li>
</ul>
<h2 id="Unity简单实现">Unity简单实现</h2>
<p>Unity中的预制体、材质球等本身便是应用享元模式进行开发的，如多个物体共用一个材质球等</p>
<p>享元的核心其实便是共享一部分不变的数据来节省空间，在Unity中通过ScriptableObject,静态类等都可以实现共享数据这一功能，同时其与建造者模式、工厂模式都有着不错的相性</p>
<p>以下为一些简单的实现：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">FlyweightPattern</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 共享数据类(使用Struct应该也行)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在具体对象中持有该类的引用即可</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyweightClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 共享数据</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Hp;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> Speed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FlyweightClass</span>(<span class="params"><span class="built_in">int</span> hp, <span class="built_in">float</span> speed</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Hp = hp;</span><br><span class="line">            Speed = speed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 共享数据SO</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在菜单中右键创建SO文件或使用ScriptableObject.CreateInstance方法创建SO实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在具体对象中持有SO文件的引用即可</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;Data&quot;</span>,menuName = <span class="string">&quot;SO/Flyweight&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyweightSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> hp;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1>观察者模式</h1>
<h2 id="基本定义与概念-2">基本定义与概念</h2>
<p>观察者模式(ObserverPattern)是一种可以将代码的调用与对于调用的响应分离的设计模式，这是一种极重要的设计模式，C#中的event系统便是基于观察者模式实现的。在观察者模式中，观察者拥有具体的需要执行的代码，被观察者则仅需要负责发出通知，观察者监听到了对应的通知就会执行对应的代码。当我们编写被观察者的其他代码时，便无需关心奇怪的耦合问题，只需要专注于被观察者本身，在需要触发对应事件的时候发出通知即可。</p>
<h3 id="应用场景-2">应用场景</h3>
<ul>
<li>当一个事件会触发一个或多个分属于不同系统的行为时</li>
<li>当程序耦合严重时，观察者模式可以解除观察者与被观察者之间的依赖</li>
</ul>
<h3 id="Unity简单实现-2">Unity简单实现</h3>
<p>*此处我直接实现了事件中心，这也是观察者模式的一种体现，引入了事件中心类作为第三方管理者统一订阅与触发事件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ObserverPattern</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EventCenter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">string</span>, Action&gt; Events = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Action&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>(<span class="params"><span class="built_in">string</span> key, Action action</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Events.ContainsKey(key))</span><br><span class="line">            &#123;</span><br><span class="line">                Events.Add(key,action);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Events[key] += action;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>(<span class="params"><span class="built_in">string</span> key, Action action</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Events.ContainsKey(key))</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">$&quot;EventCenter:can&#x27;t find <span class="subst">&#123;key&#125;</span> when remove&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Events[key] -= action;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Trigger</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Events.ContainsKey(key))</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">$&quot;EventCenter:can&#x27;t find <span class="subst">&#123;key&#125;</span> when trigger&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Events[key]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Notes</category>
        <category>Design Pattern</category>
        <category>《Game Programming Patterns》</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>《游戏编程模式》</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏编程模式】读书笔记二：命令模式</title>
    <url>/posts/2002/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303301905867.jpeg" alt="img"></p>
<blockquote>
<p><strong>《游戏编程模式》-Bob Nystrom</strong></p>
<p><strong>书籍汉化版网址：<a href="https://gpp.tkchu.me/">https://gpp.tkchu.me/</a></strong></p>
<p><strong>笔记目录：<a href="https://hmxs.games/posts/2000/">https://hmxs.games/posts/2000/</a></strong></p>
</blockquote>
<hr>
<h1>命令模式</h1>
<h2 id="基本定义与概念">基本定义与概念</h2>
<p>命令模式(Command Pattern)是一种将函数调用对象化的设计模式，“When I’ve used it in the right place, it’s neatly untangled some really gnarly code.”，其可以增加代码的条理性，同时使得代码有更好的拓展性。命令模式的核心是将回调用面向对象的方法进行实现，让方法的调用对象化，当方法成为对象，记录与替换它们就变得很容易。</p>
<h3 id="应用场景">应用场景</h3>
<ul>
<li>有回溯/撤销命令的需求时</li>
<li>有按键更改/方法替换的需求时</li>
<li>有记录指令日志的需求时</li>
</ul>
<h3 id="优点">优点</h3>
<ul>
<li>当在正确的地方使用时，可以将复杂的代码清理干净</li>
<li>让命令本身变为实例，提高代码的拓展性</li>
<li>可以为实现“指令的撤销”带来极大的便利</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>造成额外的内存开销</li>
</ul>
<hr>
<h2 id="Unity简单实现">Unity简单实现</h2>
<h3 id="命令基类-接口">命令基类/接口</h3>
<p>此处为C#的接口实现，也可通过抽象类+虚函数的方法实现</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传入了一个GameObject作为参数，表示命令作用的对象，也可不传/传别的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">GameObject obj</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体命令">具体命令</h3>
<p>此处创建了两个具体命令:JumpCommand,WalkCommand，具体命令需继承自ICommand接口，并实现Execute方法</p>
<p>实现的Execute函数为命令的具体逻辑，如果需要可以通过构造函数传入参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JumpCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">GameObject obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(obj.name + <span class="string">&quot;Jump&quot;</span>);</span><br><span class="line">        <span class="comment">// 具体方法逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WalkCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector2 _targetPos;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置构造函数传入参数，设定命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WalkCommand</span>(<span class="params">Vector2 pos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _targetPos = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">GameObject obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(obj.name + <span class="string">&quot;Walk to&quot;</span> + _targetPos);</span><br><span class="line">        <span class="comment">// 具体方法逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命令调用">命令调用</h3>
<p>创建继承MonoBehaviour类的脚本用于调用命令</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InputHandler</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector2 _pos; <span class="comment">// 模拟物体移动</span></span><br><span class="line">    <span class="keyword">private</span> ICommand _currentCommand;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _currentCommand = InputCommand();</span><br><span class="line">        <span class="keyword">if</span> (_currentCommand != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _currentCommand.Execute(gameObject); <span class="comment">// 执行命令</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接收输入，返回对应命令</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ICommand <span class="title">InputCommand</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.A)) <span class="keyword">return</span> <span class="keyword">new</span> JumpCommand();</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.D))</span><br><span class="line">        &#123;</span><br><span class="line">            _pos += Vector2.one;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WalkCommand(_pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们可以通过命令模式在“输入”与“调用函数”之间添加了一层间接寻址，使得“输入”与“调用函数”之间不存在硬编码:</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304022311986.png" alt="img"></p>
<hr>
<h2 id="命令的撤销">命令的撤销</h2>
<p>在命令模式中，每一条命令都是一个实际存在的类，由此我们可以很方便的实现回滚操作/撤销指令等功能，这在回合制游戏中有着重要的作用</p>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304030023331.png" alt="从旧到新排列的命令栈。 一个当前箭头指向一条命令，一个“撤销”箭头指向之前的命令，一个“重做”指向之后的命令"></p>
<p>以下代码实现了指令的撤销：</p>
<p>为接口与命令类实现Undo方法，在其中编写撤销代码，当我们需要撤销某一条命令时，我们便只需要调用该命令的Undo方法即可</p>
<p>因为撤销方法往往有着对储存之前状态的需求，我们可以在命令类的构造函数中传入这些状态，并且声明私有变量来存储它们</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Undo</span>()</span>;<span class="comment">// 撤销方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JumpCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log( <span class="string">&quot;Jump&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Jump Undo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WalkCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GameObject _obj;</span><br><span class="line">    <span class="keyword">private</span> Vector2 _beforePos;<span class="comment">// 存储之前的位置</span></span><br><span class="line">    <span class="keyword">private</span> Vector2 _targetPos;<span class="comment">// 目标位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以设置构造函数传入参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WalkCommand</span>(<span class="params">GameObject obj,Vector2 pos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _obj = obj;</span><br><span class="line">        _beforePos = obj.GetComponent&lt;InputHandler&gt;().pos;</span><br><span class="line">        _targetPos = _beforePos + pos;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _obj.GetComponent&lt;InputHandler&gt;().pos = _targetPos;</span><br><span class="line">        Debug.Log(_obj.name + <span class="string">&quot;Walk To&quot;</span> + _targetPos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _obj.GetComponent&lt;InputHandler&gt;().pos = _beforePos;</span><br><span class="line">        Debug.Log(_obj.name + <span class="string">&quot;Back To&quot;</span> + _beforePos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用命令的脚本中，通过Unity提供的List<T>来存储指令，通过一个int变量_commandHead表示List的指针，指向当前命令，通过对commandHead的改变便可以灵活调用指令</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InputHandler</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ICommand&gt; _commands = <span class="keyword">new</span>();<span class="comment">// 储存命令的List</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _commandHead = <span class="number">-1</span>;<span class="comment">// 命令指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 pos;<span class="comment">// 模拟物体移动</span></span><br><span class="line">    <span class="keyword">private</span> ICommand _currentCommand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _currentCommand = InputCommand();</span><br><span class="line">        <span class="keyword">if</span> (_currentCommand != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 执行命令</span></span><br><span class="line">            _commandHead += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (_commands.Count &lt;= _commandHead)</span><br><span class="line">                _commands.Add(_currentCommand);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                _commands[_commandHead] = _currentCommand;</span><br><span class="line">            _commands[_commandHead].Execute();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Z))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 撤销命令</span></span><br><span class="line">            <span class="keyword">if</span> (_commandHead &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _commands[_commandHead].Undo();</span><br><span class="line">                _commandHead -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收输入，返回对应命令</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ICommand <span class="title">InputCommand</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.A)) <span class="keyword">return</span> <span class="keyword">new</span> JumpCommand();</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.D))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WalkCommand(gameObject, Vector2.one);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Design Pattern</category>
        <category>《Game Programming Patterns》</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>《游戏编程模式》</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏编程模式】读书笔记四：原型模式、单例模式</title>
    <url>/posts/2004/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304060426139.jpeg" alt="img"></p>
<blockquote>
<p><strong>《游戏编程模式》-Bob Nystrom</strong></p>
<p><strong>书籍汉化版网址：<a href="https://gpp.tkchu.me/">https://gpp.tkchu.me/</a></strong></p>
<p><strong>笔记目录：<a href="https://hmxs.games/posts/2000/">https://hmxs.games/posts/2000/</a></strong></p>
</blockquote>
<hr>
<h1>原型模式</h1>
<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304061710457.png" alt="一个生产者包含一个对怪物应用的原型字段。 他调用原型的clone()方法来产生新的怪物。"></p>
<h2 id="基本定义与概念">基本定义与概念</h2>
<p>原型模式(PrototypePattern)是一种创建型设计模式，设计之初是为了解决&quot;重复创建类似对象&quot;这一问题，其提倡通过预先创建一个&quot;原型对象&quot;，再通过对原型进行克隆的方式创建对象。虽然在今时今日原始的原型模式实现方式已经有些过时，很多语言已经将原型模式纳入了其语言特性中(如Unity中的Instantiate方法)，但其思想仍然有值得学习借鉴的地方，如在我们通过JSON配置对象数据时，我们便可以将一部分相同的数据作为原型部分来提高效率。</p>
<hr>
<h1>单例模式</h1>
<h2 id="基本定义与概念-2">基本定义与概念</h2>
<p>单例模式(Singleton)是最易于使用，同时也存在着许多争议的一种设计模式。其理念是:**保证一个类只有一个实例，并且提供访问该实例的全局访问点。**从另一个角度来说，单例模式是一种将全局状态封装为类的模式。其有着鲜明的优缺点，它是一种方便好用的设计模式，但是它也有着很多缺陷，依据本书作者的话来说，使用它更接近一种“饮鸩止渴”的状态。</p>
<h3 id="优点">优点</h3>
<ul>
<li>使用懒汉式单例时，惰性加载可以一定程度上节省内存，没人调用它时，其便不会被创建</li>
<li>与静态/全局状态相比，其在运行时进行实例化，这让其初始化变得方便，不必担心引用问题</li>
<li>因其可以被全局访问，调用它非常轻松惬意</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>全局访问的特性，让理解代码变得困难，同时并不安全，因为所有人都能访问到，也让并行开发变得困难</li>
<li>使用懒汉式单例时，惰性加载让准确控制其加载时机变得困难，无法手动控制其内存</li>
<li>饿汉式单例随没有惰性加载的问题，但其相比静态类很难突出其优势</li>
</ul>
<h2 id="Unity简单实现">Unity简单实现</h2>
<p>Singleton懒汉式泛型基类实现：分为不继承Mono与继承Mono两个版本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">SingletonPattern</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> T _instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T Instance</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _instance = <span class="keyword">new</span> T();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonMono</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">SingletonMono</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> T _instance;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> T Instance</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(_instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    GameObject obj = <span class="keyword">new</span> GameObject</span><br><span class="line">                    &#123;</span><br><span class="line">                        name = <span class="keyword">typeof</span>(T).ToString()</span><br><span class="line">                    &#125;;</span><br><span class="line">                    DontDestroyOnLoad(obj);</span><br><span class="line">                    _instance = obj.AddComponent&lt;T&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Design Pattern</category>
        <category>《Game Programming Patterns》</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>《游戏编程模式》</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏编程模式】读书笔记六：序列模式（更新中）</title>
    <url>/posts/2006/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304070014396.jpeg" alt="img"></p>
<blockquote>
<p><strong>《游戏编程模式》-Bob Nystrom</strong></p>
<p><strong>书籍汉化版网址：<a href="https://gpp.tkchu.me/">https://gpp.tkchu.me/</a></strong></p>
<p><strong>笔记目录：<a href="https://hmxs.games/posts/2000/">https://hmxs.games/posts/2000/</a></strong></p>
</blockquote>
<hr>
<h1>序列模式</h1>
<p>在游戏制作中，“时间”是一个极其重要的概念，我们需要为我们创造的虚拟世界赋予时钟。本章节序列模式(SequencingPatterns)便是构建时钟的工具。</p>
<p><strong>游戏循环</strong>是时钟的主轴</p>
<p>对象通过<strong>Update方法</strong>响应游戏循环</p>
<p>应用<strong>双缓冲模式</strong>可以储存快照来隐藏计算机顺序执行的特性，使游戏看起来是同步更新的</p>
<hr>
<h2 id="双缓冲模式">双缓冲模式</h2>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Design Pattern</category>
        <category>《Game Programming Patterns》</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>《游戏编程模式》</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏编程模式】读书笔记五：状态模式</title>
    <url>/posts/2005/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304070014396.jpeg" alt="img"></p>
<blockquote>
<p><strong>《游戏编程模式》-Bob Nystrom</strong></p>
<p><strong>书籍汉化版网址：<a href="https://gpp.tkchu.me/">https://gpp.tkchu.me/</a></strong></p>
<p><strong>笔记目录：<a href="https://hmxs.games/posts/2000/">https://hmxs.games/posts/2000/</a></strong></p>
</blockquote>
<hr>
<h1>状态模式</h1>
<h2 id="有限状态机FSM">有限状态机FSM</h2>
<p>有限状态机帮助我们梳理角色的状态，防止出现一些可能由“连点”等操作导致的让一个动作不断重复的bug。unity中的动画系统很大程度上便是基于FSM进行设计的。本章通过FSM引入状态模式</p>
<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202304070016740.png" alt="一张画有盒子的图表，盒子代表了站立，跳跃，俯卧和跳斩。标记了按键的按下和释放的箭头连接了这些盒子。" style="zoom:50%;" />
<h3 id="定义">定义</h3>
<ul>
<li>状态机拥有所有可能状态</li>
<li>状态机同时只能存在一个状态</li>
<li>状态机可以接收连续的输入与事件</li>
<li>每个状态都有一系列状态转移方法，这些方法与输入和另一状态相关</li>
</ul>
<h3 id="FSM的简单实现">FSM的简单实现</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">StatePattern</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleFSM</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 状态枚举</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">enum</span> State</span><br><span class="line">        &#123;</span><br><span class="line">            Idle,</span><br><span class="line">            Attack,</span><br><span class="line">            Walk</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> State _current;<span class="comment">// 当前状态</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _current = State.Idle;<span class="comment">// 初始状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每帧判断状态</span></span><br><span class="line">            <span class="keyword">switch</span> (_current)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> State.Idle:</span><br><span class="line">                    Idle();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> State.Attack:</span><br><span class="line">                    Attack();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> State.Walk:</span><br><span class="line">                    Walk();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体状态逻辑</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Idle</span>()</span> &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span> &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Walk</span>()</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象的状态模式">面向对象的状态模式</h2>
<blockquote>
<p>GoF: 允许一个对象在其内部状态发生变化时改变自己的行为，该对象看起来好像修改了它的类型</p>
</blockquote>
<p>Switch方法已经可以很好的实现一个简单的状态机了，但是在FSM中，我们可以更进一步，通过OOP的思想来编写FSM。通过实现状态接口、让每个状态成为类、状态委托这三步便可以实现这一点。其核心目的是将状态的行为和数据封装到单一类中。</p>
<h3 id="动态面向对象FSM实现">动态面向对象FSM实现</h3>
<p><strong>状态基类与状态类</strong>：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">StatePattern</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">FsmBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span> &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FsmBase <span class="title">TransitState</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IdleState</span> : <span class="title">FsmBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">float</span> _changeTime;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IdleState</span>(<span class="params"><span class="built_in">float</span> changeTime</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _changeTime = changeTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Idle Enter&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Idle Update&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> FsmBase <span class="title">TransitState</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _changeTime -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (_changeTime &lt; <span class="number">0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AttackState();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AttackState</span> : <span class="title">FsmBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Attack Exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Attack Update&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> FsmBase <span class="title">TransitState</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.A))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> IdleState(<span class="number">3f</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>人物脚本</strong>：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">StatePattern</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> FsmBase _current;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _current = <span class="keyword">new</span> IdleState(<span class="number">1f</span>);</span><br><span class="line">            _current.OnEnter();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            FsmBase temp = _current.TransitState();</span><br><span class="line">            <span class="keyword">if</span> (temp != _current)</span><br><span class="line">            &#123;</span><br><span class="line">                _current.OnExit();</span><br><span class="line">                _current = temp;</span><br><span class="line">                _current.OnEnter();</span><br><span class="line">            &#125;</span><br><span class="line">            _current.OnUpdate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发状态机">并发状态机</h2>
<p>当我们通过FSM来管理一个角色的状态，有走、跑、跳等，若我们现在想为这个角色添加各类武器，若我们仍然通过单一FSM来进行管理，状态就会变成走斩、跑斩、跳劈、走射、跑射等，如果我们还想添加别的角色模块，就会让单一FSM的状态数量成指数上涨，这并不易于编写。</p>
<p>这种情况下，并发状态机便可以被使用，其核心便是<strong>分离角色状态，通过复数状态机进行管理</strong>，如上述例子中，可以分离为“角色动作”与“角色装备”，通过两个同时运行的状态机进行管理。</p>
<h2 id="分层状态机">分层状态机</h2>
<p>当状态机中有多个状态有部分相似的行为时，我们便可以通过分层状态机来减少代码编写量。</p>
<p>因为我们采用了OOP的思想来建构状态机，而OOP中类共享代码的形式为继承，我们便可以为这些状态创建父类作为父状态，子状态进行继承即可。</p>
<h2 id="下推状态机">下推状态机</h2>
<p>通过状态栈来管理状态，把新状态推入栈，当前状态为栈顶的状态，当我们不需要该状态时出栈即可，这样便可以实现记忆状态的目的。</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Design Pattern</category>
        <category>《Game Programming Patterns》</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>《游戏编程模式》</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>FlappyBird</title>
    <url>/posts/16350/</url>
    <content><![CDATA[<p><img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303251606418.png" alt="FlappyBird"></p>
<blockquote>
<p><strong>项目地址：</strong></p>
<p>Unity: <a href="https://github.com/hmxsqaq/Unity-FlappyBird">https://github.com/hmxsqaq/Unity-FlappyBird</a></p>
<p>Pygame: <a href="https://github.com/hmxsqaq/Pygame-FlappyBird">https://github.com/hmxsqaq/Pygame-FlappyBird</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Projects</category>
        <category>经典小游戏复刻</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>GameProject</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>2048</title>
    <url>/posts/42265/</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303251612203.png" alt="2048" style="zoom: 25%;" />
<blockquote>
<p><strong>项目地址</strong>：<a href="https://github.com/hmxsqaq/Unity-2048-New">https://github.com/hmxsqaq/Unity-2048-New</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Projects</category>
        <category>经典小游戏复刻</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>GameProject</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/css/font.css</url>
    <content><![CDATA[@font-face{font-family:mononoki;font-display:swap;src:url('../fonts/mononoki-Regular.ttf') format("truetype")}@font-face{font-family:LXGWWenKaiGBLite;font-display:swap;src:url('../fonts/LXGWWenKaiGBLite-Medium.ttf') format("truetype")}]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/custom_loading.css</url>
    <content><![CDATA[.loading-img{background:url(https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202312251233199.jpeg) no-repeat center center;background-size:cover}]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[<img src="https://hmxs-1315810738.cos.ap-shanghai.myqcloud.com/img/202303231227575.jpg" style="zoom: 33%;" />
<h2 id="Who-am-I？">Who am I？</h2>
<p>你好！我是徽墨 🤣👉<s>真名就不说了，把头像po上面已经够羞耻的了</s></p>
<p>目前就读于<code>中国传媒大学-动画与数字艺术学院-数字媒体技术（游戏设计技术专业）</code></p>
<p>正在为了成为一名合格的游戏程序而努力，未来想去<code>USC</code>/<code>CMU</code>/<code>Utah</code>进修游戏开发相关专业（被英语折磨中）</p>
<p>人格测试是<code>INTP-A</code> ，<s>半年前还是ISFJ来着🤨</s></p>
<h2 id="Interests">Interests</h2>
<p>ACG爱好者，单机天龙人，动漫宅，阴暗逼；喜欢整理东西、写博客、收藏掌机/设定集/游戏盘/手办等各种奇奇怪怪的东西</p>
<ul>
<li>
<p>游戏方面：Switch/3DS/PSV/PC玩家，最喜欢的游戏是<code>十三机兵防卫圈</code>和<code>塞尔达传说系列</code>，铁血任豚，但也玩MOBA（LOL大乱斗）、二次元手游（公主连结）、TCG（影之诗）；总之除了FPS（<s>打不准啊</s>）什么都玩一点，但都不精通</p>
</li>
<li>
<p>动漫方面：最喜欢的番是<code>Clannad</code>，每季新番都会追，看番没有特别的倾向</p>
</li>
<li>
<p>技术方面：喜欢捣鼓效率和美化工具，喜欢做游戏，目前在用的游戏引擎是<code>Unity</code></p>
</li>
<li>
<p>音乐方面：主要听摇滚、JPOP、ACG相关歌曲，最喜欢的乐队是<code>One OK Rock</code>和<code>My First Stroy</code></p>
</li>
</ul>
<h2 id="Skills">Skills</h2>
<ul>
<li>[x] 一点点C#与Unity</li>
<li>[x] 一点点Python</li>
<li>[x] 一点点C/C++</li>
<li>[x] 一点点游戏设计</li>
</ul>
<h2 id="Projects">Projects</h2>
<p>这里是我参与的一些游戏相关项目</p>
<table>
<thead>
<tr>
<th style="text-align:center">Projects</th>
<th style="text-align:center">Introduction</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/1/">《Revive》UE GameJam 2022</a></td>
<td style="text-align:center">主题为「自私的基因」，一款以怀胎体验为核心的严肃游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/2/">《躲避病毒》严肃游戏工坊作品</a></td>
<td style="text-align:center">一款诞生于疫情大背景下，以传递防疫知识为目的的益智小游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/3/">《Cyberpsychosis》AI GameJam 2023</a></td>
<td style="text-align:center">主题为「和谐的缝合怪」，50%美术资源由AI完成，一款将“推箱子”与“联合移动”机制相结合的游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/5/">《SCP》游戏创作1 week3</a></td>
<td style="text-align:center">主题为「SCP」，一款以黑暗、神秘、恐怖为核心的2D冒险游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/6/">《辟邪傩狮》游创1 结课</a></td>
<td style="text-align:center">CUC游戏创作1课程结课作品，一款结合传统舞狮文化的2d平台跳跃游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/7/">《电击小子》CiGA GameJam 2023</a></td>
<td style="text-align:center">主题为「Touch」，一款以冬天静电电人为灵感的恶搞休闲游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/4/">《联机象棋》游戏编程实训</a></td>
<td style="text-align:center">CUC游戏编程实训课程结课作品，一款基于C语言的可点对点联机的中国象棋游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/8/">《Just Suck》吉比特GameJam 2023</a></td>
<td style="text-align:center">三等奖作品，Jam主题为「吸收」，一款极简设计风格的休闲游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/9/">《吹气球》游戏创作2 week1</a></td>
<td style="text-align:center">CUC游戏创作2第一次作业，一款机制简单但欢乐的派对休闲游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/10/">《BlindTrust》游戏创作2 week3</a></td>
<td style="text-align:center">CUC游戏创作2第三次作业，一个简易的模拟盲人出行模拟器，使用了网络联机技术</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/11/">《AssAssIn》游戏创作2 结课</a></td>
<td style="text-align:center">CUC游戏创作2课程结课作品，一款动效华丽的双人对战派对游戏</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/12/">从零开始的C++软光栅渲染器</a></td>
<td style="text-align:center">一个微型 C++ 软光栅渲染器，可以进行简单的渲染</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/hmxsqaq/Unity-Framework">Unity小游戏框架-练习用</a></td>
<td style="text-align:center">为Unity开发的一套适用于小游戏的游戏框架，包含了对象池、事件中心、音频UI管理器等模块</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/hmxsqaq/Unity-HmxsToolkit">Hmxs Toolkit</a></td>
<td style="text-align:center">一个个人Toolkit项目，会记录一些自己写<s>Ctrl+C/V</s>的Unity模块/功能/系统/轮子</td>
</tr>
</tbody>
</table>
<h2 id="Notes">Notes</h2>
<p>这里是我的一些学习笔记</p>
<table>
<thead>
<tr>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Introduction</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/100/">【3B1B-线性代数的本质】学习笔记</a></td>
<td style="text-align:center">通过 3Blue1Brown 的《线性代数的本质》系列视频复习线性代数</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/1001/">【The Cherno-C++】学习笔记</a></td>
<td style="text-align:center">通过 The Cherno 的系列视频学习 C++</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/104/">【C#-反射】学习笔记</a></td>
<td style="text-align:center">整理了 C# 中反射的原理与相关知识</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/103/">【C#-泛型约束】学习笔记</a></td>
<td style="text-align:center">对C#中的泛型约束与应用的知识点整理</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/105/">【Unity-Input System】学习笔记</a></td>
<td style="text-align:center">对Unity中的新输入系统 Input System 的原理与使用方法整理</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/106/">【Unity-Timeline】学习笔记</a></td>
<td style="text-align:center">对Unity中的强大的可视化工具 Timeline 的学习笔记</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/101/">【GAMES101】学习笔记</a></td>
<td style="text-align:center">通过大名鼎鼎的GAMES101系列课程入门图形学</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/2000/">《游戏编程模式》读书笔记（更新中）</a></td>
<td style="text-align:center">通过《游戏编程模式》一书学习游戏开发中的设计模式</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://hmxs.games/posts/4000/">《算法4》读书笔记（更新中）</a></td>
<td style="text-align:center">大名鼎鼎的《算法:第四版》的读书笔记</td>
</tr>
</tbody>
</table>
<h2 id="一些碎碎念">一些碎碎念</h2>
<p>不知道为什么突然想写个About me，嘛，反正也没人看，就当是一些对自己的评价吧</p>
<p>不知不觉已经上了快两年大学了，感觉经历了很多，但是好像也没干什么<s>我搁这搁这呢</s>，从入校到转专业再到现在，认识了很多很优秀的人，有时候看到他们真的会很焦虑啊🙃</p>
<p>但是想来这样也挺好的吧，追赶他们或许可以成为我的动力之一？</p>
<p>总之无论如何，虽然不会的东西越学越多，身边的大佬也越来越哈人，但是总是找到了一点点目标与梦想，至少现在能知道自己想干什么，能学什么</p>
<p>如果你能看到这里的话，<strong>前路漫漫，与君共勉。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/hmxs_custom.css</url>
    <content><![CDATA[#web_bg{filter:blur(3px) brightness(70%)}#footer{background:0 0!important}#page-header{background:0 0!important}#footer::before{background:0 0!important}#page-header::before{background:0 0!important}[data-theme=dark] #footer::before{background:0 0!important}[data-theme=dark] #page-header::before{background:0 0!important}]]></content>
  </entry>
  <entry>
    <title>友链</title>
    <url>/link/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/progress_bar.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:2000;position:fixed;margin:auto;top:10px;left:0;right:0;height:8px;border-radius:8px;width:4rem;background:#eaecf2;border:1px #e3e8f7;overflow:hidden}.pace-inactive .pace-progress{opacity:0;transition:.3s ease-in}.pace .pace-progress{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0);max-width:200px;position:absolute;z-index:2000;display:block;top:0;right:100%;height:100%;width:100%;background:linear-gradient(-45deg,#ee7752,#e73c7e,#23a6d5,#23d5ab);animation:gradient 1.5s ease infinite;background-size:200%}.pace.pace-inactive{opacity:0;transition:.3s;top:-8px}@keyframes gradient{0%{background-position:0 50%}50%{background-position:100% 50%}100%{background-position:0 50%}}]]></content>
  </entry>
</search>
